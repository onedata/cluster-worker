#!/bin/bash

# Display usage help
error_bad_args()
{
	echo "Usage:"
	echo "variant 1: (argument order can be arbitrary)"
	echo "	$0 -name node_name@host -main_ccm main_ccm_node@host [-opt_ccms opt_ccm_node1@host opt_ccm_node2@host ...] -db_nodes dbnode1@host dbnode2@host ..."
	echo " "
	echo "variant 2: (file 'gen_dev.args' with arguments present in script directory)"
	echo "	$0"
	echo " "
	echo "Additional parameters: (acceptable in both variants)"
	echo "-no_compile -> skip code compilation straight to release generation."
	echo "-no_generate -> skip code compilation and release generation (creates a copy of existing release)."	
	exit 1	
}

# Function used to retrieve a parameter from script arguments. 
# args: 
# $1: <<script arguments>>   (arguments passed to the script; $*)
# $2: <<token of desired parameter>>    (eg. '-main_ccm' to retrieve main ccm name)
# $3: <<single|list>>      (expecting result as a single term or a list?)
# 
# The function starts reading parameters after ocurrence of desired token and continues for one word (single) or until it stumbles upon
# another token starting with '-' or end of line (list)
get_parameter_from_args()
{
	local ARGS=$1
	local TOKEN=$2
	local RETURN_OPTION=$3

	# Find the occurence of desired token. If there isn't one, there was no parameter value specified = error. 
	# Exception: -opt_ccms could have been left empty intentionally.
	local INDEX=`awk -v a=" $ARGS " -v b=" $TOKEN " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -eq 0 ]]; then
		if [[ $TOKEN == '-opt_ccms' ]]; then
			RESULT=""
			return
		else
			echo " "
			echo "Error: missing parameter"
			echo "'$TOKEN' must occur in script arguments."
			echo "Terminating."
			echo " "
			error_bad_args
			exit 1
		fi
	fi

	# Trim the arguments string so that it starts after the token
	local ARGS=${ARGS:$(($INDEX + ${#TOKEN})):${#ARGS}}

	# Find the next occurence of a hyphen 
	INDEX=`awk -v a="$ARGS" -v b="-" 'BEGIN{print index(a, b)}'`

	# If its zero, the ARGS variable holds the desired string. If not, cut off the part after the hyphen
	if [[ $INDEX -gt 0 ]]; then
		ARGS=${ARGS:0:$(($INDEX - 1))}
	fi

	# If the expected result is a single word, get the first one from remaining string. 
	# This somehow resolves errors like passing a double word 'name' parameter.
	if [[ $RETURN_OPTION == "single" ]]; then
		ARGS=`echo $ARGS | cut -f1 -d' '`
	else
		ARGS=`echo $ARGS`          # trims spaces from the beginning of the list
	fi

	# If the result is empty, there was no parameter value specified = error. Exception: -opt_ccms could have been left empty intentionally.
	if [[ $ARGS == "" ]]; then
		if [[ $TOKEN == '-opt_ccms' ]]; then
			RESULT=""
			return
		else
			echo " "
			echo "Error: missing parameter"
			echo "'$TOKEN' must occur in script arguments."
			echo "Terminating."
			echo " "
			error_bad_args
			exit 1
		fi
	fi

	# "return" the parameter(s)
	RESULT=$ARGS
}

# Enter the script directory
PATH_TO_SCRIPT=`echo $0 | sed "s/gen_dev//g"`
cd $PATH_TO_SCRIPT

# Accepting only no args, -no_compile or -no_generate and reading from file. Otherwise all args have to be passed via args
if [[ $# -eq 0 ]] || 
	[[ $# -eq 1  && $1 == "-no_compile" ]] || 
	[[ $# -eq 1  && $1 == "-no_generate" ]]; then
	# Check for .args file
	if [[ -f gen_dev.args ]]; then
		# Get args from 
		ARGS=`cat gen_dev.args`
		# And execute the script with the args from there
		if [[ $1 == "" ]]; then
			echo "Using arguments from gen_dev.args"
		else
			echo "Using arguments from gen_dev.args with $1 option"			
		fi
		./gen_dev $ARGS $1
		exit 0
	else
		# Error; no args file
		error_bad_args
	fi
fi


#####################################
# GATHER ARGS

# Get node name from script args
get_parameter_from_args "$*" -name single
NODE_NAME=$RESULT

# Get main_ccm name from script args
get_parameter_from_args "$*" -main_ccm single
MAIN_CCM=$RESULT

# Get opt_ccms from script args
get_parameter_from_args "$*" -opt_ccms list
OPT_CCMS=$RESULT

# Get db_nodes from script args
get_parameter_from_args "$*" -db_nodes list
DB_NODES=$RESULT

# Get short node name (without hostname)
AT_INDEX=`expr index "$NODE_NAME" @`
if [[ $AT_INDEX -gt 0 ]]; then
	NODE_NAME_WITHOUT_HOSTNAME=${NODE_NAME:0:(($AT_INDEX - 1))}
else
	NODE_NAME_WITHOUT_HOSTNAME=$NODE_NAME
fi

echo " "
echo "========================================"
echo "Generating release for $NODE_NAME in    /releases/$NODE_NAME_WITHOUT_HOSTNAME"

# Skip generation if -no_generate is in args
INDEX=`awk -v a=" $* " -v b=" -no_generate " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -eq 0 ]]; then

	# Skip compilation if -no_compile is in args
	INDEX=`awk -v a=" $* " -v b=" -no_compile " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -eq 0 ]]; then
		# Compile the code
		./rebar compile
	fi

	# Generate the release
	./rebar generate
else
	# User requested to skip release generation
	if [[ ! -d releases/veil_cluster_node ]]; then
		echo "Error: no release found"
		echo "Cannot skip release generation - no release package found."
		echo "Try executing the script without -no_generate option."
		echo "Terminating."
		exit 1
	fi
fi

# Remove old release
rm -r releases/$NODE_NAME_WITHOUT_HOSTNAME 2>/dev/null

# Copy the release package to proper location (directory named as the node without hostname), preserve mode
cp -R -p releases/veil_cluster_node releases/$NODE_NAME_WITHOUT_HOSTNAME

# Execute the apply_config script with proper arguments
./releases/$NODE_NAME_WITHOUT_HOSTNAME/config/apply_config -name $NODE_NAME -main_ccm $MAIN_CCM -opt_ccms $OPT_CCMS -db_nodes $DB_NODES

# Get IP address to use it as the cookie
IFCONFIG_LINE=`ifconfig | grep "inet addr:.*Bcast:"`
COLON_INDEX=`awk -v a="$IFCONFIG_LINE" -v b=":" 'BEGIN{print index(a, b)}'`
BCAST_INDEX=`awk -v a="$IFCONFIG_LINE" -v b="Bcast" 'BEGIN{print index(a, b)}'`
COOKIE=${IFCONFIG_LINE:COLON_INDEX:((BCAST_INDEX - COLON_INDEX - 3))}

# Get application version
START_ERL=`cat releases/$NODE_NAME_WITHOUT_HOSTNAME/releases/start_erl.data`
APP_VSN=${START_ERL#* }

# Replace the cookie
sed -i "s/-setcookie.*/-setcookie '$COOKIE'/g" releases/$NODE_NAME_WITHOUT_HOSTNAME/releases/$APP_VSN/vm.args

echo "Cookie set to: $COOKIE"

exit 0