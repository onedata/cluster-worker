<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/sequencer_stream.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/modules/sequencer_manager/sequencer_stream.erl by COVER 2015-08-06 at 11:00:45

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Krzysztof Trzepla
        |  %%% @copyright (C) 2015 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc
        |  %%% This module implements gen_server behaviour and is responsible
        |  %%% for sorting messages in ascending order of sequence number and forwarding
        |  %%% them to the router.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(sequencer_stream).
        |  -author("Krzysztof Trzepla").
        |  
        |  -behaviour(gen_server).
        |  
        |  -include("global_definitions.hrl").
        |  -include("proto/oneclient/client_messages.hrl").
        |  -include("proto/oneclient/stream_messages.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  %% API
        |  -export([start_link/3]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,
        |      code_change/3]).
        |  
        |  %% sequencer stream state:
        |  %% stream_id            - stream ID associated with sequencer
        |  %% sequence_number      - sequence number of message that can be processed by
        |  %%                        sequencer stream
        |  %% sequence_number_ack  - sequence number of last acknowledge message
        |  %% messages             - mapping from sequence number to message for messages
        |  %%                        waiting to be processed by sequencer stream
        |  %% sequencer_manager    - pid of sequencer manager
        |  %% messages_ack_window  - amount of messages that have to be processed by
        |  %%                        sequencer stream before emissions of acknowledgement
        |  %%                        message
        |  %% time_ack_window      - amount of seconds that have to elapsed before emission
        |  %%                        of acknowledgement message
        |  -record(state, {
        |      session_id :: session:id(),
        |      sequencer_manager :: pid(),
        |      sequence_number = 0 :: non_neg_integer(),
        |      sequence_number_ack = -1 :: -1 | non_neg_integer(),
        |      stream_id :: integer(),
        |      messages = #{} :: map(),
        |      messages_ack_window :: non_neg_integer(),
        |      time_ack_window :: non_neg_integer()
        |  }).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Starts the server.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec start_link(SeqMan :: pid(), SessId :: session:id(), StmId :: non_neg_integer()) -&gt;
        |      {ok, Pid :: pid()} | ignore | {error, Reason :: term()}.
        |  start_link(SeqMan, SessId, StmId) -&gt;
    13..|      gen_server:start_link(?MODULE, [SeqMan, SessId, StmId], []).
        |  
        |  %%%===================================================================
        |  %%% gen_server callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Initializes the server.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init(Args :: term()) -&gt;
        |      {ok, State :: #state{}} | {ok, State :: #state{}, timeout() | hibernate} |
        |      {stop, Reason :: term()} | ignore.
        |  init([SeqMan, SessId, StmId]) -&gt;
    13..|      process_flag(trap_exit, true),
    13..|      gen_server:cast(self(), initialize),
    13..|      {ok, #state{sequencer_manager = SeqMan, session_id = SessId, stream_id = StmId}}.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handles call messages.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_call(Request :: term(), From :: {pid(), Tag :: term()},
        |      State :: #state{}) -&gt;
        |      {reply, Reply :: term(), NewState :: #state{}} |
        |      {reply, Reply :: term(), NewState :: #state{}, timeout() | hibernate} |
        |      {noreply, NewState :: #state{}} |
        |      {noreply, NewState :: #state{}, timeout() | hibernate} |
        |      {stop, Reason :: term(), Reply :: term(), NewState :: #state{}} |
        |      {stop, Reason :: term(), NewState :: #state{}}.
        |  handle_call(_Request, _From, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {reply, ok, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handles cast messages.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_cast(Request :: term(), State :: #state{}) -&gt;
        |      {noreply, NewState :: #state{}} |
        |      {noreply, NewState :: #state{}, timeout() | hibernate} |
        |      {stop, Reason :: term(), NewState :: #state{}}.
        |  handle_cast(initialize, #state{sequencer_manager = SeqMan, stream_id = StmId} = State) -&gt;
    13..|      {ok, MsgsAckWin} = application:get_env(?APP_NAME,
        |          sequencer_stream_messages_ack_window),
    13..|      {ok, TimeAckWin} = application:get_env(?APP_NAME,
        |          sequencer_stream_seconds_ack_window),
    13..|      erlang:send_after(timer:seconds(TimeAckWin), self(), periodic_ack),
    13..|      case gen_server:call(SeqMan, {sequencer_stream_initialized, StmId}) of
        |          {ok, #state{} = SeqStmState} -&gt;
     1..|              ?info("Sequencer stream reinitialized in state: ~p", [SeqStmState]),
     1..|              {noreply, SeqStmState#state{messages_ack_window = MsgsAckWin,
        |                  time_ack_window = TimeAckWin}};
        |          _ -&gt;
    12..|              {noreply, State#state{messages_ack_window = MsgsAckWin,
        |                  time_ack_window = TimeAckWin}}
        |      end;
        |  
        |  handle_cast(#client_message{message_stream = #message_stream{sequence_number = SeqNum}} =
        |      Msg, #state{sequence_number = SeqNum} = State) -&gt;
   148..|      process_pending_messages(process_message(Msg, State));
        |  
        |  handle_cast(#client_message{message_stream = #message_stream{sequence_number = MsgSeqNum}} =
        |      Msg, #state{sequence_number = SeqNum} = State) when
        |      is_integer(MsgSeqNum), MsgSeqNum &gt; SeqNum -&gt;
   238..|      {noreply, send_message_request(Msg, store_message(Msg, State))};
        |  
        |  handle_cast(#client_message{}, State) -&gt;
   490..|      {noreply, State};
        |  
        |  handle_cast(_Request, State) -&gt;
     1..|      ?log_bad_request(_Request),
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handles all non call/cast messages.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_info(Info :: timeout() | term(), State :: #state{}) -&gt;
        |      {noreply, NewState :: #state{}} |
        |      {noreply, NewState :: #state{}, timeout() | hibernate} |
        |      {stop, Reason :: term(), NewState :: #state{}}.
        |  handle_info(periodic_ack, #state{sequence_number_ack = SeqNumAck,
        |      sequence_number = SeqNum, time_ack_window = TimeAckWin} = State) -&gt;
    19..|      erlang:send_after(timer:seconds(TimeAckWin), self(), periodic_ack),
    19..|      case SeqNumAck + 1 =:= SeqNum of
    14..|          true -&gt; {noreply, State};
     5..|          _ -&gt; {noreply, send_message_ack(State)}
        |      end;
        |  
        |  handle_info(_Info, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Info),</font>
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% This function is called by a gen_server when it is about to
        |  %% terminate. It should be the opposite of Module:init/1 and do any
        |  %% necessary cleaning up. When it returns, the gen_server terminates
        |  %% with Reason. The return value is ignored.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate(Reason :: (normal | shutdown | {shutdown, term()} | term()),
        |      State :: #state{}) -&gt; term().
        |  terminate(Reason, #state{stream_id = StmId, sequencer_manager = SeqMan} = State) -&gt;
    13..|      NewState = send_message_ack(State),
    13..|      ?log_terminate(Reason, NewState),
    13..|      gen_server:cast(SeqMan, {sequencer_stream_terminated, StmId, Reason, NewState}).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Converts process state when code is changed.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec code_change(OldVsn :: term() | {down, term()}, State :: #state{},
        |      Extra :: term()) -&gt; {ok, NewState :: #state{}} | {error, Reason :: term()}.
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Forward message to the router and sends periodic acknowledgement messages.
        |  %% Returns modified sequencer state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec process_message(Msg :: #client_message{}, State :: #state{}) -&gt;
        |      {stop, shutdown, NewState :: #state{}} |
        |      {noreply, NewState :: #state{}}.
        |  process_message(#client_message{message_stream = #message_stream{},
        |      message_body = #end_of_message_stream{}} = Msg, State) -&gt;
     1..|      NewState = send_message(Msg, State),
     1..|      {stop, shutdown, NewState};
        |  
        |  process_message(#client_message{message_stream = #message_stream{
        |      sequence_number = MsgSeqNum}} = Msg, #state{sequence_number_ack = SeqNumAck,
        |      messages_ack_window = MsgsAckWin} = State) -&gt;
   385..|      NewState = send_message(Msg, State),
   385..|      case MsgSeqNum =:= SeqNumAck + MsgsAckWin of
     2..|          true -&gt; {noreply, send_message_ack(NewState)};
   383..|          false -&gt; {noreply, NewState}
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Processes pending messages by calling process_message/2 function on messages
        |  %% with sequence number equal to current sequence number. Returns modified
        |  %% sequencer state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec process_pending_messages({stop, shutdown, State :: #state{}} | {noreply,
        |      State :: #state{}}) -&gt; {stop, shutdown, NewState :: #state{}} |
        |  {noreply, NewState :: #state{}}.
        |  process_pending_messages({stop, shutdown, State}) -&gt;
     1..|      {stop, shutdown, State};
        |  
        |  process_pending_messages({noreply, #state{sequence_number = SeqNum,
        |      messages = Msgs} = State}) -&gt;
   385..|      case maps:find(SeqNum, Msgs) of
        |          {ok, Msg} -&gt;
   238..|              process_pending_messages(process_message(Msg, remove_message(Msg, State)));
        |          _ -&gt;
   147..|              {noreply, State}
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Forwards message to the router.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send_message(Msg :: #client_message{}, State :: #state{}) -&gt;
        |      NewState :: #state{}.
        |  send_message(Msg, #state{sequence_number = SeqNum} = State) -&gt;
   386..|      router:route_message(Msg),
   386..|      State#state{sequence_number = SeqNum + 1}.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Sends acknowledgement to the client informing about sequence number of last
        |  %% successfully processed message.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send_message_ack(State :: #state{}) -&gt; NewState :: #state{}.
        |  send_message_ack(#state{stream_id = StmId, session_id = SessId,
        |      sequence_number = SeqNum} = State) -&gt;
    20..|      Msg = #message_acknowledgement{stream_id = StmId, sequence_number = SeqNum - 1},
    20..|      ok = communicator:send(Msg, SessId),
    20..|      State#state{sequence_number_ack = SeqNum - 1}.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Sends request to the client for messages with sequence number
        |  %% ranging from expected sequence number to sequence number proceeding sequence
        |  %% number of received message.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send_message_request(Msg :: #client_message{}, State :: #state{}) -&gt;
        |      NewState :: #state{}.
        |  send_message_request(#client_message{message_stream = #message_stream{
        |      stream_id = StmId, sequence_number = MsgSeqNum}}, #state{session_id = SessId,
        |      sequence_number = SeqNum} = State) -&gt;
   238..|      Msg = #message_request{
        |          stream_id = StmId, lower_sequence_number = SeqNum, upper_sequence_number = MsgSeqNum - 1
        |      },
   238..|      ok = communicator:send(Msg, SessId),
   238..|      State.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Stores message in sequencer stream state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec store_message(Msg :: #client_message{}, State :: #state{}) -&gt;
        |      NewState :: #state{}.
        |  store_message(#client_message{message_stream = #message_stream{sequence_number = SeqNum}} =
        |      Msg, #state{messages = Msgs} = State) -&gt;
   238..|      State#state{messages = maps:put(SeqNum, Msg, Msgs)}.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Removes message from sequencer stream state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec remove_message(Msg :: #client_message{}, State :: #state{}) -&gt;
        |      NewState :: #state{}.
        |  remove_message(#client_message{message_stream = #message_stream{sequence_number = SeqNum}},
        |      #state{messages = Msgs} = State) -&gt;
   238..|      State#state{messages = maps:remove(SeqNum, Msgs)}.</pre>
</body>
</html>
