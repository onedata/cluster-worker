<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/nagios_handler.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/modules/http_worker/nagios/nagios_handler.erl by COVER 2015-08-06 at 11:00:42

****************************************************************************

        |  %%%--------------------------------------------------------------------
        |  %%% @author Lukasz Opiola
        |  %%% @copyright (C) 2015 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%--------------------------------------------------------------------
        |  %%% @doc
        |  %%% This module handles Nagios monitoring requests.
        |  %%% @end
        |  %%%--------------------------------------------------------------------
        |  -module(nagios_handler).
        |  -author("Lukasz Opiola").
        |  
        |  -behaviour(cowboy_http_handler).
        |  
        |  -include("global_definitions.hrl").
        |  -include("modules_and_args.hrl").
        |  -include_lib("xmerl/include/xmerl.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  -include_lib("ctool/include/global_definitions.hrl").
        |  
        |  -export([init/3, handle/2, terminate/3]).
        |  -export([get_cluster_status/1]).
        |  
        |  -export_type([healthcheck_response/0]).
        |  
        |  % ErrorDesc will appear in xml as node status.
        |  -type healthcheck_response() :: ok | out_of_sync | {error, ErrorDesc :: atom()}.
        |  
        |  -ifdef(TEST).
        |  -compile(export_all).
        |  -endif.
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, no state is required
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init(term(), term(), term()) -&gt; {ok, cowboy_req:req(), term()}.
        |  init(_Type, Req, _Opts) -&gt;
    85..|      {ok, Req, []}.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Handles a request producing an XML response.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle(term(), term()) -&gt; {ok, cowboy_req:req(), term()}.
        |  handle(Req, State) -&gt;
    85..|      {ok, Timeout} = application:get_env(?APP_NAME, nagios_healthcheck_timeout),
    85..|      {ok, CachingTime} = application:get_env(?APP_NAME, nagios_caching_time),
    85..|      CachedResponse = case application:get_env(?APP_NAME, nagios_cache) of
        |                           {ok, {LastCheck, LastValue}} -&gt;
     3..|                               case utils:milliseconds_diff(now(), LastCheck) &lt; CachingTime of
        |                                   true -&gt;
     2..|                                       ?debug("Serving nagios response from cache"),
     2..|                                       {true, LastValue};
        |                                   false -&gt;
     1..|                                       false
        |                               end;
        |                           _ -&gt;
    82..|                               false
        |                       end,
    85..|      ClusterStatus = case CachedResponse of
        |                          {true, Value} -&gt;
     2..|                              Value;
        |                          false -&gt;
    83..|                              Status = get_cluster_status(Timeout),
        |                              % Save cluster state in cache, but only if there was no error
    83..|                              case Status of
        |                                  {ok, {?APP_NAME, ok, _}} -&gt;
    27..|                                      application:set_env(?APP_NAME, nagios_cache, {now(), Status});
        |                                  _ -&gt;
    56..|                                      skip
        |                              end,
    83..|                              Status
        |                      end,
    85..|      NewReq =
        |          case ClusterStatus of
        |              error -&gt;
    47..|                  {ok, Req2} = opn_cowboy_bridge:apply(cowboy_req, reply, [500, Req]),
    47..|                  Req2;
        |              {ok, {?APP_NAME, AppStatus, NodeStatuses}} -&gt;
    38..|                  MappedClusterState = lists:map(
        |                      fun({Node, NodeStatus, NodeComponents}) -&gt;
    93..|                          NodeDetails = lists:map(
        |                              fun({Component, Status}) -&gt;
   651..|                                  StatusList = case Status of
    17..|                                                   {error, Desc} -&gt; "error: " ++ atom_to_list(Desc);
   634..|                                                   _ -&gt; atom_to_list(Status)
        |                                               end,
   651..|                                  {Component, [{status, StatusList}], []}
        |                              end, NodeComponents),
    93..|                          {?APP_NAME, [{name, atom_to_list(Node)}, {status, atom_to_list(NodeStatus)}], NodeDetails}
        |                      end, NodeStatuses),
        |  
    38..|                  {{YY, MM, DD}, {Hour, Min, Sec}} = calendar:now_to_local_time(now()),
    38..|                  DateString = gui_str:format("~4..0w/~2..0w/~2..0w ~2..0w:~2..0w:~2..0w", [YY, MM, DD, Hour, Min, Sec]),
        |  
        |                  % Create the reply
    38..|                  Healthdata = {healthdata, [{date, DateString}, {status, atom_to_list(AppStatus)}], MappedClusterState},
    38..|                  Content = lists:flatten([Healthdata]),
    38..|                  Export = xmerl:export_simple(Content, xmerl_xml),
    38..|                  Reply = io_lib:format("~s", [lists:flatten(Export)]),
        |  
        |                  % Send the reply
    38..|                  {ok, Req2} = opn_cowboy_bridge:apply(cowboy_req, reply,
        |                      [200, [{&lt;&lt;"content-type"&gt;&gt;, &lt;&lt;"application/xml"&gt;&gt;}], Reply, Req]),
    38..|                  Req2
        |          end,
    85..|      {ok, NewReq, State}.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, no cleanup needed.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate(term(), term(), term()) -&gt; ok.
        |  terminate(_Reason, _Req, _State) -&gt;
    85..|      ok.
        |  
        |  
        |  %% ====================================================================
        |  %% Internal Functions
        |  %% ====================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Contacts all components of the cluster and produces a healthcheck report
        |  %% in following form:
        |  %% {op_worker, AppStatus, [
        |  %%     {Node1, Node1Status, [
        |  %%         {node_manager, NodeManStatus},
        |  %%         {request_dispatcher, DispStatus},
        |  %%         {Worker1, W1Status},
        |  %%         {Worker2, W2Status},
        |  %%         {Worker3, W3Status},
        |  %%     ]},
        |  %%     {Node2, Node2Status, [
        |  %%         ...
        |  %%     ]}
        |  %% ]}
        |  %% Status can be: ok | out_of_sync | error | atom()
        |  %%
        |  %% If CCM cannot be contacted, the function returns 'error' atom.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_cluster_status(Timeout :: integer()) -&gt; error | {ok, ClusterStatus} when
        |      Status :: healthcheck_response(),
        |      ClusterStatus :: {?APP_NAME, Status, NodeStatuses :: [
        |          {node(), Status, [
        |              {ModuleName :: module(), Status}
        |          ]}
        |      ]}.
        |  get_cluster_status(Timeout) -&gt;
    83..|      case check_ccm(Timeout) of
        |          error -&gt;
    47..|              error;
        |          Nodes -&gt;
    36..|              try
    36..|                  NodeManagerStatuses = check_node_managers(Nodes, Timeout),
    36..|                  DistpatcherStatuses = check_dispatchers(Nodes, Timeout),
    36..|                  Workers = [{Node, Name} || Node &lt;- Nodes, Name &lt;- ?MODULES],
    36..|                  WorkerStatuses = check_workers(Nodes, Workers, Timeout),
    36..|                  {ok, _} = calculate_cluster_status(Nodes, NodeManagerStatuses, DistpatcherStatuses, WorkerStatuses)
        |              catch
        |                  Type:Error -&gt;
<font color=red>     0..|                      ?error_stacktrace("Unexpected error during healthcheck: ~p:~p", [Type, Error]),</font>
<font color=red>     0..|                      error</font>
        |              end
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Creates a proper term expressing cluster health,
        |  %% constructing it from statuses of all components.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec calculate_cluster_status(Nodes, NodeManagerStatuses, DistpatcherStatuses, WorkerStatuses) -&gt; {ok, ClusterStatus} when
        |      Nodes :: [Node],
        |      NodeManagerStatuses :: [{Node, Status}],
        |      DistpatcherStatuses :: [{Node, Status}],
        |      WorkerStatuses :: [{Node, [{Worker :: atom(), Status}]}],
        |      Node :: node(),
        |      Status :: healthcheck_response(),
        |      ClusterStatus :: {?APP_NAME, Status, NodeStatuses :: [
        |          {node(), Status, [
        |              {ModuleName :: module(), Status}
        |          ]}
        |      ]}.
        |  calculate_cluster_status(Nodes, NodeManagerStatuses, DistpatcherStatuses, WorkerStatuses) -&gt;
    37..|      NodeStatuses =
        |          lists:map(
        |              fun(Node) -&gt;
        |                  % Get all statuses for this node
        |                  % They are all in form:
        |                  % {ModuleName, ok | out_of_sync | {error, atom()}}
    93..|                  AllStatuses = [
        |                      {?NODE_MANAGER_NAME, proplists:get_value(Node, NodeManagerStatuses)},
        |                      {?DISPATCHER_NAME, proplists:get_value(Node, DistpatcherStatuses)}
        |                      | lists:usort(proplists:get_value(Node, WorkerStatuses))
        |                  ],
        |                  % Calculate status of the whole node - it's the same as the worst status of any child
        |                  % ok &lt; out_of_sync &lt; error
        |                  % i. e. if any node component has an error, node's status will be 'error'.
    93..|                  NodeStatus = lists:foldl(
        |                      fun({_, CurrentStatus}, Acc) -&gt;
   639..|                          case {Acc, CurrentStatus} of
    11..|                              {ok, {error, _}} -&gt; error;
   581..|                              {ok, OkOrOOS} -&gt; OkOrOOS;
<font color=red>     0..|                              {out_of_sync, {error, _}} -&gt; error;</font>
     2..|                              {out_of_sync, _} -&gt; out_of_sync;
    45..|                              _ -&gt; error
        |                          end
        |                      end, ok, AllStatuses),
    93..|                  {Node, NodeStatus, AllStatuses}
        |              end, Nodes),
        |      % Calculate status of the whole application - it's the same as the worst status of any node
        |      % ok &gt; out_of_sync &gt; Other (any other atom means an error)
        |      % If any node has an error, app's status will be 'error'.
    37..|      AppStatus = lists:foldl(
        |          fun({_, CurrentStatus, _}, Acc) -&gt;
    93..|              case {Acc, CurrentStatus} of
    90..|                  {ok, Any} -&gt; Any;
<font color=red>     0..|                  {out_of_sync, ok} -&gt; out_of_sync;</font>
<font color=red>     0..|                  {out_of_sync, Any} -&gt; Any;</font>
     3..|                  _ -&gt; error
        |              end
        |          end, ok, NodeStatuses),
        |      % Sort node statuses by node name
    37..|      {ok, {?APP_NAME, AppStatus, lists:usort(NodeStatuses)}}.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Contacts CCM for healthcheck and gathers information about cluster state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec check_ccm(Timeout :: integer()) -&gt; Nodes :: [node()] | error.
        |  check_ccm(Timeout) -&gt;
    83..|      try
    83..|          {ok, Nodes} = gen_server:call({global, ?CCM}, healthcheck, Timeout),
    36..|          Nodes
        |      catch
        |          Type:Error -&gt;
    47..|              ?error("CCM error during healthcheck: ~p:~p", [Type, Error]),
    47..|              error
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Contacts node managers on given nodes for healthcheck. The check is performed in parallel (one proces per node).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec check_node_managers(Nodes :: [atom()], Timeout :: integer()) -&gt; [healthcheck_response()].
        |  check_node_managers(Nodes, Timeout) -&gt;
    36..|      utils:pmap(
        |          fun(Node) -&gt;
    89..|              Result =
        |                  try
    89..|                      gen_server:call({?NODE_MANAGER_NAME, Node}, healthcheck, Timeout)
        |                  catch T:M -&gt;
<font color=red>     0..|                      ?error("Connection error to ~p at ~p: ~p:~p", [?NODE_MANAGER_NAME, Node, T, M]),</font>
<font color=red>     0..|                      {error, timeout}</font>
        |                  end,
    89..|              {Node, Result}
        |          end, Nodes).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Contacts request dispatchers on given nodes for healthcheck. The check is performed in parallel (one proces per node).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec check_dispatchers(Nodes :: [atom()], Timeout :: integer()) -&gt; [healthcheck_response()].
        |  check_dispatchers(Nodes, Timeout) -&gt;
    36..|      utils:pmap(
        |          fun(Node) -&gt;
    89..|              Result =
        |                  try
    89..|                      gen_server:call({?DISPATCHER_NAME, Node}, healthcheck, Timeout)
        |                  catch T:M -&gt;
<font color=red>     0..|                      ?error("Connection error to ~p at ~p: ~p:~p", [?DISPATCHER_NAME, Node, T, M]),</font>
<font color=red>     0..|                      {error, timeout}</font>
        |                  end,
    89..|              {Node, Result}
        |          end, Nodes).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Contacts workers on given nodes for healthcheck. The check is performed in parallel (one proces per worker).
        |  %% Workers are grouped into one list per each node. Nodes without workers will have empty lists.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec check_workers(Nodes :: [atom()], Workers :: [{Node :: atom(), WorkerName :: atom()}], Timeout :: integer()) -&gt;
        |      [{Node :: atom(), [{Worker :: atom(), Status :: healthcheck_response()}]}].
        |  check_workers(Nodes, Workers, Timeout) -&gt;
    36..|      WorkerStatuses = utils:pmap(
        |          fun({WNode, WName}) -&gt;
   445..|              Result =
        |                  try
   445..|                      worker_proxy:call({WName, WNode}, healthcheck, Timeout)
        |                  catch T:M -&gt;
<font color=red>     0..|                      ?error("Connection error to ~p at ~p: ~p:~p", [?DISPATCHER_NAME, WNode, T, M]),</font>
<font color=red>     0..|                      {error, timeout}</font>
        |                  end,
   445..|              {WNode, WName, Result}
        |          end, Workers),
        |  
    36..|      WorkersByNode = lists:foldl(
        |          fun({WNode, WName, Status}, Proplist) -&gt;
   445..|              NewWorkerList = [{WName, Status} | proplists:get_value(WNode, Proplist, [])],
   445..|              [{WNode, NewWorkerList} | proplists:delete(WNode, Proplist)]
        |          end, [], WorkerStatuses),
        |  
        |      % If a node hosts no workers, it won't be on the WorkersByNode list, so lets add it.
    36..|      EmptyNodes = lists:foldl(
        |          fun(Node, Acc) -&gt;
    89..|              case proplists:get_value(Node, WorkersByNode) of
<font color=red>     0..|                  undefined -&gt; [{Node, []} | Acc];</font>
    89..|                  _ -&gt; Acc
        |              end
        |          end, [], Nodes),
    36..|      WorkersByNode ++ EmptyNodes.</pre>
</body>
</html>
