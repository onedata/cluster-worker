<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/datastore.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/modules/datastore/datastore.erl by COVER 2015-08-06 at 11:00:43

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Rafal Slota
        |  %%% @copyright (C) 2015 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc Main datastore API implementation.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(datastore).
        |  -author("Rafal Slota").
        |  
        |  -include("modules/datastore/datastore.hrl").
        |  -include("modules/datastore/datastore_engine.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  
        |  %% ETS name for local (node scope) state.
        |  -define(LOCAL_STATE, datastore_local_state).
        |  
        |  %% #document types
        |  -type key() :: undefined | binary() | atom() | integer().
        |  -type ext_key() :: key() | term().
        |  -type document() :: #document{}.
        |  -type value() :: term().
        |  -type document_diff() :: #{term() =&gt; term()} | fun((OldValue :: value()) -&gt; NewValue :: value()).
        |  -type bucket() :: atom() | binary().
        |  
        |  -export_type([key/0, ext_key/0, value/0, document/0, document_diff/0, bucket/0]).
        |  
        |  %% Error types
        |  -type generic_error() :: {error, Reason :: term()}.
        |  -type not_found_error(ObjectType) :: {error, {not_found, ObjectType}}.
        |  -type update_error() :: not_found_error(model_behaviour:model_type()) | generic_error().
        |  -type create_error() :: generic_error() | {error, already_exists}.
        |  -type get_error() :: not_found_error(term()) | generic_error().
        |  -type link_error() :: generic_error() | {error, link_not_found}.
        |  
        |  -export_type([generic_error/0, not_found_error/1, update_error/0, create_error/0, get_error/0, link_error/0]).
        |  
        |  %% API utility types
        |  -type store_level() :: ?DISK_ONLY_LEVEL | ?LOCAL_ONLY_LEVEL | ?GLOBAL_ONLY_LEVEL | ?LOCALLY_CACHED_LEVEL | ?GLOBALLY_CACHED_LEVEL.
        |  -type delete_predicate() :: fun(() -&gt; boolean()).
        |  -type list_fun() :: fun((Obj :: term(), AccIn :: term()) -&gt; {next, Acc :: term()} | {abort, Acc :: term()}).
        |  -type exists_return() :: boolean() | no_return().
        |  
        |  -export_type([store_level/0, delete_predicate/0, list_fun/0, exists_return/0]).
        |  
        |  %% Links' types
        |  -type normalized_link_target() :: {ext_key(), model_behaviour:model_type()}.
        |  -type link_target() :: #document{} | normalized_link_target().
        |  -type link_name() :: atom() | binary().
        |  -type link_spec() :: {link_name(), link_target()}.
        |  -type normalized_link_spec() :: {link_name(), normalized_link_target()}.
        |  
        |  
        |  -export_type([link_target/0, link_name/0, link_spec/0, normalized_link_spec/0, normalized_link_target/0]).
        |  
        |  %% API
        |  -export([save/2, save_async/2, update/4, update_async/4, create/2, create_async/2,
        |           get/3, list/4, delete/4, delete/3, exists/3]).
        |  -export([fetch_link/3, fetch_link/4, add_links/3, add_links/4, delete_links/3, delete_links/4,
        |           foreach_link/4, foreach_link/5, fetch_link_target/3, fetch_link_target/4,
        |           link_walk/4, link_walk/5]).
        |  -export([configs_per_bucket/1, ensure_state_loaded/1, healthcheck/0]).
        |  -export([run_synchronized/3]).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Saves given #document.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec save(Level :: store_level(), Document :: datastore:document()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:generic_error().
        |  save(Level, #document{} = Document) -&gt;
 18773..|      ModelName = model_name(Document),
 18773..|      exec_driver(ModelName, level_to_driver(Level), save, [maybe_gen_uuid(Document)]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Saves given #document to memory with async save to disk.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec save_async(Level :: store_level(), Document :: datastore:document()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:generic_error().
        |  save_async(Level, #document{} = Document) -&gt;
   600..|      ModelName = model_name(Document),
   600..|      exec_cache_async(ModelName, level_to_driver(Level), save, [maybe_gen_uuid(Document)]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Updates given by key document by replacing given fields with new values.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec update(Level :: store_level(), ModelName :: model_behaviour:model_type(),
        |      Key :: datastore:ext_key(), Diff :: datastore:document_diff()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:update_error().
        |  update(Level, ModelName, Key, Diff) -&gt;
  4971..|      exec_driver(ModelName, level_to_driver(Level), update, [Key, Diff]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Updates given by key document by replacing given fields with new values.
        |  %% Sync operation on memory with async operation on disk.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec update_async(Level :: store_level(), ModelName :: model_behaviour:model_type(),
        |      Key :: datastore:ext_key(), Diff :: datastore:document_diff()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:update_error().
        |  update_async(Level, ModelName, Key, Diff) -&gt;
  1200..|      exec_cache_async(ModelName, level_to_driver(Level), update, [Key, Diff]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Creates new #document.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec create(Level :: store_level(), Document :: datastore:document()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:create_error().
        |  create(Level, #document{} = Document) -&gt;
 12796..|      ModelName = model_name(Document),
 12796..|      exec_driver(ModelName, level_to_driver(Level), create, [maybe_gen_uuid(Document)]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Creates new #document. Sync operation on memory with async operation on disk.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec create_async(Level :: store_level(), Document :: datastore:document()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:create_error().
        |  create_async(Level, #document{} = Document) -&gt;
   600..|      ModelName = model_name(Document),
   600..|      exec_cache_async(ModelName, level_to_driver(Level), create, [maybe_gen_uuid(Document)]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Gets #document with given key.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get(Level :: store_level(), ModelName :: model_behaviour:model_type(),
        |      Key :: datastore:ext_key()) -&gt; {ok, datastore:document()} | datastore:get_error().
        |  get(Level, ModelName, Key) -&gt;
 35575..|      exec_driver(ModelName, level_to_driver(Level), get, [Key]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Executes given funcion for each model's record. After each record function may interrupt operation.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec list(Level :: store_level(), ModelName :: model_behaviour:model_type(), Fun :: list_fun(), AccIn :: term()) -&gt;
        |      {ok, Handle :: term()} | datastore:generic_error() | no_return().
        |  list(Level, ModelName, Fun, AccIn) -&gt;
   382..|      exec_driver(ModelName, level_to_driver(Level), list, [Fun, AccIn]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Deletes #document with given key.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete(Level :: store_level(), ModelName :: model_behaviour:model_type(),
        |      Key :: datastore:ext_key(), Pred :: delete_predicate()) -&gt; ok | datastore:generic_error().
        |  delete(Level, ModelName, Key, Pred) -&gt;
 13921..|      case exec_driver(ModelName, level_to_driver(Level), delete, [Key, Pred]) of
        |          ok -&gt;
 13921..|              spawn(fun() -&gt; catch delete_links(?DISK_ONLY_LEVEL, Key, ModelName, all) end),
 13921..|              spawn(fun() -&gt; catch delete_links(?GLOBAL_ONLY_LEVEL, Key, ModelName, all) end),
        |              %% @todo: uncomment following line when local cache will support links
        |              % spawn(fun() -&gt; catch delete_links(?LOCAL_ONLY_LEVEL, Key, ModelName, all) end),
 13921..|              ok;
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Deletes #document with given key.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete(Level :: store_level(), ModelName :: model_behaviour:model_type(),
        |      Key :: datastore:ext_key()) -&gt; ok | datastore:generic_error().
        |  delete(Level, ModelName, Key) -&gt;
 13915..|      delete(Level, ModelName, Key, ?PRED_ALWAYS).
        |  
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Checks if #document with given key exists. This method shall not be used with
        |  %% multiple drivers at once - use *_only levels.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec exists(Level :: store_level(), ModelName :: model_behaviour:model_type(),
        |      Key :: datastore:ext_key()) -&gt; {ok, boolean()} | datastore:generic_error().
        |  exists(Level, ModelName, Key) -&gt;
  3138..|      exec_driver(ModelName, level_to_driver(Level), exists, [Key]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Adds links to given document.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec add_links(Level :: store_level(), document(), link_spec() | [link_spec()]) -&gt; ok | generic_error().
        |  add_links(Level, #document{key = Key} = Doc, Links) -&gt;
   530..|      add_links(Level, Key, model_name(Doc), Links).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Adds given links to the document with given key.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec add_links(Level :: store_level(), ext_key(), model_behaviour:model_type(), link_spec() | [link_spec()]) -&gt;
        |      ok | generic_error().
        |  add_links(Level, Key, ModelName, {_LinkName, _LinkTarget} = LinkSpec) -&gt;
   283..|      add_links(Level, Key, ModelName, [LinkSpec]);
        |  add_links(Level, Key, ModelName, Links) when is_list(Links) -&gt;
   550..|      _ModelConfig = ModelName:model_init(),
   550..|      exec_driver(ModelName, level_to_driver(Level), add_links, [Key, normalize_link_target(Links)]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Removes links from given document. There is special link name 'all' which removes all links.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete_links(Level :: store_level(), document(), link_name() | [link_name()] | all) -&gt; ok | generic_error().
        |  delete_links(Level, #document{key = Key} = Doc, LinkNames) -&gt;
     6..|      delete_links(Level, Key, model_name(Doc), LinkNames).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Removes links from the document with given key. There is special link name 'all' which removes all links.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete_links(Level :: store_level(), ext_key(), model_behaviour:model_type(), link_name() | [link_name()] | all) -&gt; ok | generic_error().
        |  delete_links(Level, Key, ModelName, LinkNames) when is_list(LinkNames); LinkNames =:= all -&gt;
 28067..|      _ModelConfig = ModelName:model_init(),
 28067..|      exec_driver(ModelName, level_to_driver(Level), delete_links, [Key, LinkNames]);
        |  delete_links(Level, Key, ModelName, LinkName) -&gt;
   222..|      delete_links(Level, Key, ModelName, [LinkName]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Gets specified link from given document.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec fetch_link(Level :: store_level(), document(), link_name()) -&gt; {ok, normalized_link_target()} | link_error().
        |  fetch_link(Level, #document{key = Key} = Doc, LinkName) -&gt;
   604..|      fetch_link(Level, Key, model_name(Doc), LinkName).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Gets specified link from the document given by key.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec fetch_link(Level :: store_level(), ext_key(), model_behaviour:model_type(), link_name()) -&gt;
        |      {ok, normalized_link_target()} | generic_error().
        |  fetch_link(Level, Key, ModelName, LinkName) -&gt;
  5858..|      _ModelConfig = ModelName:model_init(),
  5858..|      exec_driver(ModelName, level_to_driver(Level), fetch_link, [Key, LinkName]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Gets document pointed by given link of given document.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec fetch_link_target(Level :: store_level(), document(), link_name()) -&gt; {ok, document()} | generic_error().
        |  fetch_link_target(Level, #document{key = Key} = Doc, LinkName) -&gt;
   205..|      fetch_link_target(Level, Key, model_name(Doc), LinkName).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Gets document pointed by given link of document given by key.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec fetch_link_target(Level :: store_level(), ext_key(), model_behaviour:model_type(), link_name()) -&gt;
        |      {ok, document()} | generic_error().
        |  fetch_link_target(Level, Key, ModelName, LinkName) -&gt;
  1029..|      case fetch_link(Level, Key, ModelName, LinkName) of
        |          {ok, _Target = {TargetKey, TargetModel}} -&gt;
   747..|              TargetModel:get(TargetKey);
        |          {error, Reason} -&gt;
   282..|              {error, Reason}
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Executes given function for each link of given document - similar to 'foldl'.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec foreach_link(Level :: store_level(), document(), fun((link_name(), link_target(), Acc :: term()) -&gt; Acc :: term()), AccIn :: term()) -&gt;
        |      {ok, Acc :: term()} | link_error().
        |  foreach_link(Level, #document{key = Key} = Doc, Fun, AccIn) -&gt;
  1239..|      foreach_link(Level, Key, model_name(Doc), Fun, AccIn).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Executes given function for each link of the document given by key - similar to 'foldl'.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec foreach_link(Level :: store_level(), Key :: ext_key(), ModelName :: model_behaviour:model_type(),
        |      fun((link_name(), link_target(), Acc :: term()) -&gt; Acc :: term()), AccIn :: term()) -&gt;
        |      {ok, Acc :: term()} | link_error().
        |  foreach_link(Level, Key, ModelName, Fun, AccIn) -&gt;
  1239..|      exec_driver(ModelName, level_to_driver(Level), foreach_link, [Key, Fun, AccIn]).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% "Walks" from link to link and fetches either all encountered documents (for Mode == get_all - not yet implemted),
        |  %% or just last document (for Mode == get_leaf). Starts on given document.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec link_walk(Level :: store_level(), document(), [link_name()], get_leaf | get_all) -&gt;
        |      {ok, document() | [document()]} | link_error() | get_error().
        |  link_walk(Level, #document{key = StartKey} = StartDoc, LinkNames, Mode) when is_atom(Mode), is_list(LinkNames) -&gt;
   826..|      link_walk(Level, StartKey, model_name(StartDoc), LinkNames, Mode).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% "Walks" from link to link and fetches either all encountered documents (for Mode == get_all - not yet implemted),
        |  %% or just last document (for Mode == get_leaf). Starts on the document given by key.
        |  %% In case of Mode == get_leaf, list of all link's uuids is also returned.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec link_walk(Level :: store_level(), Key :: ext_key(), ModelName :: model_behaviour:model_type(), [link_name()], get_leaf | get_all) -&gt;
        |      {ok, {document(), [ext_key()]} | [document()]} | link_error() | get_error().
        |  link_walk(Level, Key, ModelName, R, Mode) -&gt;
   826..|      link_walk7(Level, Key, ModelName, R, [], Mode).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Runs given function within locked ResourceId. This function makes sure that 2 funs with same ResourceId won't
        |  %% run at the same time.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec run_synchronized(ModelName :: model_behaviour:model_type(), ResourceId :: binary(), fun(() -&gt; Result)) -&gt; Result
        |      when Result :: term().
        |  run_synchronized(ModelName, ResourceId, Fun) -&gt;
   260..|      exec_driver(ModelName, ?DISTRIBUTED_CACHE_DRIVER, run_synchronized, [ResourceId, Fun]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback healthcheck/1.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec healthcheck() -&gt; ok | {error, Reason :: term()}.
        |  healthcheck() -&gt;
    89..|      case ets:info(?LOCAL_STATE) of
        |          undefined -&gt;
<font color=red>     0..|              {error, {no_ets, ?LOCAL_STATE}};</font>
    89..|          _ -&gt; ok
        |      end.
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  link_walk7(_Level, _Key, _ModelName, _Links, _Acc, get_all) -&gt;
<font color=red>     0..|      erlang:error(not_inplemented);</font>
        |  link_walk7(Level, Key, ModelName, [LastLink], Acc, get_leaf) -&gt;
   824..|      case fetch_link_target(Level, Key, ModelName, LastLink) of
        |          {ok, #document{key = LastKey} = Leaf} -&gt;
   551..|              {ok, {Leaf, lists:reverse([LastKey | Acc])}};
        |          {error, Reason} -&gt;
   273..|              {error, Reason}
        |      end;
        |  link_walk7(Level, Key, ModelName, [NextLink | R], Acc, get_leaf) -&gt;
  1535..|      case fetch_link(Level, Key, ModelName, NextLink) of
        |          {ok, {TargetKey, TargetMod}} -&gt;
  1533..|              link_walk7(Level, TargetKey, TargetMod, R, [TargetKey | Acc], get_leaf);
        |          {error, Reason} -&gt;
     2..|              {error, Reason}
        |      end.
        |  
        |  normalize_link_target([]) -&gt;
   550..|      [];
        |  normalize_link_target([Link | R]) -&gt;
   817..|      [normalize_link_target(Link) | normalize_link_target(R)];
        |  normalize_link_target({LinkName, #document{key = TargetKey} = Doc}) -&gt;
   801..|      normalize_link_target({LinkName, {TargetKey, model_name(Doc)}});
        |  normalize_link_target({_LinkName, {_TargetKey, ModelName}} = ValidLink) when is_atom(ModelName) -&gt;
   817..|      ValidLink.
        |  
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% For given #document generates key if undefined and returns updated #document structure.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec maybe_gen_uuid(document()) -&gt; document().
        |  maybe_gen_uuid(#document{key = undefined} = Doc) -&gt;
   374..|      Doc#document{key = datastore_utils:gen_uuid()};
        |  maybe_gen_uuid(#document{} = Doc) -&gt;
 32395..|      Doc.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Gets model name for given document/record.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec model_name(tuple() | document()) -&gt; atom().
        |  model_name(#document{value = Record}) -&gt;
 36980..|      model_name(Record);
        |  model_name(Record) when is_tuple(Record) -&gt;
 36980..|      element(1, Record).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Runs all pre-hooks for given model, method and context.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec run_prehooks(Config :: model_behaviour:model_config(),
        |      Method :: model_behaviour:model_action(), Level :: store_level(),
        |      Context :: term()) -&gt; ok | {error, Reason :: term()}.
        |  run_prehooks(#model_config{name = ModelName}, Method, Level, Context) -&gt;
137611..|      Hooked = ets:lookup(?LOCAL_STATE, {ModelName, Method}),
137369..|      HooksRes =
        |          lists:map(
        |              fun({_, HookedModule}) -&gt;
 55993..|                  HookedModule:before(ModelName, Method, Level, Context)
        |              end, Hooked),
137369..|      case HooksRes -- [ok] of
130674..|          [] -&gt; ok;
        |          [Interrupt | _] -&gt;
  6695..|              Interrupt
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Runs asynchronously all post-hooks for given model, method, context and
        |  %% return value. Returns given return value.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec run_posthooks(Config :: model_behaviour:model_config(),
        |      Model :: model_behaviour:model_action(), Level :: store_level(),
        |      Context :: term(), ReturnValue) -&gt; ReturnValue when ReturnValue :: term().
        |  run_posthooks(#model_config{name = ModelName}, Method, Level, Context, Return) -&gt;
137365..|      Hooked = ets:lookup(?LOCAL_STATE, {ModelName, Method}),
137360..|      lists:foreach(
        |          fun({_, HookedModule}) -&gt;
 55993..|              spawn(fun() -&gt;
 55993..|                  HookedModule:'after'(ModelName, Method, Level, Context, Return) end)
        |          end, Hooked),
137360..|      Return.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Initializes local (node scope) datastore state with given models.
        |  %% Returns initialized configuration.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec load_local_state(Models :: [model_behaviour:model_type()]) -&gt;
        |      [model_behaviour:model_config()].
        |  load_local_state(Models) -&gt;
    30..|      ets:new(?LOCAL_STATE, [named_table, public, bag]),
    30..|      lists:map(
        |          fun(ModelName) -&gt;
   240..|              Config = #model_config{hooks = Hooks} = ModelName:model_init(),
   240..|              lists:foreach(
        |                  fun(Hook) -&gt;
   420..|                      ets:insert(?LOCAL_STATE, {Hook, ModelName})
        |                  end, Hooks),
   240..|              Config
        |          end, Models).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Organizes given models into #{bucket -&gt; [model]} map.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec configs_per_bucket(Configs :: [model_behaviour:model_config()]) -&gt;
        |      #{bucket() =&gt; [model_behaviour:model_config()]}.
        |  configs_per_bucket(Configs) -&gt;
    30..|      lists:foldl(
        |          fun(#model_config{bucket = Bucket} = ModelConfig, Acc) -&gt;
   240..|              maps:put(Bucket, [ModelConfig | maps:get(Bucket, Acc, [])], Acc)
        |          end, #{}, Configs).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Runs init_bucket/1 for each datastore driver using given models'.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init_drivers(Configs :: [model_behaviour:model_config()], NodeToSync :: node()) -&gt;
        |      ok | no_return().
        |  init_drivers(Configs, NodeToSync) -&gt;
    30..|      lists:foreach(
        |          fun({Bucket, Models}) -&gt;
   240..|              ok = ?PERSISTENCE_DRIVER:init_bucket(Bucket, Models, NodeToSync),
   240..|              ok = ?LOCAL_CACHE_DRIVER:init_bucket(Bucket, Models, NodeToSync),
   240..|              ok = ?DISTRIBUTED_CACHE_DRIVER:init_bucket(Bucket, Models, NodeToSync)
        |          end, maps:to_list(configs_per_bucket(Configs))).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Loads local state, initializes datastore drivers and fetches active config
        |  %% from NodeToSync if needed.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec ensure_state_loaded(NodeToSync :: node()) -&gt; ok | {error, Reason :: term()}.
        |  ensure_state_loaded(NodeToSync) -&gt;
    30..|      try
    30..|          case ets:info(?LOCAL_STATE) of
        |              undefined -&gt;
    30..|                  Configs = load_local_state(?MODELS),
    30..|                  init_drivers(Configs, NodeToSync);
<font color=red>     0..|              _ -&gt; ok</font>
        |          end
        |      catch
        |          Type:Reason -&gt;
<font color=red>     0..|              ?error_stacktrace("Cannot initialize datastore local state due to"</font>
        |              " ~p: ~p", [Type, Reason]),
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Translates store level into list of drivers.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec level_to_driver(Level :: store_level()) -&gt; [Driver :: atom()].
        |  level_to_driver(?DISK_ONLY_LEVEL) -&gt;
 17114..|      ?PERSISTENCE_DRIVER;
        |  level_to_driver(?LOCAL_ONLY_LEVEL) -&gt;
 10073..|      ?LOCAL_CACHE_DRIVER;
        |  level_to_driver(?GLOBAL_ONLY_LEVEL) -&gt;
 76153..|      ?DISTRIBUTED_CACHE_DRIVER;
        |  level_to_driver(?LOCALLY_CACHED_LEVEL) -&gt;
  4800..|      [?LOCAL_CACHE_DRIVER, ?PERSISTENCE_DRIVER];
        |  level_to_driver(?GLOBALLY_CACHED_LEVEL) -&gt;
 19530..|      [?DISTRIBUTED_CACHE_DRIVER, ?PERSISTENCE_DRIVER].
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Reverses level_to_driver/1
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec driver_to_level(atom()) -&gt; store_level().
        |  driver_to_level(?PERSISTENCE_DRIVER) -&gt;
 53590..|      ?DISK_ONLY_LEVEL;
        |  driver_to_level(?LOCAL_CACHE_DRIVER) -&gt;
 29746..|      ?LOCAL_ONLY_LEVEL;
        |  driver_to_level(?DISTRIBUTED_CACHE_DRIVER) -&gt;
191640..|      ?GLOBAL_ONLY_LEVEL.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Executes given model action on given driver(s).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec exec_driver(model_behaviour:model_type(), [Driver] | Driver,
        |      Method :: store_driver_behaviour:driver_action(), [term()]) -&gt;
        |      ok | {ok, term()} | {error, term()} when Driver :: atom().
        |  exec_driver(ModelName, [Driver], Method, Args) when is_atom(Driver) -&gt;
  8205..|      exec_driver(ModelName, Driver, Method, Args);
        |  exec_driver(ModelName, [Driver | Rest], Method, Args) when is_atom(Driver) -&gt;
 21930..|      case exec_driver(ModelName, Driver, Method, Args) of
        |          {error, {not_found, _}} when Method =:= get -&gt;
   653..|              exec_driver(ModelName, Rest, Method, Args);
        |          {error, link_not_found} when Method =:= fetch_link -&gt;
   282..|              exec_driver(ModelName, Rest, Method, Args);
        |          {error, Reason} -&gt;
   924..|              {error, Reason};
        |          Result when Method =:= get; Method =:= fetch_link -&gt;
 12159..|              Result;
        |          {ok, true} = Result when Method =:= exists -&gt;
   642..|              Result;
        |          _ -&gt;
  7270..|              exec_driver(ModelName, Rest, Method, Args)
        |      end;
        |  exec_driver(ModelName, Driver, Method, Args) when is_atom(Driver) -&gt;
137611..|      ModelConfig = ModelName:model_init(),
137611..|      Return =
        |          case run_prehooks(ModelConfig, Method, driver_to_level(Driver), Args) of
        |              ok -&gt;
137369..|                  FullArgs = [ModelConfig | Args],
137369..|                  case Driver of
        |                      ?PERSISTENCE_DRIVER -&gt;
 26795..|                          worker_proxy:call(datastore_worker, {driver_call, Driver, Method, FullArgs});
        |                      _ -&gt;
110574..|                          erlang:apply(Driver, Method, FullArgs)
        |                  end;
        |              {error, Reason} -&gt;
<font color=red>     0..|                  {error, Reason}</font>
        |          end,
137365..|      run_posthooks(ModelConfig, Method, driver_to_level(Driver), Args, Return).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Executes given model action with async execution on second driver.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec exec_cache_async(model_behaviour:model_type(), [atom()],
        |      Method :: store_driver_behaviour:driver_action(), [term()]) -&gt;
        |      ok | {ok, term()} | {error, term()}.
        |  exec_cache_async(ModelName, [Driver1, Driver2], Method, Args) -&gt;
  2400..|      case exec_driver(ModelName, Driver1, Method, Args) of
        |          {error, Reason} -&gt;
   924..|              {error, Reason};
        |          Result -&gt;
  1476..|              spawn(fun() -&gt; exec_driver(ModelName, Driver2, Method, Args) end),
  1476..|              Result
        |      end.
</pre>
</body>
</html>
