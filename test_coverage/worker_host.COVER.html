<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/worker_host.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/cluster_elements/worker_host/worker_host.erl by COVER 2015-08-06 at 11:00:41

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Michal Wrzeszcz
        |  %%% @copyright (C) 2013 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc
        |  %%% This module hosts all oneprovider modules (fslogic, cluster_rengin etc.).
        |  %%% It makes it easy to manage modules and provides some basic functionality
        |  %%% for its plug-ins (oneprovider modules) e.g. requests management.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(worker_host).
        |  -author("Michal Wrzeszcz").
        |  
        |  -behaviour(gen_server).
        |  
        |  -include("global_definitions.hrl").
        |  -include("cluster_elements/worker_host/worker_protocol.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  %% This record is used by worker_host (it contains its state). It describes
        |  %% plugin that is used and state of this plugin. It contains also
        |  %% information about time of requests processing (used by ccm during
        |  %% load balancing). The two list of Loads are accessible, When second list
        |  %% becomes full, it overrides first list . Loads storing works similarly to
        |  %% round robin databases
        |  -record(host_state, {
        |      plugin = non :: module(),
        |      load_info :: {
        |          Loads1 :: list(),
        |          Loads2 :: list(),
        |          NumberOfLoads :: integer(),
        |          LoadMemorySize :: integer()
        |      }}).
        |  
        |  %% API
        |  -export([start_link/3, stop/1, proc_request/2]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
        |  -export([state_get/2, state_put/3, state_update/3, state_delete/2, state_to_map/1]).
        |  
        |  -type plugin_state() :: #{term() =&gt; term()}.
        |  -export_type([plugin_state/0]).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Starts host with apropriate plug-in
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec start_link(Plugin, PluginArgs, LoadMemorySize) -&gt; Result when
        |      Plugin :: atom(),
        |      PluginArgs :: term(),
        |      LoadMemorySize :: integer(),
        |      Result :: {ok, Pid}
        |      | ignore
        |      | {error, Error},
        |      Pid :: pid(),
        |      Error :: {already_started, Pid} | term().
        |  start_link(Plugin, PluginArgs, LoadMemorySize) -&gt;
   150..|      gen_server:start_link({local, Plugin}, ?MODULE, [Plugin, PluginArgs, LoadMemorySize], []).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Stops the server
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec stop(Plugin) -&gt; ok when
        |      Plugin :: atom().
        |  stop(Plugin) -&gt;
<font color=red>     0..|      gen_server:cast(Plugin, stop).</font>
        |  
        |  %%%===================================================================
        |  %%% gen_server callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Initializes the server
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init(Args :: term()) -&gt; Result when
        |      Result :: {ok, State}
        |      | {ok, State, Timeout}
        |      | {ok, State, hibernate}
        |      | {stop, Reason :: term()}
        |      | ignore,
        |      State :: term(),
        |      Timeout :: non_neg_integer() | infinity.
        |  init([Plugin, PluginArgs, LoadMemorySize]) -&gt;
   150..|      process_flag(trap_exit, true),
   150..|      ets:new(state_table_name(Plugin), [named_table, public, set, {read_concurrency, true}]),
   150..|      {ok, InitAns} = Plugin:init(PluginArgs),
   150..|      [ets:insert(state_table_name(Plugin), Entry) || Entry &lt;- maps:to_list(InitAns)],
   150..|      ?debug("Plugin ~p initialized with args ~p and result ~p", [Plugin, PluginArgs, InitAns]),
   150..|      {ok, #host_state{plugin = Plugin, load_info = {[], [], 0, LoadMemorySize}}}.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling call messages
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_call(Request :: term(), From :: {pid(), Tag :: term()}, State :: term()) -&gt; Result when
        |      Result :: {reply, Reply, NewState}
        |      | {reply, Reply, NewState, Timeout}
        |      | {reply, Reply, NewState, hibernate}
        |      | {noreply, NewState}
        |      | {noreply, NewState, Timeout}
        |      | {noreply, NewState, hibernate}
        |      | {stop, Reason, Reply, NewState}
        |      | {stop, Reason, NewState},
        |      Reply :: term(),
        |      NewState :: term(),
        |      Timeout :: non_neg_integer() | infinity,
        |      Reason :: term().
        |  handle_call({update_plugin_state, Key, UpdateFun}, _From, State = #host_state{plugin = Plugin}) when is_function(UpdateFun) -&gt;
<font color=red>     0..|      OldValue = state_get(Plugin, Key),</font>
<font color=red>     0..|      NewValue = UpdateFun(OldValue),</font>
<font color=red>     0..|      {reply, state_put(Plugin, Key, NewValue), State};</font>
        |  
        |  handle_call(_Request, _From, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {reply, wrong_request, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling cast messages
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_cast(Request :: term(), State :: term()) -&gt; Result when
        |      Result :: {noreply, NewState}
        |      | {noreply, NewState, Timeout}
        |      | {noreply, NewState, hibernate}
        |      | {stop, Reason :: term(), NewState},
        |      NewState :: term(),
        |      Timeout :: non_neg_integer() | infinity.
        |  %% Spawning migrated to worker proxy
        |  %% handle_cast(#worker_request{} = Req, State = #host_state{plugin = Plugin}) -&gt;
        |  %%     spawn(fun() -&gt; proc_request(Plugin, Req) end),
        |  %%     {noreply, State};
        |  
        |  handle_cast({progress_report, Report}, State) -&gt;
 33069..|      NewLoadInfo = save_progress(Report, State#host_state.load_info),
 33069..|      {noreply, State#host_state{load_info = NewLoadInfo}};
        |  
        |  handle_cast(stop, State) -&gt;
<font color=red>     0..|      {stop, normal, State};</font>
        |  
        |  handle_cast(_Request, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling all non call/cast messages
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_info(Info :: timeout | term(), State :: term()) -&gt; Result when
        |      Result :: {noreply, NewState}
        |      | {noreply, NewState, Timeout}
        |      | {noreply, NewState, hibernate}
        |      | {stop, Reason :: term(), NewState},
        |      NewState :: term(),
        |      Timeout :: non_neg_integer() | infinity.
        |  handle_info({'EXIT', Pid, Reason}, State) -&gt;
<font color=red>     0..|      Plugin = State#host_state.plugin,</font>
<font color=red>     0..|      gen_server:cast(Plugin, #worker_request{req = {'EXIT', Pid, Reason}}),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  
        |  handle_info({timer, Msg}, State) -&gt;
<font color=red>     0..|      gen_server:cast(self(), Msg),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  
        |  handle_info(Msg, State) -&gt;
<font color=red>     0..|      gen_server:cast(self(), Msg),</font>
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% This function is called by a gen_server when it is about to
        |  %% terminate. It should be the opposite of Module:init/1 and do any
        |  %% necessary cleaning up. When it returns, the gen_server terminates
        |  %% with Reason. The return value is ignored.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate(Reason, State :: term()) -&gt; Any :: term() when
        |      Reason :: normal
        |      | shutdown
        |      | {shutdown, term()}
        |      | term().
        |  terminate(_Reason, #host_state{plugin = Plugin}) -&gt;
   150..|      Plugin:cleanup(),
   150..|      ok.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Convert process state when code is changed
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec code_change(OldVsn, State :: term(), Extra :: term()) -&gt; Result when
        |      Result :: {ok, NewState :: term()} | {error, Reason :: term()},
        |      OldVsn :: Vsn | {down, Vsn},
        |      Vsn :: term().
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Returns Value for given Key form plugin's KV state or 'undefined' if the is no such entry.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec state_get(Plugin :: atom(), Key :: term()) -&gt; Value :: term() | undefined.
        |  state_get(Plugin, Key) -&gt;
 30187..|      case ets:lookup(state_table_name(Plugin), Key) of
 30141..|          [{_, Value}] -&gt; Value;
    46..|          []           -&gt; undefined
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Updates Value for given Key in plugin's KV state using given function. The function gets as argument old Value and
        |  %% shall return new Value. The function runs in worker_host's process.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec state_update(Plugin :: atom(), Key :: term(), UpdateFun :: fun((OldValue :: term()) -&gt; NewValue :: term())) -&gt;
        |      ok | no_return().
        |  state_update(Plugin, Key, UpdateFun) when is_function(UpdateFun) -&gt;
<font color=red>     0..|      ok = gen_server:call(Plugin, {update_plugin_state, Key, UpdateFun}).</font>
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Puts Value for given Key into plugin's KV state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec state_put(Plugin :: atom(), Key :: term(), Value :: term()) -&gt; ok | no_return().
        |  state_put(Plugin, Key, Value) -&gt;
  7352..|      true = ets:insert(state_table_name(Plugin), {Key, Value}),
  7352..|      ok.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Removes entry for given Key in plugin's KV state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec state_delete(Plugin :: atom(), Key :: term()) -&gt; ok | no_return().
        |  state_delete(Plugin, Key) -&gt;
<font color=red>     0..|      true = ets:delete(state_table_name(Plugin), Key),</font>
<font color=red>     0..|      ok.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Returns whole plugin's KV state as Erlang's map.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec state_to_map(Plugin :: atom()) -&gt; plugin_state().
        |  state_to_map(Plugin) -&gt;
    89..|      maps:from_list(ets:tab2list(state_table_name(Plugin))).
        |  
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Processes client request using Plugin:handle function. Afterwards,
        |  %% it sends the answer to dispatcher and logs info about processing time.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec proc_request(Plugin :: atom(), Request :: #worker_request{}) -&gt; Result when
        |      Result :: atom().
        |  proc_request(Plugin, Request = #worker_request{req = Msg}) -&gt;
 33069..|      BeforeProcessingRequest = os:timestamp(),
 33069..|      Response =
        |          try
 33069..|              Plugin:handle(Msg)
        |          catch
        |              Type:Error -&gt;
<font color=red>     0..|                  ?error_stacktrace("Worker plug-in ~p error: ~p:~p, on request: ~p", [Plugin, Type, Error, Request]),</font>
<font color=red>     0..|                  worker_plugin_error</font>
        |          end,
 33069..|      send_response(Plugin, BeforeProcessingRequest, Request, Response).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Sends responce to client
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send_response(Plugin :: atom(), BeforeProcessingRequest :: term(), Request :: #worker_request{}, Response :: term()) -&gt; atom().
        |  send_response(Plugin, BeforeProcessingRequest, #worker_request{id = MsgId, reply_to = ReplyTo}, Response) -&gt;
 33069..|      case ReplyTo of
<font color=red>     0..|          undefined -&gt; ok;</font>
        |          {gen_serv, Serv} -&gt;
<font color=red>     0..|              case MsgId of</font>
<font color=red>     0..|                  undefined -&gt; gen_server:cast(Serv, Response);</font>
        |                  Id -&gt;
<font color=red>     0..|                      gen_server:cast(Serv, #worker_answer{id = Id, response = Response})</font>
        |              end;
        |          {proc, Pid} -&gt;
 33069..|              case MsgId of
<font color=red>     0..|                  undefined -&gt; Pid ! Response;</font>
 33069..|                  Id -&gt; Pid ! #worker_answer{id = Id, response = Response}
        |              end
        |      end,
        |  
 33069..|      AfterProcessingRequest = os:timestamp(),
 33069..|      Time = timer:now_diff(AfterProcessingRequest, BeforeProcessingRequest),
 33069..|      gen_server:cast(Plugin, {progress_report, {BeforeProcessingRequest, Time}}).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Adds information about ended request to host memory (ccm uses
        |  %% it to control cluster load).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec save_progress(Report :: term(), LoadInfo :: term()) -&gt; NewLoadInfo when
        |      NewLoadInfo :: term().
        |  save_progress(Report, {New, Old, NewListSize, Max}) -&gt;
 33069..|      case NewListSize + 1 of
        |          Max -&gt;
    24..|              {[], [Report | New], 0, Max};
        |          S -&gt;
 33045..|              {[Report | New], Old, S, Max}
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Returns the name of ETS table holding plugin's state.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec state_table_name(Plugin :: atom()) -&gt; atom().
        |  state_table_name(Plugin) -&gt;
 38048..|      Plugin.</pre>
</body>
</html>
