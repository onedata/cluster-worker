<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/opn_cowboy_bridge.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/modules/http_worker/opn_cowboy_bridge.erl by COVER 2015-08-06 at 11:00:40

****************************************************************************

        |  %%%--------------------------------------------------------------------
        |  %%% @author Lukasz Opiola
        |  %%% @copyright (C) 2014 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%--------------------------------------------------------------------
        |  %%% @doc This module introduces a new abstraction layer over standard cowboy
        |  %%% handlers. It allows delegating tasks to http_worker instances on other
        |  %%% nodes. Delegation can be switched on and off for different handlers.
        |  %%% Nomenclature:
        |  %%% socket process - process, that has been spawned by cowboy to handle a request
        |  %%% handling process - process that has been spawned by http_worker to process
        |  %%% the request and send the answer to socket process.
        |  %%% @end
        |  %%%--------------------------------------------------------------------
        |  -module(opn_cowboy_bridge).
        |  -author("Lukasz Opiola").
        |  
        |  -behaviour(cowboy_http_handler).
        |  -behaviour(cowboy_websocket_handler).
        |  
        |  -include("global_definitions.hrl").
        |  -include("modules/http_worker/http_common.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  % Max time (ms) to wait for worker_host to reply
        |  -define(HANDLING_PROCESS_SPAWN_TIMEOUT, timer:seconds(5)).
        |  
        |  %% Interaction between socket process and handling process
        |  -export([apply/3, request_processing_loop/0, set_socket_pid/1, get_socket_pid/0]).
        |  
        |  %% Cowboy handler API
        |  -export([init/3, handle/2, terminate/3]).
        |  
        |  %% Cowboy websocket handler API
        |  -export([websocket_init/3, websocket_handle/3, websocket_info/3, websocket_terminate/3]).
        |  
        |  %% Cowboy REST handler API
        |  %% This is not the full cowboy API. If needed, more functions can be added to this bridge.
        |  -export([rest_init/2, malformed_request/2, known_methods/2, allowed_methods/2, is_authorized/2, options/2, resource_exists/2]).
        |  -export([content_types_provided/2, languages_provided/2, charsets_provided/2]).
        |  -export([moved_permanently/2, moved_temporarily/2, content_types_accepted/2, delete_resource/2]).
        |  -export([generate_etag/2, last_modified/2, expires/2, forbidden/2]).
        |  %% REST handler specific funs
        |  -export([get_resource/2, handle_urlencoded_data/2, handle_json_data/2, handle_multipart_data/2]).
        |  %% CDMI handler specific funs
        |  -export([get_cdmi_container/2, get_cdmi_object/2, get_binary/2, get_cdmi_capability/2]).
        |  -export([put_cdmi_container/2, put_cdmi_object/2, put_binary/2]).
        |  %% Static file handler specific funs
        |  -export([get_file/2]).
        |  
        |  %% This is an internal function, but must be exported to use ?MODULE: in recursion.
        |  -export([delegation_loop/1]).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Used to interact with the socket process - issues application of
        |  %% some code on the socket process, which then sends back the result.
        |  %% This is needed when some data is cached at socket process - for example
        |  %% cowboy_req:reply or :body can be evaluated only on socket process.
        |  %% If applied fun ends with an exception, it will be rethrown in the handling process.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec apply(Module :: atom(), Fun :: atom(), Args :: [term()]) -&gt; term() | no_return().
        |  apply(Module, Fun, Args) -&gt;
   253..|      case get_delegation() of
        |          false -&gt;
        |              % This is the socket process (delegation flag is set)
        |              % so it can just evaluate code
<font color=red>     0..|              erlang:apply(Module, Fun, Args);</font>
        |          _ -&gt;
        |              % This is a spawned process, it must call the socket process to apply the fun
   253..|              get_socket_pid() ! {apply, Module, Fun, Args},
   253..|              receive
        |                  {result, Result} -&gt;
   253..|                      Result;
        |                  {except, Except} -&gt;
<font color=red>     0..|                      throw(Except)</font>
        |              end
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% A loop that gets evaluated while handling process is processing
        |  %% a request.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec request_processing_loop() -&gt; ok.
        |  request_processing_loop() -&gt;
  1026..|      SocketProcessPid = get_socket_pid(),
  1026..|      receive
        |          {apply, Module, Fun, Args} -&gt;
   771..|              Result =
        |                  try
   771..|                      erlang:apply(Module, Fun, Args)
        |                  catch
        |                      T:M -&gt;
<font color=red>     0..|                          ?error_stacktrace("Error in request processing loop - ~p:~p", [T, M]),</font>
<font color=red>     0..|                          error</font>
        |                  end,
   771..|              case Result of
        |                  error -&gt;
<font color=red>     0..|                      ok;</font>
        |                  _ -&gt;
   771..|                      SocketProcessPid ! {result, Result},
   771..|                      ?MODULE:request_processing_loop()
        |              end;
        |          {flush, Actions} -&gt;
<font color=red>     0..|              SocketProcessPid ! {flush, Actions},</font>
<font color=red>     0..|              ?MODULE:request_processing_loop();</font>
        |          terminate -&gt;
   253..|              ok;
        |          {'DOWN', _, _, _, _} -&gt;
     2..|              ?debug("Socket process died, handler process is terminating"),
     2..|              ok;
        |          Unknown -&gt;
<font color=red>     0..|              ?warning("Unknown message in request processing loop: ~p", [Unknown]),</font>
<font color=red>     0..|              ok</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that stores the reference to socket pid in process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec set_socket_pid(Pid :: pid()) -&gt; term().
        |  set_socket_pid(Pid) -&gt;
   255..|      erlang:put(socket_pid, Pid).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that retrieves the reference to socket pid from process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_socket_pid() -&gt; pid().
        |  get_socket_pid() -&gt;
  1279..|      erlang:get(socket_pid).
        |  
        |  %%%===================================================================
        |  %%% HTTP callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called to initialize request handling flow.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init(Type :: term(), Req :: cowboy_req:req(), Opts :: [term()]) -&gt;
        |      {ok, cowboy_req:req(), term()}
        |      | {loop, cowboy_req:req(), term()}
        |      | {loop, cowboy_req:req(), term(), hibernate}
        |      | {loop, cowboy_req:req(), term(), timeout()}
        |      | {loop, cowboy_req:req(), term(), timeout(), hibernate}
        |      | {shutdown, cowboy_req:req(), term()}
        |      | {upgrade, protocol, module()}
        |      | {upgrade, protocol, module(), cowboy_req:req(), term()}.
        |  init(Type, Req, Opts) -&gt;
   325..|      HandlerModule = proplists:get_value(handler_module, Opts),
   325..|      HandlerOpts = proplists:get_value(handler_opts, Opts, []),
   325..|      Delegation = proplists:get_value(delegation, Opts, true),
   325..|      set_handler_module(HandlerModule),
   325..|      set_delegation(Delegation),
        |  
   325..|      DoDelegate =
        |          fun() -&gt;
   255..|              case delegate(init, [Type, Req, HandlerOpts], 3) of
        |                  {upgrade, protocol, Module, Req2, HandlerOpts2} -&gt;
     2..|                      Opts1 = proplists:delete(handler_opts, Opts),
     2..|                      {upgrade, protocol, Module, Req2, [{handler_opts, HandlerOpts2} | Opts1]};
   253..|                  Other -&gt; Other
        |              end
        |          end,
        |  
   325..|      case Delegation of
        |          true -&gt;
   325..|              case spawn_handling_process() of
        |                  ok -&gt;
   255..|                      DoDelegate();
        |                  _ -&gt;
    70..|                      {ok, Req2} = cowboy_req:reply(500, [], Req),
    70..|                      {shutdown, Req2, no_state}
        |              end;
        |          false -&gt;
<font color=red>     0..|              DoDelegate()</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called to process a HTTP request.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle(Req :: cowboy_req:req(), State :: term()) -&gt; {ok, NewReq :: cowboy_req:req(), State :: term()}.
        |  handle(Req, State) -&gt;
   253..|      delegate(handle, [Req, State], 2).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called after a request is processed.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate(Reason :: term(), Req :: cowboy_req:req(), State :: term()) -&gt; ok.
        |  terminate(Reason, Req, State) -&gt;
   323..|      delegate(terminate, [Reason, Req, State], 3),
   323..|      case get_delegation() of
        |          true -&gt;
   323..|              terminate_handling_process(),
   323..|              ok;
        |          false -&gt;
<font color=red>     0..|              ok</font>
        |      end.
        |  
        |  %%%===================================================================
        |  %%% Websocket callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called right after protocol upgrade to websocket.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec websocket_init(Transport :: term(), Req :: cowboy_req:req(), Opts :: term()) -&gt;
        |      {ok, cowboy_req:req(), term()}
        |      | {ok, cowboy_req:req(), term(), hibernate}
        |      | {ok, cowboy_req:req(), term(), timeout()}
        |      | {ok, cowboy_req:req(), term(), timeout(), hibernate}
        |      | {shutdown, cowboy_req:req()}.
        |  websocket_init(Transport, Req, Opts) -&gt;
<font color=red>     0..|      HandlerOpts = proplists:get_value(handler_opts, Opts, []),</font>
<font color=red>     0..|      delegate(websocket_init, [Transport, Req, HandlerOpts], 3).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called when websocket process receives
        |  %% data packet (event) from websocket client.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec websocket_handle(Data :: term(), Req :: cowboy_req:req(), State :: term()) -&gt;
        |      {ok, cowboy_req:req(), term()}
        |      | {ok, cowboy_req:req(), NewState :: term(), hibernate}
        |      | {reply, cowboy_websocket:frame() | [cowboy_websocket:frame()], cowboy_req:req(), NewState :: term()}
        |      | {reply, cowboy_websocket:frame() | [cowboy_websocket:frame()], cowboy_req:req(), NewState :: term(), hibernate}
        |      | {shutdown, cowboy_req:req(), term()}.
        |  websocket_handle(Data, Req, State) -&gt;
<font color=red>     0..|      delegate(websocket_handle, [Data, Req, State], 3).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called when websocket process receives an erlang message.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec websocket_info(Info :: term(), Req :: cowboy_req:req(), State :: term()) -&gt;
        |      {ok, cowboy_req:req(), NewState :: term()}
        |      | {ok, cowboy_req:req(), NewState :: term(), hibernate}
        |      | {reply, cowboy_websocket:frame() | [cowboy_websocket:frame()], cowboy_req:req(), NewState :: term()}
        |      | {reply, cowboy_websocket:frame() | [cowboy_websocket:frame()], cowboy_req:req(), NewState :: term(), hibernate}
        |      | {shutdown, cowboy_req:req(), term()}.
        |  websocket_info(Info, Req, State) -&gt;
<font color=red>     0..|      delegate(websocket_info, [Info, Req, State], 3).</font>
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called on a websocket connection finalization.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec websocket_terminate(Reason :: term(), Req :: cowboy_req:req(), State :: term()) -&gt; ok.
        |  websocket_terminate(Reason, Req, State) -&gt;
<font color=red>     0..|      delegate(websocket_terminate, [Reason, Req, State], 3),</font>
<font color=red>     0..|      terminate_handling_process(),</font>
<font color=red>     0..|      ok.</font>
        |  
        |  %%%===================================================================
        |  %%% REST callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy handler callback, called right after protocol upgrade to init the request context.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec rest_init(Req :: cowboy_req:req(), Opts :: term()) -&gt; {ok, NewReq :: cowboy_req:req(), State :: term()} | {shutdown, NewReq :: cowboy_req:req()}.
        |  rest_init(Req, Opts) -&gt;
     2..|      HandlerOpts = proplists:get_value(handler_opts, Opts, []),
     2..|      delegate(rest_init, [Req, HandlerOpts], 2).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Checks request validity.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec malformed_request(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  malformed_request(Req, State) -&gt;
     2..|      delegate(malformed_request, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns methods resolvable by the handler.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec known_methods(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: [binary()], NewReq :: cowboy_req:req(), NewState :: term()}.
        |  known_methods(Req, State) -&gt;
     2..|      delegate(known_methods, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function.
        |  %% Returns methods that are allowed, based on version specified in URI.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec allowed_methods(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: [binary()], NewReq :: cowboy_req:req(), NewState :: term()}.
        |  allowed_methods(Req, State) -&gt;
     2..|      delegate(allowed_methods, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function.
        |  %% Returns true or false if the client is authorized to perform such request.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec is_authorized(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  is_authorized(Req, State) -&gt;
     2..|      delegate(is_authorized, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function.
        |  %% Returns options / requirements associated with a resource.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec options(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: [term()], NewReq :: cowboy_req:req(), NewState :: term()}.
        |  options(Req, State) -&gt;
<font color=red>     0..|      delegate(options, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns content types that can be provided. "application/json" is default.
        |  %% It can be changed later by gui_utils:cowboy_ensure_header/3.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec content_types_provided(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: [binary()], NewReq :: cowboy_req:req(), NewState :: term()}.
        |  content_types_provided(Req, State) -&gt;
     1..|      delegate(content_types_provided, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns list of languages in which the response can be sent.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec languages_provided(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: [binary()], NewReq :: cowboy_req:req(), NewState :: term()}.
        |  languages_provided(Req, State) -&gt;
     1..|      delegate(languages_provided, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns list of charsets in which the response can be encoded.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec charsets_provided(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: [binary()], NewReq :: cowboy_req:req(), NewState :: term()}.
        |  charsets_provided(Req, State) -&gt;
     1..|      delegate(charsets_provided, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns false or {true, Location}.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec moved_permanently(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  moved_permanently(Req, State) -&gt;
<font color=red>     0..|      delegate(moved_permanently, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns false or {true, Location}.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec moved_temporarily(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  moved_temporarily(Req, State) -&gt;
<font color=red>     0..|      delegate(moved_temporarily, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Determines if resource identified by URI exists.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec resource_exists(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  resource_exists(Req, State) -&gt;
     1..|      delegate(resource_exists, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns an etag generated from a static file.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec generate_etag(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  generate_etag(Req, State) -&gt;
<font color=red>     0..|      delegate(generate_etag, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns file's modification time.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec last_modified(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: integer(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  last_modified(Req, State) -&gt;
<font color=red>     0..|      delegate(last_modified, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns time of expiration of a resource.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec expires(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: integer(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  expires(Req, State) -&gt;
<font color=red>     0..|      delegate(expires, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns true if access to a resource is forbidden.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec forbidden(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  forbidden(Req, State) -&gt;
     1..|      delegate(forbidden, [Req, State], 2, true).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Handles GET requests.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_resource(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  get_resource(Req, State) -&gt;
<font color=red>     0..|      delegate(get_resource, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Returns content-types that are accepted by REST handler and what
        |  %% functions should be used to process the requests.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec content_types_accepted(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  content_types_accepted(Req, State) -&gt;
<font color=red>     0..|      delegate(content_types_accepted, [Req, State], 2, true).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Function handling "application/x-www-form-urlencoded" requests.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_urlencoded_data(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  handle_urlencoded_data(Req, State) -&gt;
<font color=red>     0..|      delegate(handle_urlencoded_data, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Function handling "application/json" requests.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_json_data(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  handle_json_data(Req, State) -&gt;
<font color=red>     0..|      delegate(handle_json_data, [Req, State], 2).</font>
        |  
        |  %% handle_multipart_data/2
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Function handling "multipart/form-data" requests.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_multipart_data(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: boolean(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  handle_multipart_data(Req, State) -&gt;
<font color=red>     0..|      delegate(handle_multipart_data, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Cowboy callback function
        |  %% Handles DELETE requests.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete_resource(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), NewState :: term()}.
        |  delete_resource(Req, State) -&gt;
<font color=red>     0..|      delegate(delete_resource, [Req, State], 2).</font>
        |  
        |  %%%===================================================================
        |  %%% CDMI callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_cdmi_container(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), term()}.
        |  get_cdmi_container(Req, State) -&gt;
<font color=red>     0..|      delegate(get_cdmi_container, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_cdmi_object(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  get_cdmi_object(Req, State) -&gt;
<font color=red>     0..|      delegate(get_cdmi_object, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_binary(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  get_binary(Req, State) -&gt;
<font color=red>     0..|      delegate(get_binary, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec put_cdmi_container(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  put_cdmi_container(Req, State) -&gt;
<font color=red>     0..|      delegate(put_cdmi_container, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec put_cdmi_object(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  put_cdmi_object(Req, State) -&gt;
<font color=red>     0..|      delegate(put_cdmi_object, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec put_binary(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  put_binary(Req, State) -&gt;
<font color=red>     0..|      delegate(put_binary, [Req, State], 2).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for cdmi.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_cdmi_capability(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  get_cdmi_capability(Req, State) -&gt;
<font color=red>     0..|      delegate(get_cdmi_capability, [Req, State], 2).</font>
        |  
        |  %%%===================================================================
        |  %%% Static file handler callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Callback function for static file handler.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_file(Req :: cowboy_req:req(), State :: term()) -&gt; {Result :: term(), NewReq :: cowboy_req:req(), State :: term()}.
        |  get_file(Req, State) -&gt;
<font color=red>     0..|      delegate(get_file, [Req, State], 2).</font>
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Contacts a http_worker instance via dispatcher to spawn a handling
        |  %% process there, whoose pid will be reported back to socket process for
        |  %% later communication.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec spawn_handling_process() -&gt; ok | {error, term()}.
        |  spawn_handling_process() -&gt;
   325..|      case worker_proxy:call(http_worker, {spawn_handler, self()}, ?HANDLING_PROCESS_SPAWN_TIMEOUT) of
        |          {ok, Pid} -&gt;
   255..|              set_handler_pid(Pid),
   255..|              ok;
        |          {error, Error} -&gt;
    70..|              ?error("Cannot spawn handling process, error: ~p", [Error]),
    70..|              set_handler_pid(undefined),
    70..|              {error, Error}
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Orders the handling process to terminate.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate_handling_process() -&gt; terminate.
        |  terminate_handling_process() -&gt;
   323..|      case get_handler_pid() of
        |          undefined -&gt;
    70..|              ok;
        |          Pid when is_pid(Pid) -&gt;
   253..|              Pid ! terminate
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% @equiv delegate(Fun, Args, Arity, false)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delegate(Fun :: atom(), Args :: [term()], Arity :: integer()) -&gt; term().
        |  delegate(Fun, Args, Arity) -&gt;
   833..|      delegate(Fun, Args, Arity, false).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Function used to delegate a cowboy callback. Depending on if the
        |  %% delegation flag was set to true, this will contact a handling process
        |  %% or cause the socket process to evaluate the callback.
        |  %% FailWithNoCall flag allows returning a no_call atom to cowboy,
        |  %% which tells it that the function is not implemented so it can
        |  %% decide for itself what to do. This is useful with optional cowboy
        |  %% callbacks (mostly REST).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delegate(Fun :: atom(), Args :: [term()], Arity :: integer(), FailWithNoCall :: boolean()) -&gt; term().
        |  %%--------------------------------------------------------------------
        |  delegate(Fun, Args, Arity, FailWithNoCall) -&gt;
   846..|      HandlerModule = get_handler_module(),
   846..|      case (FailWithNoCall) andalso (not erlang:function_exported(HandlerModule, Fun, Arity)) of
        |          true -&gt;
     5..|              no_call;
        |          false -&gt;
   841..|              case get_delegation() of
        |                  true -&gt;
   841..|                      case get_handler_pid() of
        |                          undefined -&gt;
    70..|                              no_call;
        |                          Pid when is_pid(Pid) -&gt;
   771..|                              Pid ! {apply, HandlerModule, Fun, Args},
   771..|                              delegation_loop(Pid)
        |                      end;
        |                  false -&gt;
<font color=red>     0..|                      erlang:apply(HandlerModule, Fun, Args)</font>
        |              end
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Loop that is evaluated by socket process while it has spawned a handling process
        |  %% and is delegating tasks.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delegation_loop(HandlerPid :: pid()) -&gt; term().
        |  delegation_loop(HandlerPid) -&gt;
  1024..|      receive
        |          {result, Res} -&gt;
   771..|              Res;
        |          {apply, Module, Fun, Args} -&gt;
   253..|              Result = try
   253..|                  {result, erlang:apply(Module, Fun, Args)}
        |                       catch T:M -&gt;
<font color=red>     0..|                           {except, {T, M}}</font>
        |                       end,
   253..|              HandlerPid ! Result,
   253..|              ?MODULE:delegation_loop(HandlerPid)
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that stores the reference to handler module in process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec set_handler_module(Module :: atom()) -&gt; term().
        |  set_handler_module(Module) -&gt;
   325..|      erlang:put(handler_module, Module).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that retrieves the reference to handler module from process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_handler_module() -&gt; atom().
        |  get_handler_module() -&gt;
   846..|      erlang:get(handler_module).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that stores the reference to handler pid in process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec set_handler_pid(Pid :: pid() | undefined) -&gt; term().
        |  set_handler_pid(Pid) -&gt;
   325..|      erlang:put(handler_pid, Pid).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that retrieves the reference to handler pid from process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_handler_pid() -&gt; pid() | undefined.
        |  get_handler_pid() -&gt;
  1164..|      erlang:get(handler_pid).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that stores the delegation flag in process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec set_delegation(Delegation :: boolean()) -&gt; term().
        |  set_delegation(Delegation) -&gt;
   325..|      erlang:put(delegation, Delegation).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Convenience function that retrieves the delegation flag from process dict.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_delegation() -&gt; boolean().
        |  get_delegation() -&gt;
  1417..|      erlang:get(delegation).</pre>
</body>
</html>
