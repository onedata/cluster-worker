<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/worker_proxy.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/cluster_elements/worker_host/worker_proxy.erl by COVER 2015-08-06 at 11:00:44

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Tomasz Lichon
        |  %%% @author Krzysztof Trzepla
        |  %%% @copyright (C) 2015 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc
        |  %%% This module is fasade of worker_host gen_server api,
        |  %%% It simply translates arguments into apropriate #worker_request,
        |  %%% and sends it to worker.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(worker_proxy).
        |  -author("Tomasz Lichon").
        |  -author("Krzysztof Trzepla").
        |  
        |  -include("cluster_elements/worker_host/worker_protocol.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  -define(DEFAULT_REQUEST_TIMEOUT, timer:seconds(10)).
        |  
        |  %% API
        |  -export([call/2, call/3, multicall/2, multicall/3,
        |      cast/2, cast/3, cast/4, multicast/2, multicast/3, multicast/4]).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Synchronously send request to worker with default timeout.
        |  %% @equiv call(WorkerName, Request, ?DEFAULT_REQUEST_TIMEOUT)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec call(WorkerRef :: request_dispatcher:worker_ref(), Request :: term()) -&gt;
        |      ok | {ok, term()} | {error, term()}.
        |  call(WorkerRef, Request) -&gt;
 31654..|      call(WorkerRef, Request, ?DEFAULT_REQUEST_TIMEOUT).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Synchronously send request to worker with given timeout.
        |  %% @equiv call(WorkerName, Request, Timeout, ?DEFAULT_WORKER_SELECTION_TYPE)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec call(WorkerRef :: request_dispatcher:worker_ref(), Request :: term(), Timeout :: timeout()) -&gt;
        |      ok | {ok, term()} | {error, term()}.
        |  call(WorkerRef, Request, Timeout) -&gt;
 32860..|      MsgId = make_ref(),
 32860..|      case choose_node(WorkerRef) of
        |          {ok, Name, Node} -&gt;
 32669..|              spawn(Node, worker_host, proc_request,
        |                  [Name, #worker_request{req = Request, id = MsgId, reply_to = {proc, self()}}]),
 32669..|              receive
 32665..|                  #worker_answer{id = MsgId, response = Response} -&gt; Response
        |              after Timeout -&gt;
     1..|                  ?error("Worker: ~p, request: ~p exceeded timeout of ~p ms",
        |                      [WorkerRef, Request, Timeout]),
     1..|                  {error, timeout}
        |              end;
        |          Error -&gt;
    70..|              Error
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Synchronously send request to all workers with default timeout.
        |  %% @equiv multicall(WorkerName, Request, ?DEFAULT_REQUEST_TIMEOUT)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec multicall(WorkerName :: request_dispatcher:worker_name(), Request :: term()) -&gt;
        |      [{Node :: node(), ok | {ok, term()} | {error, term()}}].
        |  multicall(WorkerName, Request) -&gt;
<font color=red>     0..|      multicall(WorkerName, Request, ?DEFAULT_REQUEST_TIMEOUT).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Synchronously send request to all workers with given timeout.
        |  %% Returns list of pairs: node and associated answer.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec multicall(WorkerName :: request_dispatcher:worker_name(), Request :: term(), Timeout :: timeout()) -&gt;
        |      [{Node :: node(), ok | {ok, term()} | {error, term()}}].
        |  multicall(WorkerName, Request, Timeout) -&gt;
<font color=red>     0..|      {ok, Nodes} = request_dispatcher:get_worker_nodes(WorkerName),</font>
<font color=red>     0..|      utils:pmap(fun(Node) -&gt;</font>
<font color=red>     0..|          {Node, call({WorkerName, Node}, Request, Timeout)}</font>
        |      end, Nodes).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Asynchronously send request to worker.
        |  %% @equiv cast(WorkerRef, Request, undefined)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec cast(WorkerRef :: request_dispatcher:worker_ref(), Request :: term()) -&gt; ok | {error, term()}.
        |  cast(WorkerRef, Request) -&gt;
<font color=red>     0..|      cast(WorkerRef, Request, undefined).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Asynchronously send request to worker, answer is expected at ReplyTo
        |  %% process/gen_server.
        |  %% @equiv cast(WorkerName, Request, ReplyTo, undefined)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec cast(WorkerRef :: request_dispatcher:worker_ref(), Request :: term(), ReplyTo :: process_ref()) -&gt;
        |      ok | {error, term()}.
        |  cast(WorkerRef, Request, ReplyTo) -&gt;
<font color=red>     0..|      cast(WorkerRef, Request, ReplyTo, undefined).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Asynchronously send request to worker, answer with given MsgId is
        |  %% expected at ReplyTo process/gen_server. The answer will be
        |  %% 'worker_answer' record.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec cast(WorkerRef :: request_dispatcher:worker_ref(), Request :: term(), ReplyTo :: process_ref(),
        |      MsgId :: term() | undefined) -&gt; ok | {error, term()}.
        |  cast(WorkerRef, Request, ReplyTo, MsgId) -&gt;
   400..|      case choose_node(WorkerRef) of
        |          {ok, Name, Node} -&gt;
   400..|              spawn(Node, worker_host, proc_request,
        |                  [Name, #worker_request{req = Request, id = MsgId, reply_to = ReplyTo}]),
   400..|              ok;
        |          Error -&gt;
<font color=red>     0..|              Error</font>
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Asynchronously send request to all workers.
        |  %% @equiv multicast(WorkerName, Request, undefined)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec multicast(WorkerName :: request_dispatcher:worker_name(), Request :: term()) -&gt; ok.
        |  multicast(WorkerName, Request) -&gt;
<font color=red>     0..|      multicast(WorkerName, Request, undefined).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Asynchronously send request to all workers, answer is expected at
        |  %% ReplyTo process/gen_server.
        |  %% @equiv multicast(WorkerName, Request, ReplyTo, undefined)
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec multicast(WorkerName :: request_dispatcher:worker_name(), Request :: term(),
        |      ReplyTo :: process_ref()) -&gt; ok.
        |  multicast(WorkerName, Request, ReplyTo) -&gt;
<font color=red>     0..|      multicast(WorkerName, Request, ReplyTo, undefined).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Asynchronously send request to all workers, answers with given MsgId
        |  %% are expected at ReplyTo process/gen_server. The answers will be
        |  %% 'worker_answer' records.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec multicast(WorkerName :: request_dispatcher:worker_name(), Request :: term(),
        |      ReplyTo :: process_ref(), MsgId :: term() | undefined) -&gt; ok.
        |  multicast(WorkerName, Request, ReplyTo, MsgId) -&gt;
<font color=red>     0..|      {ok, Nodes} = request_dispatcher:get_worker_nodes(WorkerName),</font>
<font color=red>     0..|      utils:pforeach(fun(Node) -&gt;</font>
<font color=red>     0..|          cast({WorkerName, Node}, Request, ReplyTo, MsgId)</font>
        |      end, Nodes).
        |  
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Chooses a node to send a worker request to.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec choose_node(WorkerRef :: request_dispatcher:worker_ref()) -&gt;
        |      {ok, WorkerName :: request_dispatcher:worker_name(), WorkerNode :: atom()} | {error, term()}.
        |  choose_node(WorkerRef) -&gt;
 33260..|      case WorkerRef of
        |          {WName, WNode} -&gt;
  4408..|              {ok, WName, WNode};
        |          WName -&gt;
 28852..|              case request_dispatcher:get_worker_node(WName) of
        |                  {ok, WNode} -&gt;
 28661..|                      {ok, WName, WNode};
        |                  {error, Error} -&gt;
    70..|                      {error, Error}
        |              end
        |      end.
</pre>
</body>
</html>
