<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/riak_datastore_driver.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/modules/datastore/drivers/riak_datastore_driver.erl by COVER 2015-08-06 at 11:00:41

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Rafal Slota
        |  %%% @copyright (C) 2015 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc Riak database driver.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(riak_datastore_driver).
        |  -author("Rafal Slota").
        |  -behaviour(store_driver_behaviour).
        |  
        |  -include("modules/datastore/datastore.hrl").
        |  -include("modules/datastore/datastore_common_internal.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  %% Bucket type that is defined in database and configured to store "map" data type
        |  -define(RIAK_BUCKET_TYPE, &lt;&lt;"maps"&gt;&gt;).
        |  
        |  %% Encoded object prefix
        |  -define(OBJ_PREFIX, "OBJ::").
        |  
        |  %% Encoded atom prefix
        |  -define(ATOM_PREFIX, "ATOM::").
        |  
        |  -define(LINKS_KEY_SUFFIX, "$$").
        |  
        |  %% Connections to single Riak node
        |  -define(CONN_PER_NODE, 10).
        |  
        |  -type riak_node() :: {HostName :: binary(), Port :: non_neg_integer()}.
        |  -type riak_connection() :: {riak_node(), ConnectionHandle :: term()}.
        |  
        |  %% store_driver_behaviour callbacks
        |  -export([init_bucket/3, healthcheck/1]).
        |  -export([save/2, create/2, update/3, exists/2, get/2, list/3, delete/3]).
        |  -export([add_links/3, delete_links/3, fetch_link/3, foreach_link/4]).
        |  
        |  %%%===================================================================
        |  %%% store_driver_behaviour callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback init_bucket/2.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init_bucket(Bucket :: datastore:bucket(), Models :: [model_behaviour:model_config()],
        |      NodeToSync :: node()) -&gt; ok.
        |  init_bucket(_Bucket, _Models, _NodeToSync) -&gt;
   240..|      ?debug("Riak init with nodes: ~p", [datastore_worker:state_get(riak_nodes)]),
   240..|      ok.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback init_bucket/2.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec save(model_behaviour:model_config(), datastore:document()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:generic_error().
        |  save(#model_config{bucket = Bucket} = _ModelConfig, #document{key = Key, rev = Rev, value = Value}) -&gt;
  2160..|      RiakObj = to_riak_obj(Value, Rev),
  2160..|      RiakOP = riakc_map:to_op(RiakObj),
  2160..|      case call(riakc_pb_socket, update_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key), RiakOP]) of
  2160..|          ok -&gt; {ok, Key};
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback update/3.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec update(model_behaviour:model_config(), datastore:ext_key(),
        |      Diff :: datastore:document_diff()) -&gt; {ok, datastore:ext_key()} | datastore:update_error().
        |  update(#model_config{bucket = _Bucket} = _ModelConfig, _Key, Diff) when is_function(Diff) -&gt;
<font color=red>     0..|      erlang:error(not_implemented);</font>
        |  update(#model_config{bucket = Bucket, name = ModelName} = _ModelConfig, Key, Diff) when is_map(Diff) -&gt;
  2343..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key)]) of
        |          {ok, Result}
        |              -&gt;
  1761..|              NewRMap =
        |                  maps:fold(
        |                      fun(K, V, Acc) -&gt;
  1765..|                          RiakObj = to_riak_obj(V),
  1765..|                          Module = riakc_datatype:module_for_term(RiakObj),
  1765..|                          Type = Module:type(),
  1765..|                          riakc_map:update({to_binary(K), Type}, fun(_) -&gt;
  1765..|                              RiakObj end, Acc)
        |                      end, Result, Diff),
  1761..|              case call(riakc_pb_socket, update_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key), riakc_map:to_op(NewRMap)]) of
  1761..|                  ok -&gt; {ok, Key};
<font color=red>     0..|                  {error, Reason} -&gt; {error, Reason}</font>
        |              end;
        |          {error, {notfound, _}} -&gt;
   582..|              {error, {not_found, ModelName}};
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback create/2.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec create(model_behaviour:model_config(), datastore:document()) -&gt;
        |      {ok, datastore:ext_key()} | datastore:create_error().
        |  create(#model_config{bucket = Bucket} = _ModelConfig, #document{key = Key, value = Value}) -&gt;
        |      %% @todo: fix me! somehow riak's context allows to override existing record
   856..|      case exists(_ModelConfig, Key) of
        |          {ok, true} -&gt;
   270..|              {error, already_exists};
        |          {ok, false} -&gt;
   586..|              RiakOP = riakc_map:to_op(to_riak_obj(Value)),
   586..|              case call(riakc_pb_socket, update_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key), RiakOP]) of
   586..|                  ok -&gt; {ok, Key};
        |                  {error, Reason} -&gt;
<font color=red>     0..|                      {error, Reason}</font>
        |              end;
        |          {error, Reason0} -&gt;
<font color=red>     0..|              {error, Reason0}</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback get/2.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get(model_behaviour:model_config(), datastore:ext_key()) -&gt;
        |      {ok, datastore:document()} | datastore:get_error().
        |  get(#model_config{bucket = Bucket, name = ModelName} = _ModelConfig, Key) -&gt;
  1264..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key)]) of
        |          {ok, Result} -&gt;
   364..|              {ok, #document{key = Key, rev = Result,
        |                  value = form_riak_obj(map, Result)}};
        |          {error, {notfound, _}} -&gt;
   900..|              {error, {not_found, ModelName}};
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback list/3.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec list(model_behaviour:model_config(),
        |      Fun :: datastore:list_fun(), AccIn :: term()) -&gt; no_return().
        |  list(#model_config{} = _ModelConfig, _Fun, _AccIn) -&gt;
<font color=red>     0..|      error(not_supported).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback delete/2.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete(model_behaviour:model_config(), datastore:ext_key(), datastore:delete_predicate()) -&gt;
        |      ok | datastore:generic_error().
        |  delete(#model_config{bucket = Bucket} = _ModelConfig, Key, Pred) -&gt;
  2688..|      case Pred() of
        |          true -&gt;
  2686..|              case call(riakc_pb_socket, delete, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key)]) of
        |                  ok -&gt;
  2686..|                      ok;
        |                  {error, Reason} -&gt;
<font color=red>     0..|                      {error, Reason}</font>
        |              end;
        |          false -&gt;
     2..|              ok
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback exists/2.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec exists(model_behaviour:model_config(), datastore:ext_key()) -&gt;
        |      {ok, boolean()} | datastore:generic_error().
        |  exists(#model_config{bucket = Bucket} = _ModelConfig, Key) -&gt;
  2110..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(Key)]) of
        |          {error, {notfound, _}} -&gt;
  1514..|              {ok, false};
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason};</font>
        |          {ok, _} -&gt;
   596..|              {ok, true}
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback add_links/3.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec add_links(model_behaviour:model_config(), datastore:ext_key(), [datastore:normalized_link_spec()]) -&gt;
        |      ok | datastore:generic_error().
        |  add_links(#model_config{bucket = Bucket} = ModelConfig, Key, Links) when is_list(Links) -&gt;
   548..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key))]) of
        |          {ok, Result} -&gt;
   284..|              add_links4(ModelConfig, Key, Links, Result);
        |          {error, {notfound, _}} -&gt;
   264..|              add_links4(ModelConfig, Key, Links, riakc_map:new());
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  -spec add_links4(model_behaviour:model_config(), datastore:ext_key(), [datastore:normalized_link_spec()], InternalCtx :: term()) -&gt;
        |      ok | datastore:generic_error().
        |  add_links4(#model_config{bucket = Bucket} = _ModelConfig, Key, [], Ctx) -&gt;
   548..|      case call(riakc_pb_socket, update_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key)), riakc_map:to_op(Ctx)]) of
        |          ok -&gt;
   548..|              ok;
<font color=red>     0..|          {error, Reason} -&gt; {error, Reason}</font>
        |      end;
        |  add_links4(#model_config{bucket = _Bucket} = ModelConfig, Key, [Link | R], Ctx) -&gt;
   813..|      {LinkName, {_TargetKey, _TargetModel} = Target} = Link,
   813..|      NewCtx = riakc_map:update(
        |          {to_binary(LinkName), riakc_register:type()},
   813..|          fun(_) -&gt; to_riak_obj(to_binary(Target)) end, Ctx),
   813..|      add_links4(ModelConfig, Key, R, NewCtx).
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback delete_links/3.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec delete_links(model_behaviour:model_config(), datastore:ext_key(), [datastore:link_name()] | all) -&gt;
        |      ok | datastore:generic_error().
        |  delete_links(#model_config{bucket = Bucket} = _ModelConfig, Key, all) -&gt;
 13921..|      case call(riakc_pb_socket, delete, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key))]) of
        |          ok -&gt;
 13921..|              ok;
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end;
        |  delete_links(#model_config{bucket = Bucket} = ModelConfig, Key, Links) -&gt;
   223..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key))]) of
        |          {ok, Result} -&gt;
   192..|              delete_links4(ModelConfig, Key, Links, Result);
        |          {error, {notfound, _}} -&gt;
    31..|              ok;
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  -spec delete_links4(model_behaviour:model_config(), datastore:ext_key(), [datastore:normalized_link_spec()] | all, InternalCtx :: term()) -&gt;
        |      ok | datastore:generic_error().
        |  delete_links4(#model_config{bucket = Bucket} = _ModelConfig, Key, [], Ctx) -&gt;
   192..|      case call(riakc_pb_socket, update_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key)), riakc_map:to_op(Ctx)]) of
        |          ok -&gt;
   192..|              ok;
<font color=red>     0..|          {error, Reason} -&gt; {error, Reason}</font>
        |      end;
        |  delete_links4(#model_config{} = ModelConfig, Key, [Link | R], Ctx) -&gt;
   194..|      NewCtx = riakc_map:erase({to_binary(Link), register}, Ctx),
   194..|      delete_links4(ModelConfig, Key, R, NewCtx).
        |  
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback fetch_links/3.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec fetch_link(model_behaviour:model_config(), datastore:ext_key(), datastore:link_name()) -&gt;
        |      {ok, datastore:link_target()} | datastore:link_error().
        |  fetch_link(#model_config{bucket = Bucket} = _ModelConfig, Key, LinkName) -&gt;
   299..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key))]) of
        |          {ok, Result} -&gt;
   294..|              try riakc_map:fetch({to_binary(LinkName), register}, Result) of
        |                  EncodedLink -&gt;
    10..|                      {_TargetKey, _TargetModel} = Target = from_binary(form_riak_obj(register, EncodedLink)),
    10..|                      {ok, Target}
        |              catch
        |                  _:_E -&gt;
   284..|                      {error, link_not_found}
        |              end;
        |          {error, {notfound, _}} -&gt;
     5..|              {error, link_not_found};
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback foreach_link/4.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec foreach_link(model_behaviour:model_config(), Key :: datastore:ext_key(),
        |      fun((datastore:link_name(), datastore:link_target(), Acc :: term()) -&gt; Acc :: term()), AccIn :: term()) -&gt;
        |      {ok, Acc :: term()} | datastore:link_error().
        |  foreach_link(#model_config{bucket = Bucket} = _ModelConfig, Key, Fun, AccIn) -&gt;
  1239..|      case call(riakc_pb_socket, fetch_type, [{?RIAK_BUCKET_TYPE, bucket_encode(Bucket)}, to_binary(links_doc_key(Key))]) of
        |          {ok, Result} -&gt;
  1239..|              try
  1239..|                  FoldRet = riakc_map:fold(
        |                      fun({LinkName, DataType}, EncodedLink, Acc) -&gt;
  6808..|                          {_TargetKey, _TargetModel} = Target = from_binary(form_riak_obj(DataType, EncodedLink)),
  6808..|                          Fun(from_binary(LinkName), Target, Acc)
        |                      end, AccIn, Result),
  1239..|                  {ok, FoldRet}
        |              catch
        |                  _:Reason1 -&gt;
<font color=red>     0..|                      {error, Reason1}</font>
        |              end;
        |          {error, {notfound, _}} -&gt;
<font color=red>     0..|              {ok, AccIn};</font>
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% {@link store_driver_behaviour} callback healthcheck/1.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec healthcheck(WorkerState :: term()) -&gt; ok | {error, Reason :: term()}.
        |  healthcheck(_) -&gt;
    89..|      try call(riakc_pb_socket, ping, []) of
    89..|          pong -&gt; ok;
        |          Other -&gt;
<font color=red>     0..|              {error, {riak_connection_error, Other}}</font>
        |      catch
        |          _:Reason -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Translates given riak object to erlang term.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec form_riak_obj(map | counter | register, Obj :: term()) -&gt; term().
        |  form_riak_obj(map, Obj) -&gt;
        |      %% somehow, sometimes, riak's client returns orddict instead of #map{}
   678..|      FoldMod = case Obj of
   314..|                    [_ | _] -&gt; orddict;
   364..|                    _       -&gt; riakc_map
        |                end,
   678..|      datastore_utils:shallow_to_record(
        |          FoldMod:fold(
        |              fun({K, Type}, V, Acc) -&gt;
  2248..|                  maps:put(from_binary(K), form_riak_obj(Type, V), Acc)
        |              end, #{}, Obj)
        |      );
        |  form_riak_obj(counter, Obj) when is_integer(Obj) -&gt;
<font color=red>     0..|      Obj;</font>
        |  form_riak_obj(counter, Obj) -&gt;
<font color=red>     0..|      riakc_counter:value(Obj);</font>
        |  form_riak_obj(register, Obj) when is_binary(Obj) -&gt;
  8752..|      from_binary(Obj);
        |  form_riak_obj(register, Obj) -&gt;
<font color=red>     0..|      from_binary(riakc_register:value(Obj)).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Translates given erlang map into riak object that maybe already initialized.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec to_riak_obj(term(), undefined | term()) -&gt; term().
        |  to_riak_obj(Term, undefined) when is_tuple(Term) -&gt;
  2160..|      to_riak_obj(Term);
        |  to_riak_obj(Term, Rev) when is_tuple(Term) -&gt;
  5221..|      Map = datastore_utils:shallow_to_map(Term),
  5221..|      RMap0 = Rev,
  5221..|      maps:fold(
        |          fun(K, V, Acc) -&gt;
 19963..|              RiakObj = to_riak_obj(V),
 19963..|              Module = riakc_datatype:module_for_term(RiakObj),
 19963..|              Type = Module:type(),
 19963..|              riakc_map:update({to_binary(K), Type}, fun(_) -&gt; RiakObj end, Acc)
        |          end, RMap0, Map).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Translates given erlang term into new riak object.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec to_riak_obj(term()) -&gt; term().
        |  to_riak_obj(Term) when is_tuple(Term) -&gt;
  5221..|      to_riak_obj(Term, riakc_map:new());
        |  to_riak_obj(Bin) when is_binary(Bin) -&gt;
  3674..|      Register = riakc_register:new(),
  3674..|      riakc_register:set(Bin, Register);
        |  to_riak_obj(Atom) when is_atom(Atom) -&gt;
 11269..|      Register = riakc_register:new(),
 11269..|      Bin = atom_to_binary(Atom, utf8),
 11269..|      riakc_register:set(&lt;&lt;"ATOM::", Bin/binary&gt;&gt;, Register);
        |  to_riak_obj(Term) -&gt;
  5123..|      Register = riakc_register:new(),
  5123..|      Bin = to_binary(Term),
  5123..|      riakc_register:set(Bin, Register).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Calls given MFA with riak connection handle added as first argument.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec call(Module :: atom(), Method :: atom(), Args :: [term()]) -&gt; term() | {error, no_riak_nodes}.
        |  call(Module, Method, Args) -&gt;
 29969..|      call(Module, Method, Args, 3).
        |  
        |  call(Module, Method, Args, Retry) when Retry &gt;= 0 -&gt;
 29969..|      {Node, Pid} = select_connection(),
 29969..|      try apply(Module, Method, [Pid | Args]) of
 29969..|          Result -&gt; Result
        |      catch
        |          _:Reason -&gt;
<font color=red>     0..|              ?error_stacktrace("Failed to call Riak node ~p due to ~p", [Node, Reason]),</font>
<font color=red>     0..|              NewConn = [Conn || {N, _} = Conn &lt;- datastore_worker:state_get(riak_connections), N =/= Node],</font>
<font color=red>     0..|              datastore_worker:state_put(riak_connections, NewConn),</font>
<font color=red>     0..|              call(Module, Method, Args, Retry - 1)</font>
        |      end;
        |  call(_Module, _Method, _Args, _Retry) -&gt;
<font color=red>     0..|      {error, no_riak_nodes}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Selects riak connection from connection pool retuned by get_connections/0.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec select_connection() -&gt; riak_connection().
        |  select_connection() -&gt;
 29969..|      Connections = get_connections(),
 29969..|      lists:nth(crypto:rand_uniform(1, length(Connections) + 1), Connections).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Gets riak active connections. When no connection is available, tries to
        |  %% estabilish new connections.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_connections() -&gt; [riak_connection()].
        |  get_connections() -&gt;
 29969..|      case datastore_worker:state_get(riak_connections) of
        |          [_ | _] = Connections -&gt;
 29939..|              Connections;
        |          _ -&gt;
    30..|              Nodes = lists:map(
        |                  fun(Elem) -&gt;
    50..|                      [Elem || _ &lt;- lists:seq(1, ?CONN_PER_NODE)]
        |                  end, datastore_worker:state_get(riak_nodes)),
    30..|              Connections = connect(lists:flatten(Nodes)),
    30..|              datastore_worker:state_put(riak_connections, Connections),
    30..|              Connections
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Connects to given Riak database nodes.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec connect([riak_node()]) -&gt; [riak_connection()].
        |  connect([{HostName, Port} = Node | R]) -&gt;
   500..|      case riakc_pb_socket:start_link(binary_to_list(HostName), Port) of
        |          {ok, Pid} -&gt;
   500..|              [{Node, Pid} | connect(R)];
        |          {error, Reason} -&gt;
<font color=red>     0..|              ?error("Cannot connect to riak node ~p due to ~p", [Node, Reason]),</font>
<font color=red>     0..|              connect(R)</font>
        |      end;
        |  connect([]) -&gt;
    30..|      [].
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Encodes given term to base64 binary.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec term_to_base64(term()) -&gt; binary().
        |  term_to_base64(Term) -&gt;
 10897..|      Base = base64:encode(term_to_binary(Term)),
 10897..|      &lt;&lt;?OBJ_PREFIX, Base/binary&gt;&gt;.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Decodes given base64 binary to erlang term (reverses term_to_base64/1).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec base64_to_term(binary()) -&gt; term().
        |  base64_to_term(&lt;&lt;?OBJ_PREFIX, Base/binary&gt;&gt;) -&gt;
  7814..|      binary_to_term(base64:decode(Base)).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Encodes given given term as binary which maybe human readable if possible.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec to_binary(term()) -&gt; binary().
        |  to_binary(Term) when is_binary(Term) -&gt;
 47564..|      Term;
        |  to_binary(Term) when is_atom(Term) -&gt;
 17354..|      &lt;&lt;?ATOM_PREFIX, (atom_to_binary(Term, utf8))/binary&gt;&gt;;
        |  to_binary(Term) -&gt;
 10897..|      term_to_base64(Term).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Translates given database "register" object to erlang term (reverses to_binary/1).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec from_binary(binary()) -&gt; term().
        |  from_binary(&lt;&lt;?OBJ_PREFIX, _/binary&gt;&gt; = Bin) -&gt;
  7814..|      base64_to_term(Bin);
        |  from_binary(&lt;&lt;?ATOM_PREFIX, Atom/binary&gt;&gt;) -&gt;
  5354..|      binary_to_atom(Atom, utf8);
        |  from_binary(Bin) -&gt;
 11458..|      Bin.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Encodes geven bucket name to format supported by database.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec bucket_encode(datastore:bucket()) -&gt; binary().
        |  bucket_encode(Bucket) when is_atom(Bucket) -&gt;
 29880..|      atom_to_binary(Bucket, utf8);
        |  bucket_encode(Bucket) when is_binary(Bucket) -&gt;
<font color=red>     0..|      Bucket.</font>
        |  
        |  links_doc_key(Key) -&gt;
 16970..|      BinKey = to_binary(Key),
 16970..|      &lt;&lt;BinKey/binary, ?LINKS_KEY_SUFFIX&gt;&gt;.</pre>
</body>
</html>
