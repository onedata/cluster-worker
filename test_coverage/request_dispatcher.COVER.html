<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/request_dispatcher.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/cluster_elements/request_dispatcher/request_dispatcher.erl by COVER 2015-08-06 at 11:00:43

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Michal Wrzeszcz
        |  %%% @author Tomasz Lichon
        |  %%% @author Lukasz Opiola
        |  %%% @copyright (C) 2013 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc
        |  %%% This module updates worker_map on cluster state change
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(request_dispatcher).
        |  -author("Michal Wrzeszcz").
        |  -author("Tomasz Lichon").
        |  -author("Lukasz Opiola").
        |  
        |  -behaviour(gen_server).
        |  
        |  -include("modules_and_args.hrl").
        |  -include("global_definitions.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  % ETS used to hold workers mapping.
        |  -define(LB_ADVICE_KEY, lb_advice).
        |  -define(WORKER_MAP_ETS, workers_ets).
        |  
        |  % Types used in request routing.
        |  -type worker_name() :: atom().
        |  -type worker_ref() :: worker_name() | {WorkerName :: worker_name(), Node :: node()}.
        |  -export_type([worker_name/0, worker_ref/0]).
        |  
        |  %% This record is used by requests_dispatcher (it contains its state).
        |  -record(state, {
        |      % Time of last ld advice update received from dispatcher
        |      last_update = {0, 0, 0} :: {integer(), integer(), integer()}
        |  }).
        |  
        |  %% API
        |  -export([start_link/0, stop/0]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
        |  
        |  %% Request routing API
        |  -export([get_worker_node/1, get_worker_nodes/1]).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Starts request_dispatcher
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec start_link() -&gt; Result when
        |      Result :: {ok, Pid}
        |      | ignore
        |      | {error, Error},
        |      Pid :: pid(),
        |      Error :: {already_started, Pid} | term().
        |  start_link() -&gt;
    30..|      gen_server:start_link({local, ?DISPATCHER_NAME}, ?MODULE, [], []).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Stops request_dispatcher
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec stop() -&gt; ok.
        |  stop() -&gt;
<font color=red>     0..|      gen_server:cast(?DISPATCHER_NAME, stop).</font>
        |  
        |  %%%===================================================================
        |  %%% gen_server callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Initializes the server
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init(Args :: term()) -&gt; Result when
        |      Result :: {ok, State}
        |      | {ok, State, Timeout}
        |      | {ok, State, hibernate}
        |      | {stop, Reason :: term()}
        |      | ignore,
        |      State :: term(),
        |      Timeout :: non_neg_integer() | infinity.
        |  init(_) -&gt;
    30..|      process_flag(trap_exit, true),
    30..|      ets:new(?WORKER_MAP_ETS, [set, protected, named_table, {read_concurrency, true}]),
        |      % Insert undefined as LB advice - it means that the node is not yet initialized
        |      % and it should not accept requests to workers.
    30..|      ets:insert(?WORKER_MAP_ETS, {?LB_ADVICE_KEY, undefined}),
    30..|      {ok, #state{}}.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling call messages
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_call(Request :: term(), From :: {pid(), Tag :: term()}, State :: term()) -&gt; Result when
        |      Result :: {reply, Reply, NewState}
        |      | {reply, Reply, NewState, Timeout}
        |      | {reply, Reply, NewState, hibernate}
        |      | {noreply, NewState}
        |      | {noreply, NewState, Timeout}
        |      | {noreply, NewState, hibernate}
        |      | {stop, Reason, Reply, NewState}
        |      | {stop, Reason, NewState},
        |      Reply :: nagios_handler:healthcheck_response() | term(),
        |      NewState :: term(),
        |      Timeout :: non_neg_integer() | infinity,
        |      Reason :: term().
        |  handle_call(healthcheck, _From, #state{last_update = LastUpdate} = State) -&gt;
        |      % Report error as long as no LB advice has been received.
    89..|      Reply = case ets:lookup(?WORKER_MAP_ETS, ?LB_ADVICE_KEY) of
        |                  [{?LB_ADVICE_KEY, undefined}] -&gt;
     8..|                      {error, no_lb_advice_received};
        |                  _ -&gt;
    81..|                      {ok, Threshold} = application:get_env(?APP_NAME, dns_disp_out_of_sync_threshold),
        |                      % Threshold is in millisecs, now_diff is in microsecs
    81..|                      case utils:milliseconds_diff(now(), LastUpdate) &gt; Threshold of
<font color=red>     0..|                          true -&gt; out_of_sync;</font>
    81..|                          false -&gt; ok
        |                      end
        |              end,
    89..|      {reply, Reply, State};
        |  
        |  handle_call(_Request, _From, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {reply, wrong_request, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling cast messages
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_cast(Request :: term(), State :: term()) -&gt; Result when
        |      Result :: {noreply, NewState}
        |      | {noreply, NewState, Timeout}
        |      | {noreply, NewState, hibernate}
        |      | {stop, Reason :: term(), NewState},
        |      NewState :: term(),
        |      Timeout :: non_neg_integer() | infinity.
        |  
        |  handle_cast({update_lb_advice, LBAdvice}, State) -&gt;
  3661..|      ?debug("Dispatcher update of load_balancing advice: ~p", [LBAdvice]),
        |      % Update LB advice
  3661..|      ets:insert(?WORKER_MAP_ETS, {?LB_ADVICE_KEY, LBAdvice}),
  3661..|      {noreply, State#state{last_update = now()}};
        |  
        |  handle_cast(stop, State) -&gt;
<font color=red>     0..|      {stop, normal, State};</font>
        |  
        |  handle_cast(_Request, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling all non call/cast messages
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_info(Info :: timeout | term(), State :: term()) -&gt; Result when
        |      Result :: {noreply, NewState}
        |      | {noreply, NewState, Timeout}
        |      | {noreply, NewState, hibernate}
        |      | {stop, Reason :: term(), NewState},
        |      NewState :: term(),
        |      Timeout :: non_neg_integer() | infinity.
        |  handle_info({timer, Msg}, State) -&gt;
<font color=red>     0..|      gen_server:cast(?DISPATCHER_NAME, Msg),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  handle_info(_Request, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% This function is called by a gen_server when it is about to
        |  %% terminate. It should be the opposite of Module:init/1 and do any
        |  %% necessary cleaning up. When it returns, the gen_server terminates
        |  %% with Reason. The return value is ignored.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate(Reason, State :: term()) -&gt; Any :: term() when
        |      Reason :: normal
        |      | shutdown
        |      | {shutdown, term()}
        |      | term().
        |  terminate(_Reason, _State) -&gt;
    30..|      ets:delete(?WORKER_MAP_ETS),
    30..|      ok.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Convert process state when code is changed
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec code_change(OldVsn, State :: term(), Extra :: term()) -&gt; Result when
        |      Result :: {ok, NewState :: term()} | {error, Reason :: term()},
        |      OldVsn :: Vsn | {down, Vsn},
        |      Vsn :: term().
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %%%===================================================================
        |  %%% Request routing API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Chooses to which worker (on which node) the request should be sent.
        |  %%
        |  %% NOTE: currently, all nodes host all workers, so worker type can be omitted.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_worker_node(WorkerName :: worker_name()) -&gt; {ok, node()} | {error, dispatcher_out_of_sync}.
        |  get_worker_node(WorkerName) -&gt;
 28852..|      case ets:lookup(?WORKER_MAP_ETS, ?LB_ADVICE_KEY) of
        |          [{?LB_ADVICE_KEY, undefined}] -&gt;
    70..|              {error, dispatcher_out_of_sync};
        |          [{?LB_ADVICE_KEY, LBAdvice}] -&gt;
 28661..|              Node = load_balancing:choose_node_for_dispatcher(LBAdvice, WorkerName),
 28661..|              {ok, Node}
        |      end.
        |  
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Returns all workers that host given worker.
        |  %%
        |  %% NOTE: currently, all nodes host all workers, so worker type can be omitted.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec get_worker_nodes(WorkerName :: worker_name()) -&gt; {ok, [node()]} | {error, dispatcher_out_of_sync}.
        |  get_worker_nodes(_WorkerName) -&gt;
<font color=red>     0..|      case ets:lookup(?WORKER_MAP_ETS, ?LB_ADVICE_KEY) of</font>
        |          [{?LB_ADVICE_KEY, undefined}] -&gt;
<font color=red>     0..|              {error, dispatcher_out_of_sync};</font>
        |          [{?LB_ADVICE_KEY, LBAdvice}] -&gt;
<font color=red>     0..|              Nodes = load_balancing:all_nodes_for_dispatcher(LBAdvice),</font>
<font color=red>     0..|              {ok, Nodes}</font>
        |      end.
</pre>
</body>
</html>
