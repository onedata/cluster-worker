<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/piotrek/Dokumenty/OneData/merge_merge/op-worker/test_coverage/connection.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/piotrek/Dokumenty/OneData/merge_merge/op-worker/ebin/../src/modules/session/communicator/connection.erl by COVER 2015-08-06 at 11:00:40

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Tomasz Lichon
        |  %%% @copyright (C) 2015 ACK CYFRONET AGH
        |  %%% This software is released under the MIT license
        |  %%% cited in 'LICENSE.txt'.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  %%% @doc
        |  %%% This module handles client and provider requests.
        |  %%% @end
        |  %%%-------------------------------------------------------------------
        |  -module(connection).
        |  -author("Tomasz Lichon").
        |  
        |  -behaviour(ranch_protocol).
        |  -behaviour(gen_server).
        |  
        |  -include("proto/oneclient/client_messages.hrl").
        |  -include("proto/oneclient/server_messages.hrl").
        |  -include("proto/oneclient/handshake_messages.hrl").
        |  -include_lib("ctool/include/logging.hrl").
        |  
        |  %% API
        |  -export([start_link/4, init/4, send/2, send_async/2]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,
        |      code_change/3]).
        |  
        |  -record(sock_state, {
        |      certificate :: #'OTPCertificate'{},
        |      % handler responses
        |      ok :: atom(),
        |      closed :: atom(),
        |      error :: atom(),
        |      % actual connection state
        |      socket :: ssl2:socket(),
        |      transport :: module(),
        |      session_id :: session:id()
        |  }).
        |  
        |  -define(TIMEOUT, timer:minutes(1)).
        |  -define(PACKET_VALUE, 4).
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Send server_message to client, returns sending result info.
        |  %% @equiv gen_server:call(Pid, {send, Req}).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send(Pid :: pid(), Req :: #server_message{}) -&gt; ok | {error, term()}.
        |  send(Pid, Req) -&gt;
 11164..|      gen_server:call(Pid, {send, Req}).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Send server_message to client, returns 'ok'.
        |  %% @equiv gen_server:cast(Pid, {send, Req}).
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send_async(Pid :: pid(), Req :: #server_message{}) -&gt; ok.
        |  send_async(Pid, Req) -&gt;
<font color=red>     0..|      gen_server:cast(Pid, {send, Req}).</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Starts the server.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec start_link(Ref :: atom(), Socket :: ssl2:socket(), Transport :: atom(), Opts :: list()) -&gt;
        |      {ok, Pid :: pid()}.
        |  start_link(Ref, Socket, Transport, Opts) -&gt;
   210..|      proc_lib:start_link(?MODULE, init, [Ref, Socket, Transport, Opts]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Initializes the server.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init(Args :: term(), Socket :: ssl2:socket(), Transport :: atom(), Opts :: list()) -&gt;
        |      no_return().
        |  init(Ref, Socket, Transport, _Opts = []) -&gt;
   210..|      ok = proc_lib:init_ack({ok, self()}),
   210..|      ok = ranch:accept_ack(Ref),
   210..|      ok = Transport:setopts(Socket, [binary, {active, once}, {packet, ?PACKET_VALUE}]),
   210..|      {Ok, Closed, Error} = Transport:messages(),
   210..|      Certificate =
        |          case ssl2:peercert(Socket) of
   210..|              {error, _} -&gt; undefined;
<font color=red>     0..|              {ok, Der} -&gt; public_key:pkix_decode_cert(Der, otp)</font>
        |          end,
        |  
   210..|      gen_server:enter_loop(?MODULE, [], #sock_state{
        |          socket = Socket,
        |          transport = Transport,
        |          ok = Ok,
        |          closed = Closed,
        |          error = Error,
        |          certificate = Certificate
        |      }, ?TIMEOUT).
        |  
        |  %%%===================================================================
        |  %%% gen_server callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% This function is never called. We only define it so that
        |  %% we can use the -behaviour(gen_server) attribute. Init is handled by ranch
        |  %% init/4 function
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec init([]) -&gt; {ok, undefined}.
<font color=red>     0..|  init([]) -&gt; {ok, undefined}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handles call messages.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_call(Request :: term(), From :: {pid(), Tag :: term()},
        |      State :: #sock_state{}) -&gt;
        |      {reply, Reply :: term(), NewState :: #sock_state{}} |
        |      {reply, Reply :: term(), NewState :: #sock_state{}, timeout() | hibernate} |
        |      {noreply, NewState :: #sock_state{}} |
        |      {noreply, NewState :: #sock_state{}, timeout() | hibernate} |
        |      {stop, Reason :: term(), Reply :: term(), NewState :: #sock_state{}} |
        |      {stop, Reason :: term(), NewState :: #sock_state{}}.
        |  handle_call({send, ServerMsg}, _From, State = #sock_state{socket = Socket,
        |      transport = Transport}) -&gt;
 11126..|      send_server_message(Socket, Transport, ServerMsg),
 11126..|      {reply, ok, State};
        |  
        |  handle_call(_Request, _From, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {reply, wrong_request, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handles cast messages.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_cast(Request :: term(), State :: #sock_state{}) -&gt;
        |      {noreply, NewState :: #sock_state{}} |
        |      {noreply, NewState :: #sock_state{}, timeout() | hibernate} |
        |      {stop, Reason :: term(), NewState :: #sock_state{}}.
        |  handle_cast({send, ServerMsg}, State = #sock_state{socket = Socket,
        |      transport = Transport}) -&gt;
<font color=red>     0..|      send_server_message(Socket, Transport, ServerMsg),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  
        |  handle_cast(_Request, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Request),</font>
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handles all non call/cast messages.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_info(Info :: timeout() | {Ok :: atom(), Socket :: ssl2:socket(),
        |      Data :: binary()} | term(), State :: #sock_state{}) -&gt;
        |      {noreply, NewState :: #sock_state{}} |
        |      {noreply, NewState :: #sock_state{}, timeout() | hibernate} |
        |      {stop, Reason :: term(), NewState :: #sock_state{}}.
        |  handle_info({Ok, Socket, Data}, State = #sock_state{socket = Socket, ok = Ok,
        |      transport = Transport}) -&gt;
 12146..|      activate_socket_once(Socket, Transport),
 12146..|      handle_client_message(State, Data);
        |  
        |  handle_info({Closed, _}, State = #sock_state{closed = Closed}) -&gt;
    90..|      {stop, normal, State};
        |  
        |  handle_info({Error, Socket, Reason}, State = #sock_state{error = Error}) -&gt;
   119..|      ?warning("Connection ~p error: ~p", [Socket, Reason]),
    17..|      {stop, Reason, State};
        |  
        |  handle_info(timeout, State = #sock_state{socket = Socket}) -&gt;
<font color=red>     0..|      ?warning("Connection ~p timeout", [Socket]),</font>
<font color=red>     0..|      {stop, normal, State};</font>
        |  
        |  handle_info(_Info, State) -&gt;
<font color=red>     0..|      ?log_bad_request(_Info),</font>
<font color=red>     0..|      {stop, normal, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% This function is called by a gen_server when it is about to
        |  %% terminate. It should be the opposite of Module:init/1 and do any
        |  %% necessary cleaning up. When it returns, the gen_server terminates
        |  %% with Reason. The return value is ignored.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec terminate(Reason :: (normal | shutdown | {shutdown, term()} | term()),
        |      State :: #sock_state{}) -&gt; term().
        |  terminate(Reason, #sock_state{session_id = Id} = State) -&gt;
   107..|      ?log_terminate(Reason, State),
   107..|      catch communicator:remove_connection(Id, self()),
   107..|      ok.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Converts process state when code is changed.
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec code_change(OldVsn :: term() | {down, term()}, State :: #sock_state{},
        |      Extra :: term()) -&gt; {ok, NewState :: #sock_state{}} | {error, Reason :: term()}.
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handle usual client data, it is decoded and passed to subsequent handler
        |  %% functions
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_client_message(#sock_state{}, binary()) -&gt;
        |      {noreply, NewState :: #sock_state{}, timeout()} |
        |      {stop, Reason :: term(), NewState :: #sock_state{}}.
        |  handle_client_message(State = #sock_state{session_id = SessId}, Data) -&gt;
 12146..|      try serializator:deserialize_client_message(Data, SessId) of
        |          {ok, Msg} when SessId == undefined -&gt;
   121..|              handle_handshake(State, Msg);
        |          {ok, Msg} -&gt;
 12025..|              handle_normal_message(State, Msg)
        |      catch
        |          _:Error -&gt;
<font color=red>     0..|              ?warning_stacktrace("Client message decoding error: ~p", [Error]),</font>
<font color=red>     0..|              {stop, Error, State}</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handle client handshake_request, it is necessary to authenticate
        |  %% and obtain session
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_handshake(#sock_state{}, #client_message{}) -&gt;
        |      {noreply, NewState :: #sock_state{}, timeout()} |
        |      {stop, Reason :: term(), NewState :: #sock_state{}}.
        |  handle_handshake(State = #sock_state{certificate = Cert, socket = Sock,
        |      transport = Transp}, Msg) -&gt;
   121..|      try auth_manager:handle_handshake(Msg, Cert) of
        |          {ok, Response = #server_message{message_body =
        |          #handshake_response{session_id = NewSessId}}} -&gt;
   121..|              send_server_message(Sock, Transp, Response),
   121..|              {noreply, State#sock_state{session_id = NewSessId}, ?TIMEOUT}
        |      catch
        |          _:Error -&gt;
<font color=red>     0..|              ?warning_stacktrace("Handshake ~p, error ~p", [Msg, Error]),</font>
<font color=red>     0..|              {stop, Error, State}</font>
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handle nomal client_message
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec handle_normal_message(#sock_state{}, #client_message{}) -&gt;
        |      {noreply, NewState :: #sock_state{}, timeout()} |
        |      {stop, Reason :: term(), NewState :: #sock_state{}}.
        |  handle_normal_message(State = #sock_state{session_id = SessId,
        |      socket = _Sock, transport = _Transp}, Msg) -&gt;
 12025..|      case router:preroute_message(Msg, SessId) of
        |          ok -&gt;
 12025..|              {noreply, State, ?TIMEOUT}
        |  %%         {error, Reason} -&gt;
        |  %%             ?warning("Message ~p handling error: ~p", [Msg, Reason]),
        |  %%             {stop, {error, Reason}, State}
        |      end.
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Activate socket for next message, so it will be send to handling process
        |  %% via erlang message
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec activate_socket_once(Socket :: ssl2:socket(), Transport :: module()) -&gt; ok.
        |  activate_socket_once(Socket, Transport) -&gt;
 12146..|      ok = Transport:setopts(Socket, [{active, once}]).
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Activate socket for next message, so it will be send to handling process
        |  %% via erlang message
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  -spec send_server_message(Socket :: ssl2:socket(), Transport :: module(),
        |      ServerMessage :: #server_message{}) -&gt; ok.
        |  send_server_message(Socket, Transport, ServerMsg) -&gt;
 11247..|      {ok, Data} = serializator:serialize_server_message(ServerMsg),
 11247..|      ok = Transport:send(Socket, Data).
        |  
</pre>
</body>
</html>
