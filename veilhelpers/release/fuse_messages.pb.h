// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fuse_messages.proto

#ifndef PROTOBUF_fuse_5fmessages_2eproto__INCLUDED
#define PROTOBUF_fuse_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace veil {
namespace protocol {
namespace fuse_messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_fuse_5fmessages_2eproto();
void protobuf_AssignDesc_fuse_5fmessages_2eproto();
void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

class ChannelRegistration;
class ChannelClose;
class FuseMessage;
class GetFileLocation;
class GetNewFileLocation;
class GetFileAttr;
class FileAttr;
class GetFileUuid;
class FileUuid;
class FileLocation;
class CreateFileAck;
class FileNotUsed;
class RenewFileLocation;
class FileLocationValidity;
class GetFileChildren;
class FileChildren;
class CreateDir;
class DeleteFile;
class CreateLink;
class GetLink;
class LinkInfo;
class RenameFile;
class ChangeFileOwner;
class ChangeFileGroup;
class ChangeFilePerms;
class CheckFilePerms;
class UpdateTimes;
class TestChannel;
class TestChannelAnswer;
class HandshakeRequest;
class HandshakeRequest_EnvVariable;
class HandshakeRequest_CertConfirmation;
class HandshakeResponse;
class HandshakeAck;
class CreateStorageTestFileRequest;
class CreateStorageTestFileResponse;
class StorageTestFileModifiedRequest;
class StorageTestFileModifiedResponse;
class ClientStorageInfo;
class ClientStorageInfo_StorageInfo;
class GetStatFS;
class StatFSInfo;
class EventFilterConfig;
class EventAggregatorConfig;
class EventTransformerConfig;
class EventStreamConfig;
class EventProducerConfig;
class EventMessage;

// ===================================================================

class ChannelRegistration : public ::google::protobuf::Message {
 public:
  ChannelRegistration();
  virtual ~ChannelRegistration();

  ChannelRegistration(const ChannelRegistration& from);

  inline ChannelRegistration& operator=(const ChannelRegistration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelRegistration& default_instance();

  void Swap(ChannelRegistration* other);

  // implements Message ----------------------------------------------

  ChannelRegistration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelRegistration& from);
  void MergeFrom(const ChannelRegistration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fuse_id = 1;
  inline bool has_fuse_id() const;
  inline void clear_fuse_id();
  static const int kFuseIdFieldNumber = 1;
  inline const ::std::string& fuse_id() const;
  inline void set_fuse_id(const ::std::string& value);
  inline void set_fuse_id(const char* value);
  inline void set_fuse_id(const char* value, size_t size);
  inline ::std::string* mutable_fuse_id();
  inline ::std::string* release_fuse_id();
  inline void set_allocated_fuse_id(::std::string* fuse_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ChannelRegistration)
 private:
  inline void set_has_fuse_id();
  inline void clear_has_fuse_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fuse_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ChannelRegistration* default_instance_;
};
// -------------------------------------------------------------------

class ChannelClose : public ::google::protobuf::Message {
 public:
  ChannelClose();
  virtual ~ChannelClose();

  ChannelClose(const ChannelClose& from);

  inline ChannelClose& operator=(const ChannelClose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelClose& default_instance();

  void Swap(ChannelClose* other);

  // implements Message ----------------------------------------------

  ChannelClose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelClose& from);
  void MergeFrom(const ChannelClose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fuse_id = 1;
  inline bool has_fuse_id() const;
  inline void clear_fuse_id();
  static const int kFuseIdFieldNumber = 1;
  inline const ::std::string& fuse_id() const;
  inline void set_fuse_id(const ::std::string& value);
  inline void set_fuse_id(const char* value);
  inline void set_fuse_id(const char* value, size_t size);
  inline ::std::string* mutable_fuse_id();
  inline ::std::string* release_fuse_id();
  inline void set_allocated_fuse_id(::std::string* fuse_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ChannelClose)
 private:
  inline void set_has_fuse_id();
  inline void clear_has_fuse_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fuse_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ChannelClose* default_instance_;
};
// -------------------------------------------------------------------

class FuseMessage : public ::google::protobuf::Message {
 public:
  FuseMessage();
  virtual ~FuseMessage();

  FuseMessage(const FuseMessage& from);

  inline FuseMessage& operator=(const FuseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuseMessage& default_instance();

  void Swap(FuseMessage* other);

  // implements Message ----------------------------------------------

  FuseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuseMessage& from);
  void MergeFrom(const FuseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline const ::std::string& message_type() const;
  inline void set_message_type(const ::std::string& value);
  inline void set_message_type(const char* value);
  inline void set_message_type(const char* value, size_t size);
  inline ::std::string* mutable_message_type();
  inline ::std::string* release_message_type();
  inline void set_allocated_message_type(::std::string* message_type);

  // required bytes input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::std::string& input() const;
  inline void set_input(const ::std::string& value);
  inline void set_input(const char* value);
  inline void set_input(const void* value, size_t size);
  inline ::std::string* mutable_input();
  inline ::std::string* release_input();
  inline void set_allocated_input(::std::string* input);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FuseMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_type_;
  ::std::string* input_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FuseMessage* default_instance_;
};
// -------------------------------------------------------------------

class GetFileLocation : public ::google::protobuf::Message {
 public:
  GetFileLocation();
  virtual ~GetFileLocation();

  GetFileLocation(const GetFileLocation& from);

  inline GetFileLocation& operator=(const GetFileLocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileLocation& default_instance();

  void Swap(GetFileLocation* other);

  // implements Message ----------------------------------------------

  GetFileLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileLocation& from);
  void MergeFrom(const GetFileLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // optional string open_mode = 2 [default = ""];
  inline bool has_open_mode() const;
  inline void clear_open_mode();
  static const int kOpenModeFieldNumber = 2;
  inline const ::std::string& open_mode() const;
  inline void set_open_mode(const ::std::string& value);
  inline void set_open_mode(const char* value);
  inline void set_open_mode(const char* value, size_t size);
  inline ::std::string* mutable_open_mode();
  inline ::std::string* release_open_mode();
  inline void set_allocated_open_mode(::std::string* open_mode);

  // optional bool force_cluster_proxy = 3 [default = false];
  inline bool has_force_cluster_proxy() const;
  inline void clear_force_cluster_proxy();
  static const int kForceClusterProxyFieldNumber = 3;
  inline bool force_cluster_proxy() const;
  inline void set_force_cluster_proxy(bool value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetFileLocation)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_open_mode();
  inline void clear_has_open_mode();
  inline void set_has_force_cluster_proxy();
  inline void clear_has_force_cluster_proxy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::std::string* open_mode_;
  bool force_cluster_proxy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetFileLocation* default_instance_;
};
// -------------------------------------------------------------------

class GetNewFileLocation : public ::google::protobuf::Message {
 public:
  GetNewFileLocation();
  virtual ~GetNewFileLocation();

  GetNewFileLocation(const GetNewFileLocation& from);

  inline GetNewFileLocation& operator=(const GetNewFileLocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNewFileLocation& default_instance();

  void Swap(GetNewFileLocation* other);

  // implements Message ----------------------------------------------

  GetNewFileLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNewFileLocation& from);
  void MergeFrom(const GetNewFileLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // required uint32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // optional bool force_cluster_proxy = 3 [default = false];
  inline bool has_force_cluster_proxy() const;
  inline void clear_force_cluster_proxy();
  static const int kForceClusterProxyFieldNumber = 3;
  inline bool force_cluster_proxy() const;
  inline void set_force_cluster_proxy(bool value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetNewFileLocation)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_force_cluster_proxy();
  inline void clear_has_force_cluster_proxy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::google::protobuf::uint32 mode_;
  bool force_cluster_proxy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetNewFileLocation* default_instance_;
};
// -------------------------------------------------------------------

class GetFileAttr : public ::google::protobuf::Message {
 public:
  GetFileAttr();
  virtual ~GetFileAttr();

  GetFileAttr(const GetFileAttr& from);

  inline GetFileAttr& operator=(const GetFileAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileAttr& default_instance();

  void Swap(GetFileAttr* other);

  // implements Message ----------------------------------------------

  GetFileAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileAttr& from);
  void MergeFrom(const GetFileAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetFileAttr)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetFileAttr* default_instance_;
};
// -------------------------------------------------------------------

class FileAttr : public ::google::protobuf::Message {
 public:
  FileAttr();
  virtual ~FileAttr();

  FileAttr(const FileAttr& from);

  inline FileAttr& operator=(const FileAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileAttr& default_instance();

  void Swap(FileAttr* other);

  // implements Message ----------------------------------------------

  FileAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileAttr& from);
  void MergeFrom(const FileAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // required int32 uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // required int32 gid = 4;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 4;
  inline ::google::protobuf::int32 gid() const;
  inline void set_gid(::google::protobuf::int32 value);

  // required int64 atime = 5;
  inline bool has_atime() const;
  inline void clear_atime();
  static const int kAtimeFieldNumber = 5;
  inline ::google::protobuf::int64 atime() const;
  inline void set_atime(::google::protobuf::int64 value);

  // required int64 mtime = 6;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 6;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);

  // required int64 ctime = 7;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 7;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);

  // required string type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int64 size = 10 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 10;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // optional string uname = 11 [default = ""];
  inline bool has_uname() const;
  inline void clear_uname();
  static const int kUnameFieldNumber = 11;
  inline const ::std::string& uname() const;
  inline void set_uname(const ::std::string& value);
  inline void set_uname(const char* value);
  inline void set_uname(const char* value, size_t size);
  inline ::std::string* mutable_uname();
  inline ::std::string* release_uname();
  inline void set_allocated_uname(::std::string* uname);

  // optional string gname = 12 [default = ""];
  inline bool has_gname() const;
  inline void clear_gname();
  static const int kGnameFieldNumber = 12;
  inline const ::std::string& gname() const;
  inline void set_gname(const ::std::string& value);
  inline void set_gname(const char* value);
  inline void set_gname(const char* value, size_t size);
  inline ::std::string* mutable_gname();
  inline ::std::string* release_gname();
  inline void set_allocated_gname(::std::string* gname);

  // optional int32 links = 13 [default = 1];
  inline bool has_links() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 13;
  inline ::google::protobuf::int32 links() const;
  inline void set_links(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FileAttr)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_atime();
  inline void clear_has_atime();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_uname();
  inline void clear_has_uname();
  inline void set_has_gname();
  inline void clear_has_gname();
  inline void set_has_links();
  inline void clear_has_links();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int64 atime_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int64 ctime_;
  ::std::string* type_;
  ::google::protobuf::int32 gid_;
  ::google::protobuf::int32 links_;
  ::google::protobuf::int64 size_;
  ::std::string* uname_;
  ::std::string* gname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FileAttr* default_instance_;
};
// -------------------------------------------------------------------

class GetFileUuid : public ::google::protobuf::Message {
 public:
  GetFileUuid();
  virtual ~GetFileUuid();

  GetFileUuid(const GetFileUuid& from);

  inline GetFileUuid& operator=(const GetFileUuid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileUuid& default_instance();

  void Swap(GetFileUuid* other);

  // implements Message ----------------------------------------------

  GetFileUuid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileUuid& from);
  void MergeFrom(const GetFileUuid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetFileUuid)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetFileUuid* default_instance_;
};
// -------------------------------------------------------------------

class FileUuid : public ::google::protobuf::Message {
 public:
  FileUuid();
  virtual ~FileUuid();

  FileUuid(const FileUuid& from);

  inline FileUuid& operator=(const FileUuid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileUuid& default_instance();

  void Swap(FileUuid* other);

  // implements Message ----------------------------------------------

  FileUuid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileUuid& from);
  void MergeFrom(const FileUuid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // required string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FileUuid)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FileUuid* default_instance_;
};
// -------------------------------------------------------------------

class FileLocation : public ::google::protobuf::Message {
 public:
  FileLocation();
  virtual ~FileLocation();

  FileLocation(const FileLocation& from);

  inline FileLocation& operator=(const FileLocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLocation& default_instance();

  void Swap(FileLocation* other);

  // implements Message ----------------------------------------------

  FileLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLocation& from);
  void MergeFrom(const FileLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // required int32 storage_id = 2;
  inline bool has_storage_id() const;
  inline void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  inline ::google::protobuf::int32 storage_id() const;
  inline void set_storage_id(::google::protobuf::int32 value);

  // required string file_id = 3;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 3;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int32 validity = 4;
  inline bool has_validity() const;
  inline void clear_validity();
  static const int kValidityFieldNumber = 4;
  inline ::google::protobuf::int32 validity() const;
  inline void set_validity(::google::protobuf::int32 value);

  // optional string storage_helper_name = 5;
  inline bool has_storage_helper_name() const;
  inline void clear_storage_helper_name();
  static const int kStorageHelperNameFieldNumber = 5;
  inline const ::std::string& storage_helper_name() const;
  inline void set_storage_helper_name(const ::std::string& value);
  inline void set_storage_helper_name(const char* value);
  inline void set_storage_helper_name(const char* value, size_t size);
  inline ::std::string* mutable_storage_helper_name();
  inline ::std::string* release_storage_helper_name();
  inline void set_allocated_storage_helper_name(::std::string* storage_helper_name);

  // repeated string storage_helper_args = 6;
  inline int storage_helper_args_size() const;
  inline void clear_storage_helper_args();
  static const int kStorageHelperArgsFieldNumber = 6;
  inline const ::std::string& storage_helper_args(int index) const;
  inline ::std::string* mutable_storage_helper_args(int index);
  inline void set_storage_helper_args(int index, const ::std::string& value);
  inline void set_storage_helper_args(int index, const char* value);
  inline void set_storage_helper_args(int index, const char* value, size_t size);
  inline ::std::string* add_storage_helper_args();
  inline void add_storage_helper_args(const ::std::string& value);
  inline void add_storage_helper_args(const char* value);
  inline void add_storage_helper_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& storage_helper_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_storage_helper_args();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FileLocation)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_storage_id();
  inline void clear_has_storage_id();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_validity();
  inline void clear_has_validity();
  inline void set_has_storage_helper_name();
  inline void clear_has_storage_helper_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::std::string* file_id_;
  ::google::protobuf::int32 storage_id_;
  ::google::protobuf::int32 validity_;
  ::std::string* storage_helper_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> storage_helper_args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FileLocation* default_instance_;
};
// -------------------------------------------------------------------

class CreateFileAck : public ::google::protobuf::Message {
 public:
  CreateFileAck();
  virtual ~CreateFileAck();

  CreateFileAck(const CreateFileAck& from);

  inline CreateFileAck& operator=(const CreateFileAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateFileAck& default_instance();

  void Swap(CreateFileAck* other);

  // implements Message ----------------------------------------------

  CreateFileAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateFileAck& from);
  void MergeFrom(const CreateFileAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.CreateFileAck)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static CreateFileAck* default_instance_;
};
// -------------------------------------------------------------------

class FileNotUsed : public ::google::protobuf::Message {
 public:
  FileNotUsed();
  virtual ~FileNotUsed();

  FileNotUsed(const FileNotUsed& from);

  inline FileNotUsed& operator=(const FileNotUsed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileNotUsed& default_instance();

  void Swap(FileNotUsed* other);

  // implements Message ----------------------------------------------

  FileNotUsed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileNotUsed& from);
  void MergeFrom(const FileNotUsed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FileNotUsed)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FileNotUsed* default_instance_;
};
// -------------------------------------------------------------------

class RenewFileLocation : public ::google::protobuf::Message {
 public:
  RenewFileLocation();
  virtual ~RenewFileLocation();

  RenewFileLocation(const RenewFileLocation& from);

  inline RenewFileLocation& operator=(const RenewFileLocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenewFileLocation& default_instance();

  void Swap(RenewFileLocation* other);

  // implements Message ----------------------------------------------

  RenewFileLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenewFileLocation& from);
  void MergeFrom(const RenewFileLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.RenewFileLocation)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static RenewFileLocation* default_instance_;
};
// -------------------------------------------------------------------

class FileLocationValidity : public ::google::protobuf::Message {
 public:
  FileLocationValidity();
  virtual ~FileLocationValidity();

  FileLocationValidity(const FileLocationValidity& from);

  inline FileLocationValidity& operator=(const FileLocationValidity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLocationValidity& default_instance();

  void Swap(FileLocationValidity* other);

  // implements Message ----------------------------------------------

  FileLocationValidity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLocationValidity& from);
  void MergeFrom(const FileLocationValidity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // optional int32 validity = 2;
  inline bool has_validity() const;
  inline void clear_validity();
  static const int kValidityFieldNumber = 2;
  inline ::google::protobuf::int32 validity() const;
  inline void set_validity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FileLocationValidity)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_validity();
  inline void clear_has_validity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::google::protobuf::int32 validity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FileLocationValidity* default_instance_;
};
// -------------------------------------------------------------------

class GetFileChildren : public ::google::protobuf::Message {
 public:
  GetFileChildren();
  virtual ~GetFileChildren();

  GetFileChildren(const GetFileChildren& from);

  inline GetFileChildren& operator=(const GetFileChildren& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileChildren& default_instance();

  void Swap(GetFileChildren* other);

  // implements Message ----------------------------------------------

  GetFileChildren* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileChildren& from);
  void MergeFrom(const GetFileChildren& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dir_logic_name = 1;
  inline bool has_dir_logic_name() const;
  inline void clear_dir_logic_name();
  static const int kDirLogicNameFieldNumber = 1;
  inline const ::std::string& dir_logic_name() const;
  inline void set_dir_logic_name(const ::std::string& value);
  inline void set_dir_logic_name(const char* value);
  inline void set_dir_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_dir_logic_name();
  inline ::std::string* release_dir_logic_name();
  inline void set_allocated_dir_logic_name(::std::string* dir_logic_name);

  // required int32 children_num = 2;
  inline bool has_children_num() const;
  inline void clear_children_num();
  static const int kChildrenNumFieldNumber = 2;
  inline ::google::protobuf::int32 children_num() const;
  inline void set_children_num(::google::protobuf::int32 value);

  // optional int32 offset = 3 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetFileChildren)
 private:
  inline void set_has_dir_logic_name();
  inline void clear_has_dir_logic_name();
  inline void set_has_children_num();
  inline void clear_has_children_num();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dir_logic_name_;
  ::google::protobuf::int32 children_num_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetFileChildren* default_instance_;
};
// -------------------------------------------------------------------

class FileChildren : public ::google::protobuf::Message {
 public:
  FileChildren();
  virtual ~FileChildren();

  FileChildren(const FileChildren& from);

  inline FileChildren& operator=(const FileChildren& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileChildren& default_instance();

  void Swap(FileChildren* other);

  // implements Message ----------------------------------------------

  FileChildren* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileChildren& from);
  void MergeFrom(const FileChildren& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // repeated string child_logic_name = 2;
  inline int child_logic_name_size() const;
  inline void clear_child_logic_name();
  static const int kChildLogicNameFieldNumber = 2;
  inline const ::std::string& child_logic_name(int index) const;
  inline ::std::string* mutable_child_logic_name(int index);
  inline void set_child_logic_name(int index, const ::std::string& value);
  inline void set_child_logic_name(int index, const char* value);
  inline void set_child_logic_name(int index, const char* value, size_t size);
  inline ::std::string* add_child_logic_name();
  inline void add_child_logic_name(const ::std::string& value);
  inline void add_child_logic_name(const char* value);
  inline void add_child_logic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& child_logic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_child_logic_name();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.FileChildren)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::google::protobuf::RepeatedPtrField< ::std::string> child_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static FileChildren* default_instance_;
};
// -------------------------------------------------------------------

class CreateDir : public ::google::protobuf::Message {
 public:
  CreateDir();
  virtual ~CreateDir();

  CreateDir(const CreateDir& from);

  inline CreateDir& operator=(const CreateDir& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDir& default_instance();

  void Swap(CreateDir* other);

  // implements Message ----------------------------------------------

  CreateDir* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateDir& from);
  void MergeFrom(const CreateDir& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dir_logic_name = 1;
  inline bool has_dir_logic_name() const;
  inline void clear_dir_logic_name();
  static const int kDirLogicNameFieldNumber = 1;
  inline const ::std::string& dir_logic_name() const;
  inline void set_dir_logic_name(const ::std::string& value);
  inline void set_dir_logic_name(const char* value);
  inline void set_dir_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_dir_logic_name();
  inline ::std::string* release_dir_logic_name();
  inline void set_allocated_dir_logic_name(::std::string* dir_logic_name);

  // required uint32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.CreateDir)
 private:
  inline void set_has_dir_logic_name();
  inline void clear_has_dir_logic_name();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dir_logic_name_;
  ::google::protobuf::uint32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static CreateDir* default_instance_;
};
// -------------------------------------------------------------------

class DeleteFile : public ::google::protobuf::Message {
 public:
  DeleteFile();
  virtual ~DeleteFile();

  DeleteFile(const DeleteFile& from);

  inline DeleteFile& operator=(const DeleteFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteFile& default_instance();

  void Swap(DeleteFile* other);

  // implements Message ----------------------------------------------

  DeleteFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteFile& from);
  void MergeFrom(const DeleteFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.DeleteFile)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static DeleteFile* default_instance_;
};
// -------------------------------------------------------------------

class CreateLink : public ::google::protobuf::Message {
 public:
  CreateLink();
  virtual ~CreateLink();

  CreateLink(const CreateLink& from);

  inline CreateLink& operator=(const CreateLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateLink& default_instance();

  void Swap(CreateLink* other);

  // implements Message ----------------------------------------------

  CreateLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateLink& from);
  void MergeFrom(const CreateLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from_file_logic_name = 1;
  inline bool has_from_file_logic_name() const;
  inline void clear_from_file_logic_name();
  static const int kFromFileLogicNameFieldNumber = 1;
  inline const ::std::string& from_file_logic_name() const;
  inline void set_from_file_logic_name(const ::std::string& value);
  inline void set_from_file_logic_name(const char* value);
  inline void set_from_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_from_file_logic_name();
  inline ::std::string* release_from_file_logic_name();
  inline void set_allocated_from_file_logic_name(::std::string* from_file_logic_name);

  // required string to_file_logic_name = 2;
  inline bool has_to_file_logic_name() const;
  inline void clear_to_file_logic_name();
  static const int kToFileLogicNameFieldNumber = 2;
  inline const ::std::string& to_file_logic_name() const;
  inline void set_to_file_logic_name(const ::std::string& value);
  inline void set_to_file_logic_name(const char* value);
  inline void set_to_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_to_file_logic_name();
  inline ::std::string* release_to_file_logic_name();
  inline void set_allocated_to_file_logic_name(::std::string* to_file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.CreateLink)
 private:
  inline void set_has_from_file_logic_name();
  inline void clear_has_from_file_logic_name();
  inline void set_has_to_file_logic_name();
  inline void clear_has_to_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_file_logic_name_;
  ::std::string* to_file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static CreateLink* default_instance_;
};
// -------------------------------------------------------------------

class GetLink : public ::google::protobuf::Message {
 public:
  GetLink();
  virtual ~GetLink();

  GetLink(const GetLink& from);

  inline GetLink& operator=(const GetLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLink& default_instance();

  void Swap(GetLink* other);

  // implements Message ----------------------------------------------

  GetLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLink& from);
  void MergeFrom(const GetLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetLink)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetLink* default_instance_;
};
// -------------------------------------------------------------------

class LinkInfo : public ::google::protobuf::Message {
 public:
  LinkInfo();
  virtual ~LinkInfo();

  LinkInfo(const LinkInfo& from);

  inline LinkInfo& operator=(const LinkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkInfo& default_instance();

  void Swap(LinkInfo* other);

  // implements Message ----------------------------------------------

  LinkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinkInfo& from);
  void MergeFrom(const LinkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // required string file_logic_name = 2;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 2;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.LinkInfo)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::std::string* file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static LinkInfo* default_instance_;
};
// -------------------------------------------------------------------

class RenameFile : public ::google::protobuf::Message {
 public:
  RenameFile();
  virtual ~RenameFile();

  RenameFile(const RenameFile& from);

  inline RenameFile& operator=(const RenameFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameFile& default_instance();

  void Swap(RenameFile* other);

  // implements Message ----------------------------------------------

  RenameFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenameFile& from);
  void MergeFrom(const RenameFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from_file_logic_name = 1;
  inline bool has_from_file_logic_name() const;
  inline void clear_from_file_logic_name();
  static const int kFromFileLogicNameFieldNumber = 1;
  inline const ::std::string& from_file_logic_name() const;
  inline void set_from_file_logic_name(const ::std::string& value);
  inline void set_from_file_logic_name(const char* value);
  inline void set_from_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_from_file_logic_name();
  inline ::std::string* release_from_file_logic_name();
  inline void set_allocated_from_file_logic_name(::std::string* from_file_logic_name);

  // required string to_file_logic_name = 2;
  inline bool has_to_file_logic_name() const;
  inline void clear_to_file_logic_name();
  static const int kToFileLogicNameFieldNumber = 2;
  inline const ::std::string& to_file_logic_name() const;
  inline void set_to_file_logic_name(const ::std::string& value);
  inline void set_to_file_logic_name(const char* value);
  inline void set_to_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_to_file_logic_name();
  inline ::std::string* release_to_file_logic_name();
  inline void set_allocated_to_file_logic_name(::std::string* to_file_logic_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.RenameFile)
 private:
  inline void set_has_from_file_logic_name();
  inline void clear_has_from_file_logic_name();
  inline void set_has_to_file_logic_name();
  inline void clear_has_to_file_logic_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_file_logic_name_;
  ::std::string* to_file_logic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static RenameFile* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFileOwner : public ::google::protobuf::Message {
 public:
  ChangeFileOwner();
  virtual ~ChangeFileOwner();

  ChangeFileOwner(const ChangeFileOwner& from);

  inline ChangeFileOwner& operator=(const ChangeFileOwner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFileOwner& default_instance();

  void Swap(ChangeFileOwner* other);

  // implements Message ----------------------------------------------

  ChangeFileOwner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFileOwner& from);
  void MergeFrom(const ChangeFileOwner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // required int32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional string uname = 4 [default = ""];
  inline bool has_uname() const;
  inline void clear_uname();
  static const int kUnameFieldNumber = 4;
  inline const ::std::string& uname() const;
  inline void set_uname(const ::std::string& value);
  inline void set_uname(const char* value);
  inline void set_uname(const char* value, size_t size);
  inline ::std::string* mutable_uname();
  inline ::std::string* release_uname();
  inline void set_allocated_uname(::std::string* uname);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ChangeFileOwner)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_uname();
  inline void clear_has_uname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::std::string* uname_;
  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ChangeFileOwner* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFileGroup : public ::google::protobuf::Message {
 public:
  ChangeFileGroup();
  virtual ~ChangeFileGroup();

  ChangeFileGroup(const ChangeFileGroup& from);

  inline ChangeFileGroup& operator=(const ChangeFileGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFileGroup& default_instance();

  void Swap(ChangeFileGroup* other);

  // implements Message ----------------------------------------------

  ChangeFileGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFileGroup& from);
  void MergeFrom(const ChangeFileGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // required int32 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::int32 gid() const;
  inline void set_gid(::google::protobuf::int32 value);

  // optional string gname = 5 [default = ""];
  inline bool has_gname() const;
  inline void clear_gname();
  static const int kGnameFieldNumber = 5;
  inline const ::std::string& gname() const;
  inline void set_gname(const ::std::string& value);
  inline void set_gname(const char* value);
  inline void set_gname(const char* value, size_t size);
  inline ::std::string* mutable_gname();
  inline ::std::string* release_gname();
  inline void set_allocated_gname(::std::string* gname);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ChangeFileGroup)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_gname();
  inline void clear_has_gname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::std::string* gname_;
  ::google::protobuf::int32 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ChangeFileGroup* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFilePerms : public ::google::protobuf::Message {
 public:
  ChangeFilePerms();
  virtual ~ChangeFilePerms();

  ChangeFilePerms(const ChangeFilePerms& from);

  inline ChangeFilePerms& operator=(const ChangeFilePerms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFilePerms& default_instance();

  void Swap(ChangeFilePerms* other);

  // implements Message ----------------------------------------------

  ChangeFilePerms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFilePerms& from);
  void MergeFrom(const ChangeFilePerms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // required int32 perms = 2;
  inline bool has_perms() const;
  inline void clear_perms();
  static const int kPermsFieldNumber = 2;
  inline ::google::protobuf::int32 perms() const;
  inline void set_perms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ChangeFilePerms)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_perms();
  inline void clear_has_perms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::google::protobuf::int32 perms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ChangeFilePerms* default_instance_;
};
// -------------------------------------------------------------------

class CheckFilePerms : public ::google::protobuf::Message {
 public:
  CheckFilePerms();
  virtual ~CheckFilePerms();

  CheckFilePerms(const CheckFilePerms& from);

  inline CheckFilePerms& operator=(const CheckFilePerms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckFilePerms& default_instance();

  void Swap(CheckFilePerms* other);

  // implements Message ----------------------------------------------

  CheckFilePerms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckFilePerms& from);
  void MergeFrom(const CheckFilePerms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // required string type = 2 [default = "root"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.CheckFilePerms)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::std::string* type_;
  static ::std::string* _default_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static CheckFilePerms* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTimes : public ::google::protobuf::Message {
 public:
  UpdateTimes();
  virtual ~UpdateTimes();

  UpdateTimes(const UpdateTimes& from);

  inline UpdateTimes& operator=(const UpdateTimes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTimes& default_instance();

  void Swap(UpdateTimes* other);

  // implements Message ----------------------------------------------

  UpdateTimes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTimes& from);
  void MergeFrom(const UpdateTimes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_logic_name = 1;
  inline bool has_file_logic_name() const;
  inline void clear_file_logic_name();
  static const int kFileLogicNameFieldNumber = 1;
  inline const ::std::string& file_logic_name() const;
  inline void set_file_logic_name(const ::std::string& value);
  inline void set_file_logic_name(const char* value);
  inline void set_file_logic_name(const char* value, size_t size);
  inline ::std::string* mutable_file_logic_name();
  inline ::std::string* release_file_logic_name();
  inline void set_allocated_file_logic_name(::std::string* file_logic_name);

  // optional int64 atime = 2 [default = -1];
  inline bool has_atime() const;
  inline void clear_atime();
  static const int kAtimeFieldNumber = 2;
  inline ::google::protobuf::int64 atime() const;
  inline void set_atime(::google::protobuf::int64 value);

  // optional int64 mtime = 3 [default = -1];
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 3;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);

  // optional int64 ctime = 4 [default = -1];
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 4;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.UpdateTimes)
 private:
  inline void set_has_file_logic_name();
  inline void clear_has_file_logic_name();
  inline void set_has_atime();
  inline void clear_has_atime();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_ctime();
  inline void clear_has_ctime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_logic_name_;
  ::google::protobuf::int64 atime_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int64 ctime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateTimes* default_instance_;
};
// -------------------------------------------------------------------

class TestChannel : public ::google::protobuf::Message {
 public:
  TestChannel();
  virtual ~TestChannel();

  TestChannel(const TestChannel& from);

  inline TestChannel& operator=(const TestChannel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestChannel& default_instance();

  void Swap(TestChannel* other);

  // implements Message ----------------------------------------------

  TestChannel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestChannel& from);
  void MergeFrom(const TestChannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string answer_message = 1;
  inline bool has_answer_message() const;
  inline void clear_answer_message();
  static const int kAnswerMessageFieldNumber = 1;
  inline const ::std::string& answer_message() const;
  inline void set_answer_message(const ::std::string& value);
  inline void set_answer_message(const char* value);
  inline void set_answer_message(const char* value, size_t size);
  inline ::std::string* mutable_answer_message();
  inline ::std::string* release_answer_message();
  inline void set_allocated_answer_message(::std::string* answer_message);

  // required int32 answer_delay_in_ms = 2;
  inline bool has_answer_delay_in_ms() const;
  inline void clear_answer_delay_in_ms();
  static const int kAnswerDelayInMsFieldNumber = 2;
  inline ::google::protobuf::int32 answer_delay_in_ms() const;
  inline void set_answer_delay_in_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.TestChannel)
 private:
  inline void set_has_answer_message();
  inline void clear_has_answer_message();
  inline void set_has_answer_delay_in_ms();
  inline void clear_has_answer_delay_in_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_message_;
  ::google::protobuf::int32 answer_delay_in_ms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TestChannel* default_instance_;
};
// -------------------------------------------------------------------

class TestChannelAnswer : public ::google::protobuf::Message {
 public:
  TestChannelAnswer();
  virtual ~TestChannelAnswer();

  TestChannelAnswer(const TestChannelAnswer& from);

  inline TestChannelAnswer& operator=(const TestChannelAnswer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestChannelAnswer& default_instance();

  void Swap(TestChannelAnswer* other);

  // implements Message ----------------------------------------------

  TestChannelAnswer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestChannelAnswer& from);
  void MergeFrom(const TestChannelAnswer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.TestChannelAnswer)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TestChannelAnswer* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeRequest_EnvVariable : public ::google::protobuf::Message {
 public:
  HandshakeRequest_EnvVariable();
  virtual ~HandshakeRequest_EnvVariable();

  HandshakeRequest_EnvVariable(const HandshakeRequest_EnvVariable& from);

  inline HandshakeRequest_EnvVariable& operator=(const HandshakeRequest_EnvVariable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeRequest_EnvVariable& default_instance();

  void Swap(HandshakeRequest_EnvVariable* other);

  // implements Message ----------------------------------------------

  HandshakeRequest_EnvVariable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeRequest_EnvVariable& from);
  void MergeFrom(const HandshakeRequest_EnvVariable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.HandshakeRequest.EnvVariable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static HandshakeRequest_EnvVariable* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeRequest_CertConfirmation : public ::google::protobuf::Message {
 public:
  HandshakeRequest_CertConfirmation();
  virtual ~HandshakeRequest_CertConfirmation();

  HandshakeRequest_CertConfirmation(const HandshakeRequest_CertConfirmation& from);

  inline HandshakeRequest_CertConfirmation& operator=(const HandshakeRequest_CertConfirmation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeRequest_CertConfirmation& default_instance();

  void Swap(HandshakeRequest_CertConfirmation* other);

  // implements Message ----------------------------------------------

  HandshakeRequest_CertConfirmation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeRequest_CertConfirmation& from);
  void MergeFrom(const HandshakeRequest_CertConfirmation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // required bool result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline bool result() const;
  inline void set_result(bool value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.HandshakeRequest.CertConfirmation)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* login_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static HandshakeRequest_CertConfirmation* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeRequest : public ::google::protobuf::Message {
 public:
  HandshakeRequest();
  virtual ~HandshakeRequest();

  HandshakeRequest(const HandshakeRequest& from);

  inline HandshakeRequest& operator=(const HandshakeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeRequest& default_instance();

  void Swap(HandshakeRequest* other);

  // implements Message ----------------------------------------------

  HandshakeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeRequest& from);
  void MergeFrom(const HandshakeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HandshakeRequest_EnvVariable EnvVariable;
  typedef HandshakeRequest_CertConfirmation CertConfirmation;

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // repeated .veil.protocol.fuse_messages.HandshakeRequest.EnvVariable variable = 2;
  inline int variable_size() const;
  inline void clear_variable();
  static const int kVariableFieldNumber = 2;
  inline const ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable& variable(int index) const;
  inline ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable* mutable_variable(int index);
  inline ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable* add_variable();
  inline const ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable >&
      variable() const;
  inline ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable >*
      mutable_variable();

  // optional .veil.protocol.fuse_messages.HandshakeRequest.CertConfirmation cert_confirmation = 3;
  inline bool has_cert_confirmation() const;
  inline void clear_cert_confirmation();
  static const int kCertConfirmationFieldNumber = 3;
  inline const ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation& cert_confirmation() const;
  inline ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* mutable_cert_confirmation();
  inline ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* release_cert_confirmation();
  inline void set_allocated_cert_confirmation(::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* cert_confirmation);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.HandshakeRequest)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_cert_confirmation();
  inline void clear_has_cert_confirmation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable > variable_;
  ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* cert_confirmation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static HandshakeRequest* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeResponse : public ::google::protobuf::Message {
 public:
  HandshakeResponse();
  virtual ~HandshakeResponse();

  HandshakeResponse(const HandshakeResponse& from);

  inline HandshakeResponse& operator=(const HandshakeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeResponse& default_instance();

  void Swap(HandshakeResponse* other);

  // implements Message ----------------------------------------------

  HandshakeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeResponse& from);
  void MergeFrom(const HandshakeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fuse_id = 1;
  inline bool has_fuse_id() const;
  inline void clear_fuse_id();
  static const int kFuseIdFieldNumber = 1;
  inline const ::std::string& fuse_id() const;
  inline void set_fuse_id(const ::std::string& value);
  inline void set_fuse_id(const char* value);
  inline void set_fuse_id(const char* value, size_t size);
  inline ::std::string* mutable_fuse_id();
  inline ::std::string* release_fuse_id();
  inline void set_allocated_fuse_id(::std::string* fuse_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.HandshakeResponse)
 private:
  inline void set_has_fuse_id();
  inline void clear_has_fuse_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fuse_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static HandshakeResponse* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeAck : public ::google::protobuf::Message {
 public:
  HandshakeAck();
  virtual ~HandshakeAck();

  HandshakeAck(const HandshakeAck& from);

  inline HandshakeAck& operator=(const HandshakeAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeAck& default_instance();

  void Swap(HandshakeAck* other);

  // implements Message ----------------------------------------------

  HandshakeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeAck& from);
  void MergeFrom(const HandshakeAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fuse_id = 1;
  inline bool has_fuse_id() const;
  inline void clear_fuse_id();
  static const int kFuseIdFieldNumber = 1;
  inline const ::std::string& fuse_id() const;
  inline void set_fuse_id(const ::std::string& value);
  inline void set_fuse_id(const char* value);
  inline void set_fuse_id(const char* value, size_t size);
  inline ::std::string* mutable_fuse_id();
  inline ::std::string* release_fuse_id();
  inline void set_allocated_fuse_id(::std::string* fuse_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.HandshakeAck)
 private:
  inline void set_has_fuse_id();
  inline void clear_has_fuse_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fuse_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static HandshakeAck* default_instance_;
};
// -------------------------------------------------------------------

class CreateStorageTestFileRequest : public ::google::protobuf::Message {
 public:
  CreateStorageTestFileRequest();
  virtual ~CreateStorageTestFileRequest();

  CreateStorageTestFileRequest(const CreateStorageTestFileRequest& from);

  inline CreateStorageTestFileRequest& operator=(const CreateStorageTestFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateStorageTestFileRequest& default_instance();

  void Swap(CreateStorageTestFileRequest* other);

  // implements Message ----------------------------------------------

  CreateStorageTestFileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateStorageTestFileRequest& from);
  void MergeFrom(const CreateStorageTestFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storage_id = 1;
  inline bool has_storage_id() const;
  inline void clear_storage_id();
  static const int kStorageIdFieldNumber = 1;
  inline ::google::protobuf::int32 storage_id() const;
  inline void set_storage_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.CreateStorageTestFileRequest)
 private:
  inline void set_has_storage_id();
  inline void clear_has_storage_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 storage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static CreateStorageTestFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateStorageTestFileResponse : public ::google::protobuf::Message {
 public:
  CreateStorageTestFileResponse();
  virtual ~CreateStorageTestFileResponse();

  CreateStorageTestFileResponse(const CreateStorageTestFileResponse& from);

  inline CreateStorageTestFileResponse& operator=(const CreateStorageTestFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateStorageTestFileResponse& default_instance();

  void Swap(CreateStorageTestFileResponse* other);

  // implements Message ----------------------------------------------

  CreateStorageTestFileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateStorageTestFileResponse& from);
  void MergeFrom(const CreateStorageTestFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool answer = 1;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline bool answer() const;
  inline void set_answer(bool value);

  // optional string relative_path = 2 [default = ""];
  inline bool has_relative_path() const;
  inline void clear_relative_path();
  static const int kRelativePathFieldNumber = 2;
  inline const ::std::string& relative_path() const;
  inline void set_relative_path(const ::std::string& value);
  inline void set_relative_path(const char* value);
  inline void set_relative_path(const char* value, size_t size);
  inline ::std::string* mutable_relative_path();
  inline ::std::string* release_relative_path();
  inline void set_allocated_relative_path(::std::string* relative_path);

  // optional string text = 3 [default = ""];
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.CreateStorageTestFileResponse)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_relative_path();
  inline void clear_has_relative_path();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* relative_path_;
  ::std::string* text_;
  bool answer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static CreateStorageTestFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class StorageTestFileModifiedRequest : public ::google::protobuf::Message {
 public:
  StorageTestFileModifiedRequest();
  virtual ~StorageTestFileModifiedRequest();

  StorageTestFileModifiedRequest(const StorageTestFileModifiedRequest& from);

  inline StorageTestFileModifiedRequest& operator=(const StorageTestFileModifiedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageTestFileModifiedRequest& default_instance();

  void Swap(StorageTestFileModifiedRequest* other);

  // implements Message ----------------------------------------------

  StorageTestFileModifiedRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageTestFileModifiedRequest& from);
  void MergeFrom(const StorageTestFileModifiedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storage_id = 1;
  inline bool has_storage_id() const;
  inline void clear_storage_id();
  static const int kStorageIdFieldNumber = 1;
  inline ::google::protobuf::int32 storage_id() const;
  inline void set_storage_id(::google::protobuf::int32 value);

  // required string relative_path = 2;
  inline bool has_relative_path() const;
  inline void clear_relative_path();
  static const int kRelativePathFieldNumber = 2;
  inline const ::std::string& relative_path() const;
  inline void set_relative_path(const ::std::string& value);
  inline void set_relative_path(const char* value);
  inline void set_relative_path(const char* value, size_t size);
  inline ::std::string* mutable_relative_path();
  inline ::std::string* release_relative_path();
  inline void set_allocated_relative_path(::std::string* relative_path);

  // required string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.StorageTestFileModifiedRequest)
 private:
  inline void set_has_storage_id();
  inline void clear_has_storage_id();
  inline void set_has_relative_path();
  inline void clear_has_relative_path();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* relative_path_;
  ::std::string* text_;
  ::google::protobuf::int32 storage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static StorageTestFileModifiedRequest* default_instance_;
};
// -------------------------------------------------------------------

class StorageTestFileModifiedResponse : public ::google::protobuf::Message {
 public:
  StorageTestFileModifiedResponse();
  virtual ~StorageTestFileModifiedResponse();

  StorageTestFileModifiedResponse(const StorageTestFileModifiedResponse& from);

  inline StorageTestFileModifiedResponse& operator=(const StorageTestFileModifiedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageTestFileModifiedResponse& default_instance();

  void Swap(StorageTestFileModifiedResponse* other);

  // implements Message ----------------------------------------------

  StorageTestFileModifiedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageTestFileModifiedResponse& from);
  void MergeFrom(const StorageTestFileModifiedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool answer = 1;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline bool answer() const;
  inline void set_answer(bool value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.StorageTestFileModifiedResponse)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool answer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static StorageTestFileModifiedResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientStorageInfo_StorageInfo : public ::google::protobuf::Message {
 public:
  ClientStorageInfo_StorageInfo();
  virtual ~ClientStorageInfo_StorageInfo();

  ClientStorageInfo_StorageInfo(const ClientStorageInfo_StorageInfo& from);

  inline ClientStorageInfo_StorageInfo& operator=(const ClientStorageInfo_StorageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStorageInfo_StorageInfo& default_instance();

  void Swap(ClientStorageInfo_StorageInfo* other);

  // implements Message ----------------------------------------------

  ClientStorageInfo_StorageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStorageInfo_StorageInfo& from);
  void MergeFrom(const ClientStorageInfo_StorageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storage_id = 1;
  inline bool has_storage_id() const;
  inline void clear_storage_id();
  static const int kStorageIdFieldNumber = 1;
  inline ::google::protobuf::int32 storage_id() const;
  inline void set_storage_id(::google::protobuf::int32 value);

  // required string absolute_path = 2;
  inline bool has_absolute_path() const;
  inline void clear_absolute_path();
  static const int kAbsolutePathFieldNumber = 2;
  inline const ::std::string& absolute_path() const;
  inline void set_absolute_path(const ::std::string& value);
  inline void set_absolute_path(const char* value);
  inline void set_absolute_path(const char* value, size_t size);
  inline ::std::string* mutable_absolute_path();
  inline ::std::string* release_absolute_path();
  inline void set_allocated_absolute_path(::std::string* absolute_path);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ClientStorageInfo.StorageInfo)
 private:
  inline void set_has_storage_id();
  inline void clear_has_storage_id();
  inline void set_has_absolute_path();
  inline void clear_has_absolute_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* absolute_path_;
  ::google::protobuf::int32 storage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ClientStorageInfo_StorageInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientStorageInfo : public ::google::protobuf::Message {
 public:
  ClientStorageInfo();
  virtual ~ClientStorageInfo();

  ClientStorageInfo(const ClientStorageInfo& from);

  inline ClientStorageInfo& operator=(const ClientStorageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStorageInfo& default_instance();

  void Swap(ClientStorageInfo* other);

  // implements Message ----------------------------------------------

  ClientStorageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStorageInfo& from);
  void MergeFrom(const ClientStorageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientStorageInfo_StorageInfo StorageInfo;

  // accessors -------------------------------------------------------

  // repeated .veil.protocol.fuse_messages.ClientStorageInfo.StorageInfo storage_info = 1;
  inline int storage_info_size() const;
  inline void clear_storage_info();
  static const int kStorageInfoFieldNumber = 1;
  inline const ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo& storage_info(int index) const;
  inline ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo* mutable_storage_info(int index);
  inline ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo* add_storage_info();
  inline const ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo >&
      storage_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo >*
      mutable_storage_info();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.ClientStorageInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo > storage_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ClientStorageInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetStatFS : public ::google::protobuf::Message {
 public:
  GetStatFS();
  virtual ~GetStatFS();

  GetStatFS(const GetStatFS& from);

  inline GetStatFS& operator=(const GetStatFS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStatFS& default_instance();

  void Swap(GetStatFS* other);

  // implements Message ----------------------------------------------

  GetStatFS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStatFS& from);
  void MergeFrom(const GetStatFS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.GetStatFS)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetStatFS* default_instance_;
};
// -------------------------------------------------------------------

class StatFSInfo : public ::google::protobuf::Message {
 public:
  StatFSInfo();
  virtual ~StatFSInfo();

  StatFSInfo(const StatFSInfo& from);

  inline StatFSInfo& operator=(const StatFSInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatFSInfo& default_instance();

  void Swap(StatFSInfo* other);

  // implements Message ----------------------------------------------

  StatFSInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatFSInfo& from);
  void MergeFrom(const StatFSInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // required int64 quota_size = 2;
  inline bool has_quota_size() const;
  inline void clear_quota_size();
  static const int kQuotaSizeFieldNumber = 2;
  inline ::google::protobuf::int64 quota_size() const;
  inline void set_quota_size(::google::protobuf::int64 value);

  // required int64 files_size = 3;
  inline bool has_files_size() const;
  inline void clear_files_size();
  static const int kFilesSizeFieldNumber = 3;
  inline ::google::protobuf::int64 files_size() const;
  inline void set_files_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.StatFSInfo)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_quota_size();
  inline void clear_has_quota_size();
  inline void set_has_files_size();
  inline void clear_has_files_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::google::protobuf::int64 quota_size_;
  ::google::protobuf::int64 files_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static StatFSInfo* default_instance_;
};
// -------------------------------------------------------------------

class EventFilterConfig : public ::google::protobuf::Message {
 public:
  EventFilterConfig();
  virtual ~EventFilterConfig();

  EventFilterConfig(const EventFilterConfig& from);

  inline EventFilterConfig& operator=(const EventFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventFilterConfig& default_instance();

  void Swap(EventFilterConfig* other);

  // implements Message ----------------------------------------------

  EventFilterConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventFilterConfig& from);
  void MergeFrom(const EventFilterConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string field_name = 1;
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // required string desired_value = 2;
  inline bool has_desired_value() const;
  inline void clear_desired_value();
  static const int kDesiredValueFieldNumber = 2;
  inline const ::std::string& desired_value() const;
  inline void set_desired_value(const ::std::string& value);
  inline void set_desired_value(const char* value);
  inline void set_desired_value(const char* value, size_t size);
  inline ::std::string* mutable_desired_value();
  inline ::std::string* release_desired_value();
  inline void set_allocated_desired_value(::std::string* desired_value);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.EventFilterConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_desired_value();
  inline void clear_has_desired_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  ::std::string* desired_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static EventFilterConfig* default_instance_;
};
// -------------------------------------------------------------------

class EventAggregatorConfig : public ::google::protobuf::Message {
 public:
  EventAggregatorConfig();
  virtual ~EventAggregatorConfig();

  EventAggregatorConfig(const EventAggregatorConfig& from);

  inline EventAggregatorConfig& operator=(const EventAggregatorConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventAggregatorConfig& default_instance();

  void Swap(EventAggregatorConfig* other);

  // implements Message ----------------------------------------------

  EventAggregatorConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventAggregatorConfig& from);
  void MergeFrom(const EventAggregatorConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string field_name = 1;
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // required uint64 threshold = 2;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  inline ::google::protobuf::uint64 threshold() const;
  inline void set_threshold(::google::protobuf::uint64 value);

  // required string sum_field_name = 3;
  inline bool has_sum_field_name() const;
  inline void clear_sum_field_name();
  static const int kSumFieldNameFieldNumber = 3;
  inline const ::std::string& sum_field_name() const;
  inline void set_sum_field_name(const ::std::string& value);
  inline void set_sum_field_name(const char* value);
  inline void set_sum_field_name(const char* value, size_t size);
  inline ::std::string* mutable_sum_field_name();
  inline ::std::string* release_sum_field_name();
  inline void set_allocated_sum_field_name(::std::string* sum_field_name);

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.EventAggregatorConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_threshold();
  inline void clear_has_threshold();
  inline void set_has_sum_field_name();
  inline void clear_has_sum_field_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  ::google::protobuf::uint64 threshold_;
  ::std::string* sum_field_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static EventAggregatorConfig* default_instance_;
};
// -------------------------------------------------------------------

class EventTransformerConfig : public ::google::protobuf::Message {
 public:
  EventTransformerConfig();
  virtual ~EventTransformerConfig();

  EventTransformerConfig(const EventTransformerConfig& from);

  inline EventTransformerConfig& operator=(const EventTransformerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventTransformerConfig& default_instance();

  void Swap(EventTransformerConfig* other);

  // implements Message ----------------------------------------------

  EventTransformerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventTransformerConfig& from);
  void MergeFrom(const EventTransformerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_names_to_replace = 1;
  inline int field_names_to_replace_size() const;
  inline void clear_field_names_to_replace();
  static const int kFieldNamesToReplaceFieldNumber = 1;
  inline const ::std::string& field_names_to_replace(int index) const;
  inline ::std::string* mutable_field_names_to_replace(int index);
  inline void set_field_names_to_replace(int index, const ::std::string& value);
  inline void set_field_names_to_replace(int index, const char* value);
  inline void set_field_names_to_replace(int index, const char* value, size_t size);
  inline ::std::string* add_field_names_to_replace();
  inline void add_field_names_to_replace(const ::std::string& value);
  inline void add_field_names_to_replace(const char* value);
  inline void add_field_names_to_replace(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_names_to_replace() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_names_to_replace();

  // repeated string values_to_replace = 2;
  inline int values_to_replace_size() const;
  inline void clear_values_to_replace();
  static const int kValuesToReplaceFieldNumber = 2;
  inline const ::std::string& values_to_replace(int index) const;
  inline ::std::string* mutable_values_to_replace(int index);
  inline void set_values_to_replace(int index, const ::std::string& value);
  inline void set_values_to_replace(int index, const char* value);
  inline void set_values_to_replace(int index, const char* value, size_t size);
  inline ::std::string* add_values_to_replace();
  inline void add_values_to_replace(const ::std::string& value);
  inline void add_values_to_replace(const char* value);
  inline void add_values_to_replace(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values_to_replace() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values_to_replace();

  // repeated string new_values = 3;
  inline int new_values_size() const;
  inline void clear_new_values();
  static const int kNewValuesFieldNumber = 3;
  inline const ::std::string& new_values(int index) const;
  inline ::std::string* mutable_new_values(int index);
  inline void set_new_values(int index, const ::std::string& value);
  inline void set_new_values(int index, const char* value);
  inline void set_new_values(int index, const char* value, size_t size);
  inline ::std::string* add_new_values();
  inline void add_new_values(const ::std::string& value);
  inline void add_new_values(const char* value);
  inline void add_new_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& new_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_new_values();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.EventTransformerConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> field_names_to_replace_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_to_replace_;
  ::google::protobuf::RepeatedPtrField< ::std::string> new_values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static EventTransformerConfig* default_instance_;
};
// -------------------------------------------------------------------

class EventStreamConfig : public ::google::protobuf::Message {
 public:
  EventStreamConfig();
  virtual ~EventStreamConfig();

  EventStreamConfig(const EventStreamConfig& from);

  inline EventStreamConfig& operator=(const EventStreamConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventStreamConfig& default_instance();

  void Swap(EventStreamConfig* other);

  // implements Message ----------------------------------------------

  EventStreamConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventStreamConfig& from);
  void MergeFrom(const EventStreamConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .veil.protocol.fuse_messages.EventStreamConfig wrapped_config = 1;
  inline bool has_wrapped_config() const;
  inline void clear_wrapped_config();
  static const int kWrappedConfigFieldNumber = 1;
  inline const ::veil::protocol::fuse_messages::EventStreamConfig& wrapped_config() const;
  inline ::veil::protocol::fuse_messages::EventStreamConfig* mutable_wrapped_config();
  inline ::veil::protocol::fuse_messages::EventStreamConfig* release_wrapped_config();
  inline void set_allocated_wrapped_config(::veil::protocol::fuse_messages::EventStreamConfig* wrapped_config);

  // optional .veil.protocol.fuse_messages.EventFilterConfig filter_config = 2;
  inline bool has_filter_config() const;
  inline void clear_filter_config();
  static const int kFilterConfigFieldNumber = 2;
  inline const ::veil::protocol::fuse_messages::EventFilterConfig& filter_config() const;
  inline ::veil::protocol::fuse_messages::EventFilterConfig* mutable_filter_config();
  inline ::veil::protocol::fuse_messages::EventFilterConfig* release_filter_config();
  inline void set_allocated_filter_config(::veil::protocol::fuse_messages::EventFilterConfig* filter_config);

  // optional .veil.protocol.fuse_messages.EventAggregatorConfig aggregator_config = 3;
  inline bool has_aggregator_config() const;
  inline void clear_aggregator_config();
  static const int kAggregatorConfigFieldNumber = 3;
  inline const ::veil::protocol::fuse_messages::EventAggregatorConfig& aggregator_config() const;
  inline ::veil::protocol::fuse_messages::EventAggregatorConfig* mutable_aggregator_config();
  inline ::veil::protocol::fuse_messages::EventAggregatorConfig* release_aggregator_config();
  inline void set_allocated_aggregator_config(::veil::protocol::fuse_messages::EventAggregatorConfig* aggregator_config);

  // optional .veil.protocol.fuse_messages.EventTransformerConfig transformer_config = 4;
  inline bool has_transformer_config() const;
  inline void clear_transformer_config();
  static const int kTransformerConfigFieldNumber = 4;
  inline const ::veil::protocol::fuse_messages::EventTransformerConfig& transformer_config() const;
  inline ::veil::protocol::fuse_messages::EventTransformerConfig* mutable_transformer_config();
  inline ::veil::protocol::fuse_messages::EventTransformerConfig* release_transformer_config();
  inline void set_allocated_transformer_config(::veil::protocol::fuse_messages::EventTransformerConfig* transformer_config);

  // repeated string needed_envs = 5;
  inline int needed_envs_size() const;
  inline void clear_needed_envs();
  static const int kNeededEnvsFieldNumber = 5;
  inline const ::std::string& needed_envs(int index) const;
  inline ::std::string* mutable_needed_envs(int index);
  inline void set_needed_envs(int index, const ::std::string& value);
  inline void set_needed_envs(int index, const char* value);
  inline void set_needed_envs(int index, const char* value, size_t size);
  inline ::std::string* add_needed_envs();
  inline void add_needed_envs(const ::std::string& value);
  inline void add_needed_envs(const char* value);
  inline void add_needed_envs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& needed_envs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_needed_envs();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.EventStreamConfig)
 private:
  inline void set_has_wrapped_config();
  inline void clear_has_wrapped_config();
  inline void set_has_filter_config();
  inline void clear_has_filter_config();
  inline void set_has_aggregator_config();
  inline void clear_has_aggregator_config();
  inline void set_has_transformer_config();
  inline void clear_has_transformer_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::veil::protocol::fuse_messages::EventStreamConfig* wrapped_config_;
  ::veil::protocol::fuse_messages::EventFilterConfig* filter_config_;
  ::veil::protocol::fuse_messages::EventAggregatorConfig* aggregator_config_;
  ::veil::protocol::fuse_messages::EventTransformerConfig* transformer_config_;
  ::google::protobuf::RepeatedPtrField< ::std::string> needed_envs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static EventStreamConfig* default_instance_;
};
// -------------------------------------------------------------------

class EventProducerConfig : public ::google::protobuf::Message {
 public:
  EventProducerConfig();
  virtual ~EventProducerConfig();

  EventProducerConfig(const EventProducerConfig& from);

  inline EventProducerConfig& operator=(const EventProducerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventProducerConfig& default_instance();

  void Swap(EventProducerConfig* other);

  // implements Message ----------------------------------------------

  EventProducerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventProducerConfig& from);
  void MergeFrom(const EventProducerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .veil.protocol.fuse_messages.EventStreamConfig event_streams_configs = 1;
  inline int event_streams_configs_size() const;
  inline void clear_event_streams_configs();
  static const int kEventStreamsConfigsFieldNumber = 1;
  inline const ::veil::protocol::fuse_messages::EventStreamConfig& event_streams_configs(int index) const;
  inline ::veil::protocol::fuse_messages::EventStreamConfig* mutable_event_streams_configs(int index);
  inline ::veil::protocol::fuse_messages::EventStreamConfig* add_event_streams_configs();
  inline const ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::EventStreamConfig >&
      event_streams_configs() const;
  inline ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::EventStreamConfig >*
      mutable_event_streams_configs();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.EventProducerConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::EventStreamConfig > event_streams_configs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static EventProducerConfig* default_instance_;
};
// -------------------------------------------------------------------

class EventMessage : public ::google::protobuf::Message {
 public:
  EventMessage();
  virtual ~EventMessage();

  EventMessage(const EventMessage& from);

  inline EventMessage& operator=(const EventMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventMessage& default_instance();

  void Swap(EventMessage* other);

  // implements Message ----------------------------------------------

  EventMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventMessage& from);
  void MergeFrom(const EventMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string numeric_properties_keys = 1;
  inline int numeric_properties_keys_size() const;
  inline void clear_numeric_properties_keys();
  static const int kNumericPropertiesKeysFieldNumber = 1;
  inline const ::std::string& numeric_properties_keys(int index) const;
  inline ::std::string* mutable_numeric_properties_keys(int index);
  inline void set_numeric_properties_keys(int index, const ::std::string& value);
  inline void set_numeric_properties_keys(int index, const char* value);
  inline void set_numeric_properties_keys(int index, const char* value, size_t size);
  inline ::std::string* add_numeric_properties_keys();
  inline void add_numeric_properties_keys(const ::std::string& value);
  inline void add_numeric_properties_keys(const char* value);
  inline void add_numeric_properties_keys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& numeric_properties_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_numeric_properties_keys();

  // repeated int64 numeric_properties_values = 2;
  inline int numeric_properties_values_size() const;
  inline void clear_numeric_properties_values();
  static const int kNumericPropertiesValuesFieldNumber = 2;
  inline ::google::protobuf::int64 numeric_properties_values(int index) const;
  inline void set_numeric_properties_values(int index, ::google::protobuf::int64 value);
  inline void add_numeric_properties_values(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      numeric_properties_values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_numeric_properties_values();

  // repeated string string_properties_keys = 3;
  inline int string_properties_keys_size() const;
  inline void clear_string_properties_keys();
  static const int kStringPropertiesKeysFieldNumber = 3;
  inline const ::std::string& string_properties_keys(int index) const;
  inline ::std::string* mutable_string_properties_keys(int index);
  inline void set_string_properties_keys(int index, const ::std::string& value);
  inline void set_string_properties_keys(int index, const char* value);
  inline void set_string_properties_keys(int index, const char* value, size_t size);
  inline ::std::string* add_string_properties_keys();
  inline void add_string_properties_keys(const ::std::string& value);
  inline void add_string_properties_keys(const char* value);
  inline void add_string_properties_keys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& string_properties_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_properties_keys();

  // repeated string string_properties_values = 4;
  inline int string_properties_values_size() const;
  inline void clear_string_properties_values();
  static const int kStringPropertiesValuesFieldNumber = 4;
  inline const ::std::string& string_properties_values(int index) const;
  inline ::std::string* mutable_string_properties_values(int index);
  inline void set_string_properties_values(int index, const ::std::string& value);
  inline void set_string_properties_values(int index, const char* value);
  inline void set_string_properties_values(int index, const char* value, size_t size);
  inline ::std::string* add_string_properties_values();
  inline void add_string_properties_values(const ::std::string& value);
  inline void add_string_properties_values(const char* value);
  inline void add_string_properties_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& string_properties_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_properties_values();

  // @@protoc_insertion_point(class_scope:veil.protocol.fuse_messages.EventMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> numeric_properties_keys_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > numeric_properties_values_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_properties_keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_properties_values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_fuse_5fmessages_2eproto();
  friend void protobuf_AssignDesc_fuse_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_fuse_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static EventMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ChannelRegistration

// required string fuse_id = 1;
inline bool ChannelRegistration::has_fuse_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelRegistration::set_has_fuse_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelRegistration::clear_has_fuse_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelRegistration::clear_fuse_id() {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    fuse_id_->clear();
  }
  clear_has_fuse_id();
}
inline const ::std::string& ChannelRegistration::fuse_id() const {
  return *fuse_id_;
}
inline void ChannelRegistration::set_fuse_id(const ::std::string& value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void ChannelRegistration::set_fuse_id(const char* value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void ChannelRegistration::set_fuse_id(const char* value, size_t size) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelRegistration::mutable_fuse_id() {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  return fuse_id_;
}
inline ::std::string* ChannelRegistration::release_fuse_id() {
  clear_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fuse_id_;
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChannelRegistration::set_allocated_fuse_id(::std::string* fuse_id) {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fuse_id_;
  }
  if (fuse_id) {
    set_has_fuse_id();
    fuse_id_ = fuse_id;
  } else {
    clear_has_fuse_id();
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChannelClose

// required string fuse_id = 1;
inline bool ChannelClose::has_fuse_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelClose::set_has_fuse_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelClose::clear_has_fuse_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelClose::clear_fuse_id() {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    fuse_id_->clear();
  }
  clear_has_fuse_id();
}
inline const ::std::string& ChannelClose::fuse_id() const {
  return *fuse_id_;
}
inline void ChannelClose::set_fuse_id(const ::std::string& value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void ChannelClose::set_fuse_id(const char* value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void ChannelClose::set_fuse_id(const char* value, size_t size) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelClose::mutable_fuse_id() {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  return fuse_id_;
}
inline ::std::string* ChannelClose::release_fuse_id() {
  clear_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fuse_id_;
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChannelClose::set_allocated_fuse_id(::std::string* fuse_id) {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fuse_id_;
  }
  if (fuse_id) {
    set_has_fuse_id();
    fuse_id_ = fuse_id;
  } else {
    clear_has_fuse_id();
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FuseMessage

// required string message_type = 1;
inline bool FuseMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FuseMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FuseMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FuseMessage::clear_message_type() {
  if (message_type_ != &::google::protobuf::internal::kEmptyString) {
    message_type_->clear();
  }
  clear_has_message_type();
}
inline const ::std::string& FuseMessage::message_type() const {
  return *message_type_;
}
inline void FuseMessage::set_message_type(const ::std::string& value) {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  message_type_->assign(value);
}
inline void FuseMessage::set_message_type(const char* value) {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  message_type_->assign(value);
}
inline void FuseMessage::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  message_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FuseMessage::mutable_message_type() {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  return message_type_;
}
inline ::std::string* FuseMessage::release_message_type() {
  clear_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_type_;
    message_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FuseMessage::set_allocated_message_type(::std::string* message_type) {
  if (message_type_ != &::google::protobuf::internal::kEmptyString) {
    delete message_type_;
  }
  if (message_type) {
    set_has_message_type();
    message_type_ = message_type;
  } else {
    clear_has_message_type();
    message_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes input = 2;
inline bool FuseMessage::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FuseMessage::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FuseMessage::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FuseMessage::clear_input() {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    input_->clear();
  }
  clear_has_input();
}
inline const ::std::string& FuseMessage::input() const {
  return *input_;
}
inline void FuseMessage::set_input(const ::std::string& value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void FuseMessage::set_input(const char* value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void FuseMessage::set_input(const void* value, size_t size) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FuseMessage::mutable_input() {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  return input_;
}
inline ::std::string* FuseMessage::release_input() {
  clear_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_;
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FuseMessage::set_allocated_input(::std::string* input) {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    delete input_;
  }
  if (input) {
    set_has_input();
    input_ = input;
  } else {
    clear_has_input();
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetFileLocation

// required string file_logic_name = 1;
inline bool GetFileLocation::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileLocation::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileLocation::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileLocation::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& GetFileLocation::file_logic_name() const {
  return *file_logic_name_;
}
inline void GetFileLocation::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetFileLocation::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetFileLocation::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileLocation::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* GetFileLocation::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileLocation::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string open_mode = 2 [default = ""];
inline bool GetFileLocation::has_open_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFileLocation::set_has_open_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFileLocation::clear_has_open_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFileLocation::clear_open_mode() {
  if (open_mode_ != &::google::protobuf::internal::kEmptyString) {
    open_mode_->clear();
  }
  clear_has_open_mode();
}
inline const ::std::string& GetFileLocation::open_mode() const {
  return *open_mode_;
}
inline void GetFileLocation::set_open_mode(const ::std::string& value) {
  set_has_open_mode();
  if (open_mode_ == &::google::protobuf::internal::kEmptyString) {
    open_mode_ = new ::std::string;
  }
  open_mode_->assign(value);
}
inline void GetFileLocation::set_open_mode(const char* value) {
  set_has_open_mode();
  if (open_mode_ == &::google::protobuf::internal::kEmptyString) {
    open_mode_ = new ::std::string;
  }
  open_mode_->assign(value);
}
inline void GetFileLocation::set_open_mode(const char* value, size_t size) {
  set_has_open_mode();
  if (open_mode_ == &::google::protobuf::internal::kEmptyString) {
    open_mode_ = new ::std::string;
  }
  open_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileLocation::mutable_open_mode() {
  set_has_open_mode();
  if (open_mode_ == &::google::protobuf::internal::kEmptyString) {
    open_mode_ = new ::std::string;
  }
  return open_mode_;
}
inline ::std::string* GetFileLocation::release_open_mode() {
  clear_has_open_mode();
  if (open_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = open_mode_;
    open_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileLocation::set_allocated_open_mode(::std::string* open_mode) {
  if (open_mode_ != &::google::protobuf::internal::kEmptyString) {
    delete open_mode_;
  }
  if (open_mode) {
    set_has_open_mode();
    open_mode_ = open_mode;
  } else {
    clear_has_open_mode();
    open_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool force_cluster_proxy = 3 [default = false];
inline bool GetFileLocation::has_force_cluster_proxy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFileLocation::set_has_force_cluster_proxy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFileLocation::clear_has_force_cluster_proxy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFileLocation::clear_force_cluster_proxy() {
  force_cluster_proxy_ = false;
  clear_has_force_cluster_proxy();
}
inline bool GetFileLocation::force_cluster_proxy() const {
  return force_cluster_proxy_;
}
inline void GetFileLocation::set_force_cluster_proxy(bool value) {
  set_has_force_cluster_proxy();
  force_cluster_proxy_ = value;
}

// -------------------------------------------------------------------

// GetNewFileLocation

// required string file_logic_name = 1;
inline bool GetNewFileLocation::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNewFileLocation::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNewFileLocation::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNewFileLocation::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& GetNewFileLocation::file_logic_name() const {
  return *file_logic_name_;
}
inline void GetNewFileLocation::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetNewFileLocation::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetNewFileLocation::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetNewFileLocation::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* GetNewFileLocation::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetNewFileLocation::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 mode = 2;
inline bool GetNewFileLocation::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNewFileLocation::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNewFileLocation::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNewFileLocation::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 GetNewFileLocation::mode() const {
  return mode_;
}
inline void GetNewFileLocation::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// optional bool force_cluster_proxy = 3 [default = false];
inline bool GetNewFileLocation::has_force_cluster_proxy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetNewFileLocation::set_has_force_cluster_proxy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetNewFileLocation::clear_has_force_cluster_proxy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetNewFileLocation::clear_force_cluster_proxy() {
  force_cluster_proxy_ = false;
  clear_has_force_cluster_proxy();
}
inline bool GetNewFileLocation::force_cluster_proxy() const {
  return force_cluster_proxy_;
}
inline void GetNewFileLocation::set_force_cluster_proxy(bool value) {
  set_has_force_cluster_proxy();
  force_cluster_proxy_ = value;
}

// -------------------------------------------------------------------

// GetFileAttr

// required string file_logic_name = 1;
inline bool GetFileAttr::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileAttr::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileAttr::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileAttr::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& GetFileAttr::file_logic_name() const {
  return *file_logic_name_;
}
inline void GetFileAttr::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetFileAttr::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetFileAttr::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileAttr::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* GetFileAttr::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileAttr::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileAttr

// optional string answer = 1 [default = "ok"];
inline bool FileAttr::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileAttr::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileAttr::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileAttr::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& FileAttr::answer() const {
  return *answer_;
}
inline void FileAttr::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileAttr::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileAttr::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileAttr::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* FileAttr::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void FileAttr::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// required int32 mode = 2;
inline bool FileAttr::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileAttr::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileAttr::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileAttr::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 FileAttr::mode() const {
  return mode_;
}
inline void FileAttr::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// required int32 uid = 3;
inline bool FileAttr::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileAttr::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileAttr::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileAttr::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 FileAttr::uid() const {
  return uid_;
}
inline void FileAttr::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required int32 gid = 4;
inline bool FileAttr::has_gid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileAttr::set_has_gid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileAttr::clear_has_gid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileAttr::clear_gid() {
  gid_ = 0;
  clear_has_gid();
}
inline ::google::protobuf::int32 FileAttr::gid() const {
  return gid_;
}
inline void FileAttr::set_gid(::google::protobuf::int32 value) {
  set_has_gid();
  gid_ = value;
}

// required int64 atime = 5;
inline bool FileAttr::has_atime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileAttr::set_has_atime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileAttr::clear_has_atime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileAttr::clear_atime() {
  atime_ = GOOGLE_LONGLONG(0);
  clear_has_atime();
}
inline ::google::protobuf::int64 FileAttr::atime() const {
  return atime_;
}
inline void FileAttr::set_atime(::google::protobuf::int64 value) {
  set_has_atime();
  atime_ = value;
}

// required int64 mtime = 6;
inline bool FileAttr::has_mtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileAttr::set_has_mtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileAttr::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileAttr::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::int64 FileAttr::mtime() const {
  return mtime_;
}
inline void FileAttr::set_mtime(::google::protobuf::int64 value) {
  set_has_mtime();
  mtime_ = value;
}

// required int64 ctime = 7;
inline bool FileAttr::has_ctime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileAttr::set_has_ctime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileAttr::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileAttr::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::int64 FileAttr::ctime() const {
  return ctime_;
}
inline void FileAttr::set_ctime(::google::protobuf::int64 value) {
  set_has_ctime();
  ctime_ = value;
}

// required string type = 9;
inline bool FileAttr::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FileAttr::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FileAttr::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FileAttr::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& FileAttr::type() const {
  return *type_;
}
inline void FileAttr::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FileAttr::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FileAttr::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileAttr::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* FileAttr::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileAttr::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 size = 10 [default = 0];
inline bool FileAttr::has_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FileAttr::set_has_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FileAttr::clear_has_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FileAttr::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 FileAttr::size() const {
  return size_;
}
inline void FileAttr::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// optional string uname = 11 [default = ""];
inline bool FileAttr::has_uname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FileAttr::set_has_uname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FileAttr::clear_has_uname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FileAttr::clear_uname() {
  if (uname_ != &::google::protobuf::internal::kEmptyString) {
    uname_->clear();
  }
  clear_has_uname();
}
inline const ::std::string& FileAttr::uname() const {
  return *uname_;
}
inline void FileAttr::set_uname(const ::std::string& value) {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  uname_->assign(value);
}
inline void FileAttr::set_uname(const char* value) {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  uname_->assign(value);
}
inline void FileAttr::set_uname(const char* value, size_t size) {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  uname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileAttr::mutable_uname() {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  return uname_;
}
inline ::std::string* FileAttr::release_uname() {
  clear_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uname_;
    uname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileAttr::set_allocated_uname(::std::string* uname) {
  if (uname_ != &::google::protobuf::internal::kEmptyString) {
    delete uname_;
  }
  if (uname) {
    set_has_uname();
    uname_ = uname;
  } else {
    clear_has_uname();
    uname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gname = 12 [default = ""];
inline bool FileAttr::has_gname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FileAttr::set_has_gname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FileAttr::clear_has_gname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FileAttr::clear_gname() {
  if (gname_ != &::google::protobuf::internal::kEmptyString) {
    gname_->clear();
  }
  clear_has_gname();
}
inline const ::std::string& FileAttr::gname() const {
  return *gname_;
}
inline void FileAttr::set_gname(const ::std::string& value) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(value);
}
inline void FileAttr::set_gname(const char* value) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(value);
}
inline void FileAttr::set_gname(const char* value, size_t size) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileAttr::mutable_gname() {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  return gname_;
}
inline ::std::string* FileAttr::release_gname() {
  clear_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gname_;
    gname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileAttr::set_allocated_gname(::std::string* gname) {
  if (gname_ != &::google::protobuf::internal::kEmptyString) {
    delete gname_;
  }
  if (gname) {
    set_has_gname();
    gname_ = gname;
  } else {
    clear_has_gname();
    gname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 links = 13 [default = 1];
inline bool FileAttr::has_links() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FileAttr::set_has_links() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FileAttr::clear_has_links() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FileAttr::clear_links() {
  links_ = 1;
  clear_has_links();
}
inline ::google::protobuf::int32 FileAttr::links() const {
  return links_;
}
inline void FileAttr::set_links(::google::protobuf::int32 value) {
  set_has_links();
  links_ = value;
}

// -------------------------------------------------------------------

// GetFileUuid

// required string file_logic_name = 1;
inline bool GetFileUuid::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileUuid::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileUuid::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileUuid::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& GetFileUuid::file_logic_name() const {
  return *file_logic_name_;
}
inline void GetFileUuid::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetFileUuid::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetFileUuid::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileUuid::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* GetFileUuid::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileUuid::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileUuid

// optional string answer = 1 [default = "ok"];
inline bool FileUuid::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileUuid::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileUuid::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileUuid::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& FileUuid::answer() const {
  return *answer_;
}
inline void FileUuid::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileUuid::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileUuid::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileUuid::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* FileUuid::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void FileUuid::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// required string uuid = 2;
inline bool FileUuid::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileUuid::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileUuid::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileUuid::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& FileUuid::uuid() const {
  return *uuid_;
}
inline void FileUuid::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void FileUuid::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void FileUuid::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileUuid::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* FileUuid::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileUuid::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileLocation

// optional string answer = 1 [default = "ok"];
inline bool FileLocation::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLocation::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLocation::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLocation::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& FileLocation::answer() const {
  return *answer_;
}
inline void FileLocation::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileLocation::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileLocation::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocation::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* FileLocation::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void FileLocation::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// required int32 storage_id = 2;
inline bool FileLocation::has_storage_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLocation::set_has_storage_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLocation::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLocation::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 FileLocation::storage_id() const {
  return storage_id_;
}
inline void FileLocation::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
}

// required string file_id = 3;
inline bool FileLocation::has_file_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileLocation::set_has_file_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileLocation::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileLocation::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& FileLocation::file_id() const {
  return *file_id_;
}
inline void FileLocation::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void FileLocation::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void FileLocation::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocation::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* FileLocation::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLocation::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 validity = 4;
inline bool FileLocation::has_validity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileLocation::set_has_validity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileLocation::clear_has_validity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileLocation::clear_validity() {
  validity_ = 0;
  clear_has_validity();
}
inline ::google::protobuf::int32 FileLocation::validity() const {
  return validity_;
}
inline void FileLocation::set_validity(::google::protobuf::int32 value) {
  set_has_validity();
  validity_ = value;
}

// optional string storage_helper_name = 5;
inline bool FileLocation::has_storage_helper_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileLocation::set_has_storage_helper_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileLocation::clear_has_storage_helper_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileLocation::clear_storage_helper_name() {
  if (storage_helper_name_ != &::google::protobuf::internal::kEmptyString) {
    storage_helper_name_->clear();
  }
  clear_has_storage_helper_name();
}
inline const ::std::string& FileLocation::storage_helper_name() const {
  return *storage_helper_name_;
}
inline void FileLocation::set_storage_helper_name(const ::std::string& value) {
  set_has_storage_helper_name();
  if (storage_helper_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_helper_name_ = new ::std::string;
  }
  storage_helper_name_->assign(value);
}
inline void FileLocation::set_storage_helper_name(const char* value) {
  set_has_storage_helper_name();
  if (storage_helper_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_helper_name_ = new ::std::string;
  }
  storage_helper_name_->assign(value);
}
inline void FileLocation::set_storage_helper_name(const char* value, size_t size) {
  set_has_storage_helper_name();
  if (storage_helper_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_helper_name_ = new ::std::string;
  }
  storage_helper_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocation::mutable_storage_helper_name() {
  set_has_storage_helper_name();
  if (storage_helper_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_helper_name_ = new ::std::string;
  }
  return storage_helper_name_;
}
inline ::std::string* FileLocation::release_storage_helper_name() {
  clear_has_storage_helper_name();
  if (storage_helper_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storage_helper_name_;
    storage_helper_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLocation::set_allocated_storage_helper_name(::std::string* storage_helper_name) {
  if (storage_helper_name_ != &::google::protobuf::internal::kEmptyString) {
    delete storage_helper_name_;
  }
  if (storage_helper_name) {
    set_has_storage_helper_name();
    storage_helper_name_ = storage_helper_name;
  } else {
    clear_has_storage_helper_name();
    storage_helper_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string storage_helper_args = 6;
inline int FileLocation::storage_helper_args_size() const {
  return storage_helper_args_.size();
}
inline void FileLocation::clear_storage_helper_args() {
  storage_helper_args_.Clear();
}
inline const ::std::string& FileLocation::storage_helper_args(int index) const {
  return storage_helper_args_.Get(index);
}
inline ::std::string* FileLocation::mutable_storage_helper_args(int index) {
  return storage_helper_args_.Mutable(index);
}
inline void FileLocation::set_storage_helper_args(int index, const ::std::string& value) {
  storage_helper_args_.Mutable(index)->assign(value);
}
inline void FileLocation::set_storage_helper_args(int index, const char* value) {
  storage_helper_args_.Mutable(index)->assign(value);
}
inline void FileLocation::set_storage_helper_args(int index, const char* value, size_t size) {
  storage_helper_args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocation::add_storage_helper_args() {
  return storage_helper_args_.Add();
}
inline void FileLocation::add_storage_helper_args(const ::std::string& value) {
  storage_helper_args_.Add()->assign(value);
}
inline void FileLocation::add_storage_helper_args(const char* value) {
  storage_helper_args_.Add()->assign(value);
}
inline void FileLocation::add_storage_helper_args(const char* value, size_t size) {
  storage_helper_args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileLocation::storage_helper_args() const {
  return storage_helper_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileLocation::mutable_storage_helper_args() {
  return &storage_helper_args_;
}

// -------------------------------------------------------------------

// CreateFileAck

// required string file_logic_name = 1;
inline bool CreateFileAck::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateFileAck::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateFileAck::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateFileAck::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& CreateFileAck::file_logic_name() const {
  return *file_logic_name_;
}
inline void CreateFileAck::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void CreateFileAck::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void CreateFileAck::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateFileAck::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* CreateFileAck::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateFileAck::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileNotUsed

// required string file_logic_name = 1;
inline bool FileNotUsed::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileNotUsed::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileNotUsed::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileNotUsed::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& FileNotUsed::file_logic_name() const {
  return *file_logic_name_;
}
inline void FileNotUsed::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void FileNotUsed::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void FileNotUsed::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileNotUsed::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* FileNotUsed::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileNotUsed::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RenewFileLocation

// required string file_logic_name = 1;
inline bool RenewFileLocation::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenewFileLocation::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenewFileLocation::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenewFileLocation::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& RenewFileLocation::file_logic_name() const {
  return *file_logic_name_;
}
inline void RenewFileLocation::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void RenewFileLocation::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void RenewFileLocation::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewFileLocation::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* RenewFileLocation::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RenewFileLocation::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileLocationValidity

// optional string answer = 1 [default = "ok"];
inline bool FileLocationValidity::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLocationValidity::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLocationValidity::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLocationValidity::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& FileLocationValidity::answer() const {
  return *answer_;
}
inline void FileLocationValidity::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileLocationValidity::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileLocationValidity::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocationValidity::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* FileLocationValidity::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void FileLocationValidity::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// optional int32 validity = 2;
inline bool FileLocationValidity::has_validity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLocationValidity::set_has_validity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLocationValidity::clear_has_validity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLocationValidity::clear_validity() {
  validity_ = 0;
  clear_has_validity();
}
inline ::google::protobuf::int32 FileLocationValidity::validity() const {
  return validity_;
}
inline void FileLocationValidity::set_validity(::google::protobuf::int32 value) {
  set_has_validity();
  validity_ = value;
}

// -------------------------------------------------------------------

// GetFileChildren

// required string dir_logic_name = 1;
inline bool GetFileChildren::has_dir_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileChildren::set_has_dir_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileChildren::clear_has_dir_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileChildren::clear_dir_logic_name() {
  if (dir_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_->clear();
  }
  clear_has_dir_logic_name();
}
inline const ::std::string& GetFileChildren::dir_logic_name() const {
  return *dir_logic_name_;
}
inline void GetFileChildren::set_dir_logic_name(const ::std::string& value) {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  dir_logic_name_->assign(value);
}
inline void GetFileChildren::set_dir_logic_name(const char* value) {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  dir_logic_name_->assign(value);
}
inline void GetFileChildren::set_dir_logic_name(const char* value, size_t size) {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  dir_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileChildren::mutable_dir_logic_name() {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  return dir_logic_name_;
}
inline ::std::string* GetFileChildren::release_dir_logic_name() {
  clear_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_logic_name_;
    dir_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileChildren::set_allocated_dir_logic_name(::std::string* dir_logic_name) {
  if (dir_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dir_logic_name_;
  }
  if (dir_logic_name) {
    set_has_dir_logic_name();
    dir_logic_name_ = dir_logic_name;
  } else {
    clear_has_dir_logic_name();
    dir_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 children_num = 2;
inline bool GetFileChildren::has_children_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFileChildren::set_has_children_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFileChildren::clear_has_children_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFileChildren::clear_children_num() {
  children_num_ = 0;
  clear_has_children_num();
}
inline ::google::protobuf::int32 GetFileChildren::children_num() const {
  return children_num_;
}
inline void GetFileChildren::set_children_num(::google::protobuf::int32 value) {
  set_has_children_num();
  children_num_ = value;
}

// optional int32 offset = 3 [default = 0];
inline bool GetFileChildren::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFileChildren::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFileChildren::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFileChildren::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 GetFileChildren::offset() const {
  return offset_;
}
inline void GetFileChildren::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// FileChildren

// optional string answer = 1 [default = "ok"];
inline bool FileChildren::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileChildren::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileChildren::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileChildren::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& FileChildren::answer() const {
  return *answer_;
}
inline void FileChildren::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileChildren::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void FileChildren::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileChildren::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* FileChildren::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void FileChildren::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// repeated string child_logic_name = 2;
inline int FileChildren::child_logic_name_size() const {
  return child_logic_name_.size();
}
inline void FileChildren::clear_child_logic_name() {
  child_logic_name_.Clear();
}
inline const ::std::string& FileChildren::child_logic_name(int index) const {
  return child_logic_name_.Get(index);
}
inline ::std::string* FileChildren::mutable_child_logic_name(int index) {
  return child_logic_name_.Mutable(index);
}
inline void FileChildren::set_child_logic_name(int index, const ::std::string& value) {
  child_logic_name_.Mutable(index)->assign(value);
}
inline void FileChildren::set_child_logic_name(int index, const char* value) {
  child_logic_name_.Mutable(index)->assign(value);
}
inline void FileChildren::set_child_logic_name(int index, const char* value, size_t size) {
  child_logic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileChildren::add_child_logic_name() {
  return child_logic_name_.Add();
}
inline void FileChildren::add_child_logic_name(const ::std::string& value) {
  child_logic_name_.Add()->assign(value);
}
inline void FileChildren::add_child_logic_name(const char* value) {
  child_logic_name_.Add()->assign(value);
}
inline void FileChildren::add_child_logic_name(const char* value, size_t size) {
  child_logic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileChildren::child_logic_name() const {
  return child_logic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileChildren::mutable_child_logic_name() {
  return &child_logic_name_;
}

// -------------------------------------------------------------------

// CreateDir

// required string dir_logic_name = 1;
inline bool CreateDir::has_dir_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateDir::set_has_dir_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateDir::clear_has_dir_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateDir::clear_dir_logic_name() {
  if (dir_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_->clear();
  }
  clear_has_dir_logic_name();
}
inline const ::std::string& CreateDir::dir_logic_name() const {
  return *dir_logic_name_;
}
inline void CreateDir::set_dir_logic_name(const ::std::string& value) {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  dir_logic_name_->assign(value);
}
inline void CreateDir::set_dir_logic_name(const char* value) {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  dir_logic_name_->assign(value);
}
inline void CreateDir::set_dir_logic_name(const char* value, size_t size) {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  dir_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateDir::mutable_dir_logic_name() {
  set_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    dir_logic_name_ = new ::std::string;
  }
  return dir_logic_name_;
}
inline ::std::string* CreateDir::release_dir_logic_name() {
  clear_has_dir_logic_name();
  if (dir_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_logic_name_;
    dir_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateDir::set_allocated_dir_logic_name(::std::string* dir_logic_name) {
  if (dir_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dir_logic_name_;
  }
  if (dir_logic_name) {
    set_has_dir_logic_name();
    dir_logic_name_ = dir_logic_name;
  } else {
    clear_has_dir_logic_name();
    dir_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 mode = 2;
inline bool CreateDir::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateDir::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateDir::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateDir::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CreateDir::mode() const {
  return mode_;
}
inline void CreateDir::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// DeleteFile

// required string file_logic_name = 1;
inline bool DeleteFile::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteFile::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteFile::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteFile::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& DeleteFile::file_logic_name() const {
  return *file_logic_name_;
}
inline void DeleteFile::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void DeleteFile::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void DeleteFile::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteFile::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* DeleteFile::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeleteFile::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateLink

// required string from_file_logic_name = 1;
inline bool CreateLink::has_from_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateLink::set_has_from_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateLink::clear_has_from_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateLink::clear_from_file_logic_name() {
  if (from_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_->clear();
  }
  clear_has_from_file_logic_name();
}
inline const ::std::string& CreateLink::from_file_logic_name() const {
  return *from_file_logic_name_;
}
inline void CreateLink::set_from_file_logic_name(const ::std::string& value) {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  from_file_logic_name_->assign(value);
}
inline void CreateLink::set_from_file_logic_name(const char* value) {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  from_file_logic_name_->assign(value);
}
inline void CreateLink::set_from_file_logic_name(const char* value, size_t size) {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  from_file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateLink::mutable_from_file_logic_name() {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  return from_file_logic_name_;
}
inline ::std::string* CreateLink::release_from_file_logic_name() {
  clear_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_file_logic_name_;
    from_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateLink::set_allocated_from_file_logic_name(::std::string* from_file_logic_name) {
  if (from_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_file_logic_name_;
  }
  if (from_file_logic_name) {
    set_has_from_file_logic_name();
    from_file_logic_name_ = from_file_logic_name;
  } else {
    clear_has_from_file_logic_name();
    from_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to_file_logic_name = 2;
inline bool CreateLink::has_to_file_logic_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateLink::set_has_to_file_logic_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateLink::clear_has_to_file_logic_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateLink::clear_to_file_logic_name() {
  if (to_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_->clear();
  }
  clear_has_to_file_logic_name();
}
inline const ::std::string& CreateLink::to_file_logic_name() const {
  return *to_file_logic_name_;
}
inline void CreateLink::set_to_file_logic_name(const ::std::string& value) {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  to_file_logic_name_->assign(value);
}
inline void CreateLink::set_to_file_logic_name(const char* value) {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  to_file_logic_name_->assign(value);
}
inline void CreateLink::set_to_file_logic_name(const char* value, size_t size) {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  to_file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateLink::mutable_to_file_logic_name() {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  return to_file_logic_name_;
}
inline ::std::string* CreateLink::release_to_file_logic_name() {
  clear_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_file_logic_name_;
    to_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateLink::set_allocated_to_file_logic_name(::std::string* to_file_logic_name) {
  if (to_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete to_file_logic_name_;
  }
  if (to_file_logic_name) {
    set_has_to_file_logic_name();
    to_file_logic_name_ = to_file_logic_name;
  } else {
    clear_has_to_file_logic_name();
    to_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetLink

// required string file_logic_name = 1;
inline bool GetLink::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLink::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLink::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLink::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& GetLink::file_logic_name() const {
  return *file_logic_name_;
}
inline void GetLink::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetLink::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void GetLink::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLink::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* GetLink::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLink::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LinkInfo

// optional string answer = 1 [default = "ok"];
inline bool LinkInfo::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkInfo::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkInfo::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkInfo::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& LinkInfo::answer() const {
  return *answer_;
}
inline void LinkInfo::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void LinkInfo::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void LinkInfo::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkInfo::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* LinkInfo::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void LinkInfo::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// required string file_logic_name = 2;
inline bool LinkInfo::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinkInfo::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinkInfo::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinkInfo::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& LinkInfo::file_logic_name() const {
  return *file_logic_name_;
}
inline void LinkInfo::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void LinkInfo::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void LinkInfo::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkInfo::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* LinkInfo::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinkInfo::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RenameFile

// required string from_file_logic_name = 1;
inline bool RenameFile::has_from_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenameFile::set_has_from_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenameFile::clear_has_from_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenameFile::clear_from_file_logic_name() {
  if (from_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_->clear();
  }
  clear_has_from_file_logic_name();
}
inline const ::std::string& RenameFile::from_file_logic_name() const {
  return *from_file_logic_name_;
}
inline void RenameFile::set_from_file_logic_name(const ::std::string& value) {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  from_file_logic_name_->assign(value);
}
inline void RenameFile::set_from_file_logic_name(const char* value) {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  from_file_logic_name_->assign(value);
}
inline void RenameFile::set_from_file_logic_name(const char* value, size_t size) {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  from_file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenameFile::mutable_from_file_logic_name() {
  set_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    from_file_logic_name_ = new ::std::string;
  }
  return from_file_logic_name_;
}
inline ::std::string* RenameFile::release_from_file_logic_name() {
  clear_has_from_file_logic_name();
  if (from_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_file_logic_name_;
    from_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RenameFile::set_allocated_from_file_logic_name(::std::string* from_file_logic_name) {
  if (from_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_file_logic_name_;
  }
  if (from_file_logic_name) {
    set_has_from_file_logic_name();
    from_file_logic_name_ = from_file_logic_name;
  } else {
    clear_has_from_file_logic_name();
    from_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to_file_logic_name = 2;
inline bool RenameFile::has_to_file_logic_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenameFile::set_has_to_file_logic_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenameFile::clear_has_to_file_logic_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenameFile::clear_to_file_logic_name() {
  if (to_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_->clear();
  }
  clear_has_to_file_logic_name();
}
inline const ::std::string& RenameFile::to_file_logic_name() const {
  return *to_file_logic_name_;
}
inline void RenameFile::set_to_file_logic_name(const ::std::string& value) {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  to_file_logic_name_->assign(value);
}
inline void RenameFile::set_to_file_logic_name(const char* value) {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  to_file_logic_name_->assign(value);
}
inline void RenameFile::set_to_file_logic_name(const char* value, size_t size) {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  to_file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenameFile::mutable_to_file_logic_name() {
  set_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    to_file_logic_name_ = new ::std::string;
  }
  return to_file_logic_name_;
}
inline ::std::string* RenameFile::release_to_file_logic_name() {
  clear_has_to_file_logic_name();
  if (to_file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_file_logic_name_;
    to_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RenameFile::set_allocated_to_file_logic_name(::std::string* to_file_logic_name) {
  if (to_file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete to_file_logic_name_;
  }
  if (to_file_logic_name) {
    set_has_to_file_logic_name();
    to_file_logic_name_ = to_file_logic_name;
  } else {
    clear_has_to_file_logic_name();
    to_file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeFileOwner

// required string file_logic_name = 1;
inline bool ChangeFileOwner::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFileOwner::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFileOwner::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFileOwner::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& ChangeFileOwner::file_logic_name() const {
  return *file_logic_name_;
}
inline void ChangeFileOwner::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void ChangeFileOwner::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void ChangeFileOwner::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeFileOwner::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* ChangeFileOwner::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeFileOwner::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 uid = 2;
inline bool ChangeFileOwner::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFileOwner::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFileOwner::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFileOwner::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ChangeFileOwner::uid() const {
  return uid_;
}
inline void ChangeFileOwner::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional string uname = 4 [default = ""];
inline bool ChangeFileOwner::has_uname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeFileOwner::set_has_uname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeFileOwner::clear_has_uname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeFileOwner::clear_uname() {
  if (uname_ != &::google::protobuf::internal::kEmptyString) {
    uname_->clear();
  }
  clear_has_uname();
}
inline const ::std::string& ChangeFileOwner::uname() const {
  return *uname_;
}
inline void ChangeFileOwner::set_uname(const ::std::string& value) {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  uname_->assign(value);
}
inline void ChangeFileOwner::set_uname(const char* value) {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  uname_->assign(value);
}
inline void ChangeFileOwner::set_uname(const char* value, size_t size) {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  uname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeFileOwner::mutable_uname() {
  set_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    uname_ = new ::std::string;
  }
  return uname_;
}
inline ::std::string* ChangeFileOwner::release_uname() {
  clear_has_uname();
  if (uname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uname_;
    uname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeFileOwner::set_allocated_uname(::std::string* uname) {
  if (uname_ != &::google::protobuf::internal::kEmptyString) {
    delete uname_;
  }
  if (uname) {
    set_has_uname();
    uname_ = uname;
  } else {
    clear_has_uname();
    uname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeFileGroup

// required string file_logic_name = 1;
inline bool ChangeFileGroup::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFileGroup::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFileGroup::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFileGroup::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& ChangeFileGroup::file_logic_name() const {
  return *file_logic_name_;
}
inline void ChangeFileGroup::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void ChangeFileGroup::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void ChangeFileGroup::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeFileGroup::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* ChangeFileGroup::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeFileGroup::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 gid = 3;
inline bool ChangeFileGroup::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFileGroup::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFileGroup::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFileGroup::clear_gid() {
  gid_ = 0;
  clear_has_gid();
}
inline ::google::protobuf::int32 ChangeFileGroup::gid() const {
  return gid_;
}
inline void ChangeFileGroup::set_gid(::google::protobuf::int32 value) {
  set_has_gid();
  gid_ = value;
}

// optional string gname = 5 [default = ""];
inline bool ChangeFileGroup::has_gname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeFileGroup::set_has_gname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeFileGroup::clear_has_gname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeFileGroup::clear_gname() {
  if (gname_ != &::google::protobuf::internal::kEmptyString) {
    gname_->clear();
  }
  clear_has_gname();
}
inline const ::std::string& ChangeFileGroup::gname() const {
  return *gname_;
}
inline void ChangeFileGroup::set_gname(const ::std::string& value) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(value);
}
inline void ChangeFileGroup::set_gname(const char* value) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(value);
}
inline void ChangeFileGroup::set_gname(const char* value, size_t size) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeFileGroup::mutable_gname() {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  return gname_;
}
inline ::std::string* ChangeFileGroup::release_gname() {
  clear_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gname_;
    gname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeFileGroup::set_allocated_gname(::std::string* gname) {
  if (gname_ != &::google::protobuf::internal::kEmptyString) {
    delete gname_;
  }
  if (gname) {
    set_has_gname();
    gname_ = gname;
  } else {
    clear_has_gname();
    gname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeFilePerms

// required string file_logic_name = 1;
inline bool ChangeFilePerms::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFilePerms::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFilePerms::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFilePerms::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& ChangeFilePerms::file_logic_name() const {
  return *file_logic_name_;
}
inline void ChangeFilePerms::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void ChangeFilePerms::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void ChangeFilePerms::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeFilePerms::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* ChangeFilePerms::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeFilePerms::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 perms = 2;
inline bool ChangeFilePerms::has_perms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFilePerms::set_has_perms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFilePerms::clear_has_perms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFilePerms::clear_perms() {
  perms_ = 0;
  clear_has_perms();
}
inline ::google::protobuf::int32 ChangeFilePerms::perms() const {
  return perms_;
}
inline void ChangeFilePerms::set_perms(::google::protobuf::int32 value) {
  set_has_perms();
  perms_ = value;
}

// -------------------------------------------------------------------

// CheckFilePerms

// required string file_logic_name = 1;
inline bool CheckFilePerms::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckFilePerms::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckFilePerms::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckFilePerms::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& CheckFilePerms::file_logic_name() const {
  return *file_logic_name_;
}
inline void CheckFilePerms::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void CheckFilePerms::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void CheckFilePerms::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckFilePerms::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* CheckFilePerms::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckFilePerms::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2 [default = "root"];
inline bool CheckFilePerms::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckFilePerms::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckFilePerms::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckFilePerms::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& CheckFilePerms::type() const {
  return *type_;
}
inline void CheckFilePerms::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CheckFilePerms::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CheckFilePerms::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckFilePerms::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* CheckFilePerms::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void CheckFilePerms::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// -------------------------------------------------------------------

// UpdateTimes

// required string file_logic_name = 1;
inline bool UpdateTimes::has_file_logic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTimes::set_has_file_logic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTimes::clear_has_file_logic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTimes::clear_file_logic_name() {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    file_logic_name_->clear();
  }
  clear_has_file_logic_name();
}
inline const ::std::string& UpdateTimes::file_logic_name() const {
  return *file_logic_name_;
}
inline void UpdateTimes::set_file_logic_name(const ::std::string& value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void UpdateTimes::set_file_logic_name(const char* value) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(value);
}
inline void UpdateTimes::set_file_logic_name(const char* value, size_t size) {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  file_logic_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateTimes::mutable_file_logic_name() {
  set_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    file_logic_name_ = new ::std::string;
  }
  return file_logic_name_;
}
inline ::std::string* UpdateTimes::release_file_logic_name() {
  clear_has_file_logic_name();
  if (file_logic_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_logic_name_;
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateTimes::set_allocated_file_logic_name(::std::string* file_logic_name) {
  if (file_logic_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_logic_name_;
  }
  if (file_logic_name) {
    set_has_file_logic_name();
    file_logic_name_ = file_logic_name;
  } else {
    clear_has_file_logic_name();
    file_logic_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 atime = 2 [default = -1];
inline bool UpdateTimes::has_atime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTimes::set_has_atime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTimes::clear_has_atime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTimes::clear_atime() {
  atime_ = GOOGLE_LONGLONG(-1);
  clear_has_atime();
}
inline ::google::protobuf::int64 UpdateTimes::atime() const {
  return atime_;
}
inline void UpdateTimes::set_atime(::google::protobuf::int64 value) {
  set_has_atime();
  atime_ = value;
}

// optional int64 mtime = 3 [default = -1];
inline bool UpdateTimes::has_mtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateTimes::set_has_mtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateTimes::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateTimes::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(-1);
  clear_has_mtime();
}
inline ::google::protobuf::int64 UpdateTimes::mtime() const {
  return mtime_;
}
inline void UpdateTimes::set_mtime(::google::protobuf::int64 value) {
  set_has_mtime();
  mtime_ = value;
}

// optional int64 ctime = 4 [default = -1];
inline bool UpdateTimes::has_ctime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateTimes::set_has_ctime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateTimes::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateTimes::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(-1);
  clear_has_ctime();
}
inline ::google::protobuf::int64 UpdateTimes::ctime() const {
  return ctime_;
}
inline void UpdateTimes::set_ctime(::google::protobuf::int64 value) {
  set_has_ctime();
  ctime_ = value;
}

// -------------------------------------------------------------------

// TestChannel

// required string answer_message = 1;
inline bool TestChannel::has_answer_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestChannel::set_has_answer_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestChannel::clear_has_answer_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestChannel::clear_answer_message() {
  if (answer_message_ != &::google::protobuf::internal::kEmptyString) {
    answer_message_->clear();
  }
  clear_has_answer_message();
}
inline const ::std::string& TestChannel::answer_message() const {
  return *answer_message_;
}
inline void TestChannel::set_answer_message(const ::std::string& value) {
  set_has_answer_message();
  if (answer_message_ == &::google::protobuf::internal::kEmptyString) {
    answer_message_ = new ::std::string;
  }
  answer_message_->assign(value);
}
inline void TestChannel::set_answer_message(const char* value) {
  set_has_answer_message();
  if (answer_message_ == &::google::protobuf::internal::kEmptyString) {
    answer_message_ = new ::std::string;
  }
  answer_message_->assign(value);
}
inline void TestChannel::set_answer_message(const char* value, size_t size) {
  set_has_answer_message();
  if (answer_message_ == &::google::protobuf::internal::kEmptyString) {
    answer_message_ = new ::std::string;
  }
  answer_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestChannel::mutable_answer_message() {
  set_has_answer_message();
  if (answer_message_ == &::google::protobuf::internal::kEmptyString) {
    answer_message_ = new ::std::string;
  }
  return answer_message_;
}
inline ::std::string* TestChannel::release_answer_message() {
  clear_has_answer_message();
  if (answer_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = answer_message_;
    answer_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestChannel::set_allocated_answer_message(::std::string* answer_message) {
  if (answer_message_ != &::google::protobuf::internal::kEmptyString) {
    delete answer_message_;
  }
  if (answer_message) {
    set_has_answer_message();
    answer_message_ = answer_message;
  } else {
    clear_has_answer_message();
    answer_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 answer_delay_in_ms = 2;
inline bool TestChannel::has_answer_delay_in_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestChannel::set_has_answer_delay_in_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestChannel::clear_has_answer_delay_in_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestChannel::clear_answer_delay_in_ms() {
  answer_delay_in_ms_ = 0;
  clear_has_answer_delay_in_ms();
}
inline ::google::protobuf::int32 TestChannel::answer_delay_in_ms() const {
  return answer_delay_in_ms_;
}
inline void TestChannel::set_answer_delay_in_ms(::google::protobuf::int32 value) {
  set_has_answer_delay_in_ms();
  answer_delay_in_ms_ = value;
}

// -------------------------------------------------------------------

// TestChannelAnswer

// required string message = 1;
inline bool TestChannelAnswer::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestChannelAnswer::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestChannelAnswer::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestChannelAnswer::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& TestChannelAnswer::message() const {
  return *message_;
}
inline void TestChannelAnswer::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TestChannelAnswer::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TestChannelAnswer::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestChannelAnswer::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* TestChannelAnswer::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestChannelAnswer::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HandshakeRequest_EnvVariable

// required string name = 1;
inline bool HandshakeRequest_EnvVariable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeRequest_EnvVariable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeRequest_EnvVariable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeRequest_EnvVariable::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HandshakeRequest_EnvVariable::name() const {
  return *name_;
}
inline void HandshakeRequest_EnvVariable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HandshakeRequest_EnvVariable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HandshakeRequest_EnvVariable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandshakeRequest_EnvVariable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* HandshakeRequest_EnvVariable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandshakeRequest_EnvVariable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool HandshakeRequest_EnvVariable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandshakeRequest_EnvVariable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandshakeRequest_EnvVariable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandshakeRequest_EnvVariable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& HandshakeRequest_EnvVariable::value() const {
  return *value_;
}
inline void HandshakeRequest_EnvVariable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void HandshakeRequest_EnvVariable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void HandshakeRequest_EnvVariable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandshakeRequest_EnvVariable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* HandshakeRequest_EnvVariable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandshakeRequest_EnvVariable::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HandshakeRequest_CertConfirmation

// required string login = 1;
inline bool HandshakeRequest_CertConfirmation::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeRequest_CertConfirmation::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeRequest_CertConfirmation::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeRequest_CertConfirmation::clear_login() {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    login_->clear();
  }
  clear_has_login();
}
inline const ::std::string& HandshakeRequest_CertConfirmation::login() const {
  return *login_;
}
inline void HandshakeRequest_CertConfirmation::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void HandshakeRequest_CertConfirmation::set_login(const char* value) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(value);
}
inline void HandshakeRequest_CertConfirmation::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandshakeRequest_CertConfirmation::mutable_login() {
  set_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    login_ = new ::std::string;
  }
  return login_;
}
inline ::std::string* HandshakeRequest_CertConfirmation::release_login() {
  clear_has_login();
  if (login_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandshakeRequest_CertConfirmation::set_allocated_login(::std::string* login) {
  if (login_ != &::google::protobuf::internal::kEmptyString) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool result = 2;
inline bool HandshakeRequest_CertConfirmation::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandshakeRequest_CertConfirmation::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandshakeRequest_CertConfirmation::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandshakeRequest_CertConfirmation::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool HandshakeRequest_CertConfirmation::result() const {
  return result_;
}
inline void HandshakeRequest_CertConfirmation::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// HandshakeRequest

// required string hostname = 1;
inline bool HandshakeRequest::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeRequest::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeRequest::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeRequest::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& HandshakeRequest::hostname() const {
  return *hostname_;
}
inline void HandshakeRequest::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void HandshakeRequest::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void HandshakeRequest::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandshakeRequest::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* HandshakeRequest::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandshakeRequest::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .veil.protocol.fuse_messages.HandshakeRequest.EnvVariable variable = 2;
inline int HandshakeRequest::variable_size() const {
  return variable_.size();
}
inline void HandshakeRequest::clear_variable() {
  variable_.Clear();
}
inline const ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable& HandshakeRequest::variable(int index) const {
  return variable_.Get(index);
}
inline ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable* HandshakeRequest::mutable_variable(int index) {
  return variable_.Mutable(index);
}
inline ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable* HandshakeRequest::add_variable() {
  return variable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable >&
HandshakeRequest::variable() const {
  return variable_;
}
inline ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::HandshakeRequest_EnvVariable >*
HandshakeRequest::mutable_variable() {
  return &variable_;
}

// optional .veil.protocol.fuse_messages.HandshakeRequest.CertConfirmation cert_confirmation = 3;
inline bool HandshakeRequest::has_cert_confirmation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandshakeRequest::set_has_cert_confirmation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandshakeRequest::clear_has_cert_confirmation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandshakeRequest::clear_cert_confirmation() {
  if (cert_confirmation_ != NULL) cert_confirmation_->::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation::Clear();
  clear_has_cert_confirmation();
}
inline const ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation& HandshakeRequest::cert_confirmation() const {
  return cert_confirmation_ != NULL ? *cert_confirmation_ : *default_instance_->cert_confirmation_;
}
inline ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* HandshakeRequest::mutable_cert_confirmation() {
  set_has_cert_confirmation();
  if (cert_confirmation_ == NULL) cert_confirmation_ = new ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation;
  return cert_confirmation_;
}
inline ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* HandshakeRequest::release_cert_confirmation() {
  clear_has_cert_confirmation();
  ::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* temp = cert_confirmation_;
  cert_confirmation_ = NULL;
  return temp;
}
inline void HandshakeRequest::set_allocated_cert_confirmation(::veil::protocol::fuse_messages::HandshakeRequest_CertConfirmation* cert_confirmation) {
  delete cert_confirmation_;
  cert_confirmation_ = cert_confirmation;
  if (cert_confirmation) {
    set_has_cert_confirmation();
  } else {
    clear_has_cert_confirmation();
  }
}

// -------------------------------------------------------------------

// HandshakeResponse

// required string fuse_id = 1;
inline bool HandshakeResponse::has_fuse_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeResponse::set_has_fuse_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeResponse::clear_has_fuse_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeResponse::clear_fuse_id() {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    fuse_id_->clear();
  }
  clear_has_fuse_id();
}
inline const ::std::string& HandshakeResponse::fuse_id() const {
  return *fuse_id_;
}
inline void HandshakeResponse::set_fuse_id(const ::std::string& value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void HandshakeResponse::set_fuse_id(const char* value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void HandshakeResponse::set_fuse_id(const char* value, size_t size) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandshakeResponse::mutable_fuse_id() {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  return fuse_id_;
}
inline ::std::string* HandshakeResponse::release_fuse_id() {
  clear_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fuse_id_;
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandshakeResponse::set_allocated_fuse_id(::std::string* fuse_id) {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fuse_id_;
  }
  if (fuse_id) {
    set_has_fuse_id();
    fuse_id_ = fuse_id;
  } else {
    clear_has_fuse_id();
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HandshakeAck

// required string fuse_id = 1;
inline bool HandshakeAck::has_fuse_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeAck::set_has_fuse_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeAck::clear_has_fuse_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeAck::clear_fuse_id() {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    fuse_id_->clear();
  }
  clear_has_fuse_id();
}
inline const ::std::string& HandshakeAck::fuse_id() const {
  return *fuse_id_;
}
inline void HandshakeAck::set_fuse_id(const ::std::string& value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void HandshakeAck::set_fuse_id(const char* value) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(value);
}
inline void HandshakeAck::set_fuse_id(const char* value, size_t size) {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  fuse_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandshakeAck::mutable_fuse_id() {
  set_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    fuse_id_ = new ::std::string;
  }
  return fuse_id_;
}
inline ::std::string* HandshakeAck::release_fuse_id() {
  clear_has_fuse_id();
  if (fuse_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fuse_id_;
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandshakeAck::set_allocated_fuse_id(::std::string* fuse_id) {
  if (fuse_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fuse_id_;
  }
  if (fuse_id) {
    set_has_fuse_id();
    fuse_id_ = fuse_id;
  } else {
    clear_has_fuse_id();
    fuse_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateStorageTestFileRequest

// required int32 storage_id = 1;
inline bool CreateStorageTestFileRequest::has_storage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateStorageTestFileRequest::set_has_storage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateStorageTestFileRequest::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateStorageTestFileRequest::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 CreateStorageTestFileRequest::storage_id() const {
  return storage_id_;
}
inline void CreateStorageTestFileRequest::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
}

// -------------------------------------------------------------------

// CreateStorageTestFileResponse

// required bool answer = 1;
inline bool CreateStorageTestFileResponse::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateStorageTestFileResponse::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateStorageTestFileResponse::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateStorageTestFileResponse::clear_answer() {
  answer_ = false;
  clear_has_answer();
}
inline bool CreateStorageTestFileResponse::answer() const {
  return answer_;
}
inline void CreateStorageTestFileResponse::set_answer(bool value) {
  set_has_answer();
  answer_ = value;
}

// optional string relative_path = 2 [default = ""];
inline bool CreateStorageTestFileResponse::has_relative_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateStorageTestFileResponse::set_has_relative_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateStorageTestFileResponse::clear_has_relative_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateStorageTestFileResponse::clear_relative_path() {
  if (relative_path_ != &::google::protobuf::internal::kEmptyString) {
    relative_path_->clear();
  }
  clear_has_relative_path();
}
inline const ::std::string& CreateStorageTestFileResponse::relative_path() const {
  return *relative_path_;
}
inline void CreateStorageTestFileResponse::set_relative_path(const ::std::string& value) {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  relative_path_->assign(value);
}
inline void CreateStorageTestFileResponse::set_relative_path(const char* value) {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  relative_path_->assign(value);
}
inline void CreateStorageTestFileResponse::set_relative_path(const char* value, size_t size) {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  relative_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateStorageTestFileResponse::mutable_relative_path() {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  return relative_path_;
}
inline ::std::string* CreateStorageTestFileResponse::release_relative_path() {
  clear_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relative_path_;
    relative_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateStorageTestFileResponse::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path_ != &::google::protobuf::internal::kEmptyString) {
    delete relative_path_;
  }
  if (relative_path) {
    set_has_relative_path();
    relative_path_ = relative_path;
  } else {
    clear_has_relative_path();
    relative_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 3 [default = ""];
inline bool CreateStorageTestFileResponse::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateStorageTestFileResponse::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateStorageTestFileResponse::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateStorageTestFileResponse::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& CreateStorageTestFileResponse::text() const {
  return *text_;
}
inline void CreateStorageTestFileResponse::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void CreateStorageTestFileResponse::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void CreateStorageTestFileResponse::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateStorageTestFileResponse::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* CreateStorageTestFileResponse::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateStorageTestFileResponse::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StorageTestFileModifiedRequest

// required int32 storage_id = 1;
inline bool StorageTestFileModifiedRequest::has_storage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageTestFileModifiedRequest::set_has_storage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageTestFileModifiedRequest::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageTestFileModifiedRequest::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 StorageTestFileModifiedRequest::storage_id() const {
  return storage_id_;
}
inline void StorageTestFileModifiedRequest::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
}

// required string relative_path = 2;
inline bool StorageTestFileModifiedRequest::has_relative_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageTestFileModifiedRequest::set_has_relative_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageTestFileModifiedRequest::clear_has_relative_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageTestFileModifiedRequest::clear_relative_path() {
  if (relative_path_ != &::google::protobuf::internal::kEmptyString) {
    relative_path_->clear();
  }
  clear_has_relative_path();
}
inline const ::std::string& StorageTestFileModifiedRequest::relative_path() const {
  return *relative_path_;
}
inline void StorageTestFileModifiedRequest::set_relative_path(const ::std::string& value) {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  relative_path_->assign(value);
}
inline void StorageTestFileModifiedRequest::set_relative_path(const char* value) {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  relative_path_->assign(value);
}
inline void StorageTestFileModifiedRequest::set_relative_path(const char* value, size_t size) {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  relative_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorageTestFileModifiedRequest::mutable_relative_path() {
  set_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    relative_path_ = new ::std::string;
  }
  return relative_path_;
}
inline ::std::string* StorageTestFileModifiedRequest::release_relative_path() {
  clear_has_relative_path();
  if (relative_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relative_path_;
    relative_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StorageTestFileModifiedRequest::set_allocated_relative_path(::std::string* relative_path) {
  if (relative_path_ != &::google::protobuf::internal::kEmptyString) {
    delete relative_path_;
  }
  if (relative_path) {
    set_has_relative_path();
    relative_path_ = relative_path;
  } else {
    clear_has_relative_path();
    relative_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string text = 3;
inline bool StorageTestFileModifiedRequest::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageTestFileModifiedRequest::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageTestFileModifiedRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageTestFileModifiedRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& StorageTestFileModifiedRequest::text() const {
  return *text_;
}
inline void StorageTestFileModifiedRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void StorageTestFileModifiedRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void StorageTestFileModifiedRequest::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorageTestFileModifiedRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* StorageTestFileModifiedRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StorageTestFileModifiedRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StorageTestFileModifiedResponse

// required bool answer = 1;
inline bool StorageTestFileModifiedResponse::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageTestFileModifiedResponse::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageTestFileModifiedResponse::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageTestFileModifiedResponse::clear_answer() {
  answer_ = false;
  clear_has_answer();
}
inline bool StorageTestFileModifiedResponse::answer() const {
  return answer_;
}
inline void StorageTestFileModifiedResponse::set_answer(bool value) {
  set_has_answer();
  answer_ = value;
}

// -------------------------------------------------------------------

// ClientStorageInfo_StorageInfo

// required int32 storage_id = 1;
inline bool ClientStorageInfo_StorageInfo::has_storage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStorageInfo_StorageInfo::set_has_storage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStorageInfo_StorageInfo::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStorageInfo_StorageInfo::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 ClientStorageInfo_StorageInfo::storage_id() const {
  return storage_id_;
}
inline void ClientStorageInfo_StorageInfo::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
}

// required string absolute_path = 2;
inline bool ClientStorageInfo_StorageInfo::has_absolute_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientStorageInfo_StorageInfo::set_has_absolute_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientStorageInfo_StorageInfo::clear_has_absolute_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientStorageInfo_StorageInfo::clear_absolute_path() {
  if (absolute_path_ != &::google::protobuf::internal::kEmptyString) {
    absolute_path_->clear();
  }
  clear_has_absolute_path();
}
inline const ::std::string& ClientStorageInfo_StorageInfo::absolute_path() const {
  return *absolute_path_;
}
inline void ClientStorageInfo_StorageInfo::set_absolute_path(const ::std::string& value) {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  absolute_path_->assign(value);
}
inline void ClientStorageInfo_StorageInfo::set_absolute_path(const char* value) {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  absolute_path_->assign(value);
}
inline void ClientStorageInfo_StorageInfo::set_absolute_path(const char* value, size_t size) {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  absolute_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientStorageInfo_StorageInfo::mutable_absolute_path() {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  return absolute_path_;
}
inline ::std::string* ClientStorageInfo_StorageInfo::release_absolute_path() {
  clear_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = absolute_path_;
    absolute_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientStorageInfo_StorageInfo::set_allocated_absolute_path(::std::string* absolute_path) {
  if (absolute_path_ != &::google::protobuf::internal::kEmptyString) {
    delete absolute_path_;
  }
  if (absolute_path) {
    set_has_absolute_path();
    absolute_path_ = absolute_path;
  } else {
    clear_has_absolute_path();
    absolute_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientStorageInfo

// repeated .veil.protocol.fuse_messages.ClientStorageInfo.StorageInfo storage_info = 1;
inline int ClientStorageInfo::storage_info_size() const {
  return storage_info_.size();
}
inline void ClientStorageInfo::clear_storage_info() {
  storage_info_.Clear();
}
inline const ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo& ClientStorageInfo::storage_info(int index) const {
  return storage_info_.Get(index);
}
inline ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo* ClientStorageInfo::mutable_storage_info(int index) {
  return storage_info_.Mutable(index);
}
inline ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo* ClientStorageInfo::add_storage_info() {
  return storage_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo >&
ClientStorageInfo::storage_info() const {
  return storage_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::ClientStorageInfo_StorageInfo >*
ClientStorageInfo::mutable_storage_info() {
  return &storage_info_;
}

// -------------------------------------------------------------------

// GetStatFS

// -------------------------------------------------------------------

// StatFSInfo

// optional string answer = 1 [default = "ok"];
inline bool StatFSInfo::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatFSInfo::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatFSInfo::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatFSInfo::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& StatFSInfo::answer() const {
  return *answer_;
}
inline void StatFSInfo::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void StatFSInfo::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void StatFSInfo::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatFSInfo::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* StatFSInfo::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void StatFSInfo::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// required int64 quota_size = 2;
inline bool StatFSInfo::has_quota_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatFSInfo::set_has_quota_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatFSInfo::clear_has_quota_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatFSInfo::clear_quota_size() {
  quota_size_ = GOOGLE_LONGLONG(0);
  clear_has_quota_size();
}
inline ::google::protobuf::int64 StatFSInfo::quota_size() const {
  return quota_size_;
}
inline void StatFSInfo::set_quota_size(::google::protobuf::int64 value) {
  set_has_quota_size();
  quota_size_ = value;
}

// required int64 files_size = 3;
inline bool StatFSInfo::has_files_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatFSInfo::set_has_files_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatFSInfo::clear_has_files_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatFSInfo::clear_files_size() {
  files_size_ = GOOGLE_LONGLONG(0);
  clear_has_files_size();
}
inline ::google::protobuf::int64 StatFSInfo::files_size() const {
  return files_size_;
}
inline void StatFSInfo::set_files_size(::google::protobuf::int64 value) {
  set_has_files_size();
  files_size_ = value;
}

// -------------------------------------------------------------------

// EventFilterConfig

// required string field_name = 1;
inline bool EventFilterConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventFilterConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventFilterConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventFilterConfig::clear_field_name() {
  if (field_name_ != &::google::protobuf::internal::kEmptyString) {
    field_name_->clear();
  }
  clear_has_field_name();
}
inline const ::std::string& EventFilterConfig::field_name() const {
  return *field_name_;
}
inline void EventFilterConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void EventFilterConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void EventFilterConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventFilterConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  return field_name_;
}
inline ::std::string* EventFilterConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventFilterConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != &::google::protobuf::internal::kEmptyString) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string desired_value = 2;
inline bool EventFilterConfig::has_desired_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventFilterConfig::set_has_desired_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventFilterConfig::clear_has_desired_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventFilterConfig::clear_desired_value() {
  if (desired_value_ != &::google::protobuf::internal::kEmptyString) {
    desired_value_->clear();
  }
  clear_has_desired_value();
}
inline const ::std::string& EventFilterConfig::desired_value() const {
  return *desired_value_;
}
inline void EventFilterConfig::set_desired_value(const ::std::string& value) {
  set_has_desired_value();
  if (desired_value_ == &::google::protobuf::internal::kEmptyString) {
    desired_value_ = new ::std::string;
  }
  desired_value_->assign(value);
}
inline void EventFilterConfig::set_desired_value(const char* value) {
  set_has_desired_value();
  if (desired_value_ == &::google::protobuf::internal::kEmptyString) {
    desired_value_ = new ::std::string;
  }
  desired_value_->assign(value);
}
inline void EventFilterConfig::set_desired_value(const char* value, size_t size) {
  set_has_desired_value();
  if (desired_value_ == &::google::protobuf::internal::kEmptyString) {
    desired_value_ = new ::std::string;
  }
  desired_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventFilterConfig::mutable_desired_value() {
  set_has_desired_value();
  if (desired_value_ == &::google::protobuf::internal::kEmptyString) {
    desired_value_ = new ::std::string;
  }
  return desired_value_;
}
inline ::std::string* EventFilterConfig::release_desired_value() {
  clear_has_desired_value();
  if (desired_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desired_value_;
    desired_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventFilterConfig::set_allocated_desired_value(::std::string* desired_value) {
  if (desired_value_ != &::google::protobuf::internal::kEmptyString) {
    delete desired_value_;
  }
  if (desired_value) {
    set_has_desired_value();
    desired_value_ = desired_value;
  } else {
    clear_has_desired_value();
    desired_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EventAggregatorConfig

// required string field_name = 1;
inline bool EventAggregatorConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventAggregatorConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventAggregatorConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventAggregatorConfig::clear_field_name() {
  if (field_name_ != &::google::protobuf::internal::kEmptyString) {
    field_name_->clear();
  }
  clear_has_field_name();
}
inline const ::std::string& EventAggregatorConfig::field_name() const {
  return *field_name_;
}
inline void EventAggregatorConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void EventAggregatorConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void EventAggregatorConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventAggregatorConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    field_name_ = new ::std::string;
  }
  return field_name_;
}
inline ::std::string* EventAggregatorConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventAggregatorConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != &::google::protobuf::internal::kEmptyString) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 threshold = 2;
inline bool EventAggregatorConfig::has_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventAggregatorConfig::set_has_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventAggregatorConfig::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventAggregatorConfig::clear_threshold() {
  threshold_ = GOOGLE_ULONGLONG(0);
  clear_has_threshold();
}
inline ::google::protobuf::uint64 EventAggregatorConfig::threshold() const {
  return threshold_;
}
inline void EventAggregatorConfig::set_threshold(::google::protobuf::uint64 value) {
  set_has_threshold();
  threshold_ = value;
}

// required string sum_field_name = 3;
inline bool EventAggregatorConfig::has_sum_field_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventAggregatorConfig::set_has_sum_field_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventAggregatorConfig::clear_has_sum_field_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventAggregatorConfig::clear_sum_field_name() {
  if (sum_field_name_ != &::google::protobuf::internal::kEmptyString) {
    sum_field_name_->clear();
  }
  clear_has_sum_field_name();
}
inline const ::std::string& EventAggregatorConfig::sum_field_name() const {
  return *sum_field_name_;
}
inline void EventAggregatorConfig::set_sum_field_name(const ::std::string& value) {
  set_has_sum_field_name();
  if (sum_field_name_ == &::google::protobuf::internal::kEmptyString) {
    sum_field_name_ = new ::std::string;
  }
  sum_field_name_->assign(value);
}
inline void EventAggregatorConfig::set_sum_field_name(const char* value) {
  set_has_sum_field_name();
  if (sum_field_name_ == &::google::protobuf::internal::kEmptyString) {
    sum_field_name_ = new ::std::string;
  }
  sum_field_name_->assign(value);
}
inline void EventAggregatorConfig::set_sum_field_name(const char* value, size_t size) {
  set_has_sum_field_name();
  if (sum_field_name_ == &::google::protobuf::internal::kEmptyString) {
    sum_field_name_ = new ::std::string;
  }
  sum_field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventAggregatorConfig::mutable_sum_field_name() {
  set_has_sum_field_name();
  if (sum_field_name_ == &::google::protobuf::internal::kEmptyString) {
    sum_field_name_ = new ::std::string;
  }
  return sum_field_name_;
}
inline ::std::string* EventAggregatorConfig::release_sum_field_name() {
  clear_has_sum_field_name();
  if (sum_field_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sum_field_name_;
    sum_field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventAggregatorConfig::set_allocated_sum_field_name(::std::string* sum_field_name) {
  if (sum_field_name_ != &::google::protobuf::internal::kEmptyString) {
    delete sum_field_name_;
  }
  if (sum_field_name) {
    set_has_sum_field_name();
    sum_field_name_ = sum_field_name;
  } else {
    clear_has_sum_field_name();
    sum_field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EventTransformerConfig

// repeated string field_names_to_replace = 1;
inline int EventTransformerConfig::field_names_to_replace_size() const {
  return field_names_to_replace_.size();
}
inline void EventTransformerConfig::clear_field_names_to_replace() {
  field_names_to_replace_.Clear();
}
inline const ::std::string& EventTransformerConfig::field_names_to_replace(int index) const {
  return field_names_to_replace_.Get(index);
}
inline ::std::string* EventTransformerConfig::mutable_field_names_to_replace(int index) {
  return field_names_to_replace_.Mutable(index);
}
inline void EventTransformerConfig::set_field_names_to_replace(int index, const ::std::string& value) {
  field_names_to_replace_.Mutable(index)->assign(value);
}
inline void EventTransformerConfig::set_field_names_to_replace(int index, const char* value) {
  field_names_to_replace_.Mutable(index)->assign(value);
}
inline void EventTransformerConfig::set_field_names_to_replace(int index, const char* value, size_t size) {
  field_names_to_replace_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventTransformerConfig::add_field_names_to_replace() {
  return field_names_to_replace_.Add();
}
inline void EventTransformerConfig::add_field_names_to_replace(const ::std::string& value) {
  field_names_to_replace_.Add()->assign(value);
}
inline void EventTransformerConfig::add_field_names_to_replace(const char* value) {
  field_names_to_replace_.Add()->assign(value);
}
inline void EventTransformerConfig::add_field_names_to_replace(const char* value, size_t size) {
  field_names_to_replace_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventTransformerConfig::field_names_to_replace() const {
  return field_names_to_replace_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventTransformerConfig::mutable_field_names_to_replace() {
  return &field_names_to_replace_;
}

// repeated string values_to_replace = 2;
inline int EventTransformerConfig::values_to_replace_size() const {
  return values_to_replace_.size();
}
inline void EventTransformerConfig::clear_values_to_replace() {
  values_to_replace_.Clear();
}
inline const ::std::string& EventTransformerConfig::values_to_replace(int index) const {
  return values_to_replace_.Get(index);
}
inline ::std::string* EventTransformerConfig::mutable_values_to_replace(int index) {
  return values_to_replace_.Mutable(index);
}
inline void EventTransformerConfig::set_values_to_replace(int index, const ::std::string& value) {
  values_to_replace_.Mutable(index)->assign(value);
}
inline void EventTransformerConfig::set_values_to_replace(int index, const char* value) {
  values_to_replace_.Mutable(index)->assign(value);
}
inline void EventTransformerConfig::set_values_to_replace(int index, const char* value, size_t size) {
  values_to_replace_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventTransformerConfig::add_values_to_replace() {
  return values_to_replace_.Add();
}
inline void EventTransformerConfig::add_values_to_replace(const ::std::string& value) {
  values_to_replace_.Add()->assign(value);
}
inline void EventTransformerConfig::add_values_to_replace(const char* value) {
  values_to_replace_.Add()->assign(value);
}
inline void EventTransformerConfig::add_values_to_replace(const char* value, size_t size) {
  values_to_replace_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventTransformerConfig::values_to_replace() const {
  return values_to_replace_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventTransformerConfig::mutable_values_to_replace() {
  return &values_to_replace_;
}

// repeated string new_values = 3;
inline int EventTransformerConfig::new_values_size() const {
  return new_values_.size();
}
inline void EventTransformerConfig::clear_new_values() {
  new_values_.Clear();
}
inline const ::std::string& EventTransformerConfig::new_values(int index) const {
  return new_values_.Get(index);
}
inline ::std::string* EventTransformerConfig::mutable_new_values(int index) {
  return new_values_.Mutable(index);
}
inline void EventTransformerConfig::set_new_values(int index, const ::std::string& value) {
  new_values_.Mutable(index)->assign(value);
}
inline void EventTransformerConfig::set_new_values(int index, const char* value) {
  new_values_.Mutable(index)->assign(value);
}
inline void EventTransformerConfig::set_new_values(int index, const char* value, size_t size) {
  new_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventTransformerConfig::add_new_values() {
  return new_values_.Add();
}
inline void EventTransformerConfig::add_new_values(const ::std::string& value) {
  new_values_.Add()->assign(value);
}
inline void EventTransformerConfig::add_new_values(const char* value) {
  new_values_.Add()->assign(value);
}
inline void EventTransformerConfig::add_new_values(const char* value, size_t size) {
  new_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventTransformerConfig::new_values() const {
  return new_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventTransformerConfig::mutable_new_values() {
  return &new_values_;
}

// -------------------------------------------------------------------

// EventStreamConfig

// optional .veil.protocol.fuse_messages.EventStreamConfig wrapped_config = 1;
inline bool EventStreamConfig::has_wrapped_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventStreamConfig::set_has_wrapped_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventStreamConfig::clear_has_wrapped_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventStreamConfig::clear_wrapped_config() {
  if (wrapped_config_ != NULL) wrapped_config_->::veil::protocol::fuse_messages::EventStreamConfig::Clear();
  clear_has_wrapped_config();
}
inline const ::veil::protocol::fuse_messages::EventStreamConfig& EventStreamConfig::wrapped_config() const {
  return wrapped_config_ != NULL ? *wrapped_config_ : *default_instance_->wrapped_config_;
}
inline ::veil::protocol::fuse_messages::EventStreamConfig* EventStreamConfig::mutable_wrapped_config() {
  set_has_wrapped_config();
  if (wrapped_config_ == NULL) wrapped_config_ = new ::veil::protocol::fuse_messages::EventStreamConfig;
  return wrapped_config_;
}
inline ::veil::protocol::fuse_messages::EventStreamConfig* EventStreamConfig::release_wrapped_config() {
  clear_has_wrapped_config();
  ::veil::protocol::fuse_messages::EventStreamConfig* temp = wrapped_config_;
  wrapped_config_ = NULL;
  return temp;
}
inline void EventStreamConfig::set_allocated_wrapped_config(::veil::protocol::fuse_messages::EventStreamConfig* wrapped_config) {
  delete wrapped_config_;
  wrapped_config_ = wrapped_config;
  if (wrapped_config) {
    set_has_wrapped_config();
  } else {
    clear_has_wrapped_config();
  }
}

// optional .veil.protocol.fuse_messages.EventFilterConfig filter_config = 2;
inline bool EventStreamConfig::has_filter_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventStreamConfig::set_has_filter_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventStreamConfig::clear_has_filter_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventStreamConfig::clear_filter_config() {
  if (filter_config_ != NULL) filter_config_->::veil::protocol::fuse_messages::EventFilterConfig::Clear();
  clear_has_filter_config();
}
inline const ::veil::protocol::fuse_messages::EventFilterConfig& EventStreamConfig::filter_config() const {
  return filter_config_ != NULL ? *filter_config_ : *default_instance_->filter_config_;
}
inline ::veil::protocol::fuse_messages::EventFilterConfig* EventStreamConfig::mutable_filter_config() {
  set_has_filter_config();
  if (filter_config_ == NULL) filter_config_ = new ::veil::protocol::fuse_messages::EventFilterConfig;
  return filter_config_;
}
inline ::veil::protocol::fuse_messages::EventFilterConfig* EventStreamConfig::release_filter_config() {
  clear_has_filter_config();
  ::veil::protocol::fuse_messages::EventFilterConfig* temp = filter_config_;
  filter_config_ = NULL;
  return temp;
}
inline void EventStreamConfig::set_allocated_filter_config(::veil::protocol::fuse_messages::EventFilterConfig* filter_config) {
  delete filter_config_;
  filter_config_ = filter_config;
  if (filter_config) {
    set_has_filter_config();
  } else {
    clear_has_filter_config();
  }
}

// optional .veil.protocol.fuse_messages.EventAggregatorConfig aggregator_config = 3;
inline bool EventStreamConfig::has_aggregator_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventStreamConfig::set_has_aggregator_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventStreamConfig::clear_has_aggregator_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventStreamConfig::clear_aggregator_config() {
  if (aggregator_config_ != NULL) aggregator_config_->::veil::protocol::fuse_messages::EventAggregatorConfig::Clear();
  clear_has_aggregator_config();
}
inline const ::veil::protocol::fuse_messages::EventAggregatorConfig& EventStreamConfig::aggregator_config() const {
  return aggregator_config_ != NULL ? *aggregator_config_ : *default_instance_->aggregator_config_;
}
inline ::veil::protocol::fuse_messages::EventAggregatorConfig* EventStreamConfig::mutable_aggregator_config() {
  set_has_aggregator_config();
  if (aggregator_config_ == NULL) aggregator_config_ = new ::veil::protocol::fuse_messages::EventAggregatorConfig;
  return aggregator_config_;
}
inline ::veil::protocol::fuse_messages::EventAggregatorConfig* EventStreamConfig::release_aggregator_config() {
  clear_has_aggregator_config();
  ::veil::protocol::fuse_messages::EventAggregatorConfig* temp = aggregator_config_;
  aggregator_config_ = NULL;
  return temp;
}
inline void EventStreamConfig::set_allocated_aggregator_config(::veil::protocol::fuse_messages::EventAggregatorConfig* aggregator_config) {
  delete aggregator_config_;
  aggregator_config_ = aggregator_config;
  if (aggregator_config) {
    set_has_aggregator_config();
  } else {
    clear_has_aggregator_config();
  }
}

// optional .veil.protocol.fuse_messages.EventTransformerConfig transformer_config = 4;
inline bool EventStreamConfig::has_transformer_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventStreamConfig::set_has_transformer_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventStreamConfig::clear_has_transformer_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventStreamConfig::clear_transformer_config() {
  if (transformer_config_ != NULL) transformer_config_->::veil::protocol::fuse_messages::EventTransformerConfig::Clear();
  clear_has_transformer_config();
}
inline const ::veil::protocol::fuse_messages::EventTransformerConfig& EventStreamConfig::transformer_config() const {
  return transformer_config_ != NULL ? *transformer_config_ : *default_instance_->transformer_config_;
}
inline ::veil::protocol::fuse_messages::EventTransformerConfig* EventStreamConfig::mutable_transformer_config() {
  set_has_transformer_config();
  if (transformer_config_ == NULL) transformer_config_ = new ::veil::protocol::fuse_messages::EventTransformerConfig;
  return transformer_config_;
}
inline ::veil::protocol::fuse_messages::EventTransformerConfig* EventStreamConfig::release_transformer_config() {
  clear_has_transformer_config();
  ::veil::protocol::fuse_messages::EventTransformerConfig* temp = transformer_config_;
  transformer_config_ = NULL;
  return temp;
}
inline void EventStreamConfig::set_allocated_transformer_config(::veil::protocol::fuse_messages::EventTransformerConfig* transformer_config) {
  delete transformer_config_;
  transformer_config_ = transformer_config;
  if (transformer_config) {
    set_has_transformer_config();
  } else {
    clear_has_transformer_config();
  }
}

// repeated string needed_envs = 5;
inline int EventStreamConfig::needed_envs_size() const {
  return needed_envs_.size();
}
inline void EventStreamConfig::clear_needed_envs() {
  needed_envs_.Clear();
}
inline const ::std::string& EventStreamConfig::needed_envs(int index) const {
  return needed_envs_.Get(index);
}
inline ::std::string* EventStreamConfig::mutable_needed_envs(int index) {
  return needed_envs_.Mutable(index);
}
inline void EventStreamConfig::set_needed_envs(int index, const ::std::string& value) {
  needed_envs_.Mutable(index)->assign(value);
}
inline void EventStreamConfig::set_needed_envs(int index, const char* value) {
  needed_envs_.Mutable(index)->assign(value);
}
inline void EventStreamConfig::set_needed_envs(int index, const char* value, size_t size) {
  needed_envs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventStreamConfig::add_needed_envs() {
  return needed_envs_.Add();
}
inline void EventStreamConfig::add_needed_envs(const ::std::string& value) {
  needed_envs_.Add()->assign(value);
}
inline void EventStreamConfig::add_needed_envs(const char* value) {
  needed_envs_.Add()->assign(value);
}
inline void EventStreamConfig::add_needed_envs(const char* value, size_t size) {
  needed_envs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventStreamConfig::needed_envs() const {
  return needed_envs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventStreamConfig::mutable_needed_envs() {
  return &needed_envs_;
}

// -------------------------------------------------------------------

// EventProducerConfig

// repeated .veil.protocol.fuse_messages.EventStreamConfig event_streams_configs = 1;
inline int EventProducerConfig::event_streams_configs_size() const {
  return event_streams_configs_.size();
}
inline void EventProducerConfig::clear_event_streams_configs() {
  event_streams_configs_.Clear();
}
inline const ::veil::protocol::fuse_messages::EventStreamConfig& EventProducerConfig::event_streams_configs(int index) const {
  return event_streams_configs_.Get(index);
}
inline ::veil::protocol::fuse_messages::EventStreamConfig* EventProducerConfig::mutable_event_streams_configs(int index) {
  return event_streams_configs_.Mutable(index);
}
inline ::veil::protocol::fuse_messages::EventStreamConfig* EventProducerConfig::add_event_streams_configs() {
  return event_streams_configs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::EventStreamConfig >&
EventProducerConfig::event_streams_configs() const {
  return event_streams_configs_;
}
inline ::google::protobuf::RepeatedPtrField< ::veil::protocol::fuse_messages::EventStreamConfig >*
EventProducerConfig::mutable_event_streams_configs() {
  return &event_streams_configs_;
}

// -------------------------------------------------------------------

// EventMessage

// repeated string numeric_properties_keys = 1;
inline int EventMessage::numeric_properties_keys_size() const {
  return numeric_properties_keys_.size();
}
inline void EventMessage::clear_numeric_properties_keys() {
  numeric_properties_keys_.Clear();
}
inline const ::std::string& EventMessage::numeric_properties_keys(int index) const {
  return numeric_properties_keys_.Get(index);
}
inline ::std::string* EventMessage::mutable_numeric_properties_keys(int index) {
  return numeric_properties_keys_.Mutable(index);
}
inline void EventMessage::set_numeric_properties_keys(int index, const ::std::string& value) {
  numeric_properties_keys_.Mutable(index)->assign(value);
}
inline void EventMessage::set_numeric_properties_keys(int index, const char* value) {
  numeric_properties_keys_.Mutable(index)->assign(value);
}
inline void EventMessage::set_numeric_properties_keys(int index, const char* value, size_t size) {
  numeric_properties_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventMessage::add_numeric_properties_keys() {
  return numeric_properties_keys_.Add();
}
inline void EventMessage::add_numeric_properties_keys(const ::std::string& value) {
  numeric_properties_keys_.Add()->assign(value);
}
inline void EventMessage::add_numeric_properties_keys(const char* value) {
  numeric_properties_keys_.Add()->assign(value);
}
inline void EventMessage::add_numeric_properties_keys(const char* value, size_t size) {
  numeric_properties_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventMessage::numeric_properties_keys() const {
  return numeric_properties_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventMessage::mutable_numeric_properties_keys() {
  return &numeric_properties_keys_;
}

// repeated int64 numeric_properties_values = 2;
inline int EventMessage::numeric_properties_values_size() const {
  return numeric_properties_values_.size();
}
inline void EventMessage::clear_numeric_properties_values() {
  numeric_properties_values_.Clear();
}
inline ::google::protobuf::int64 EventMessage::numeric_properties_values(int index) const {
  return numeric_properties_values_.Get(index);
}
inline void EventMessage::set_numeric_properties_values(int index, ::google::protobuf::int64 value) {
  numeric_properties_values_.Set(index, value);
}
inline void EventMessage::add_numeric_properties_values(::google::protobuf::int64 value) {
  numeric_properties_values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
EventMessage::numeric_properties_values() const {
  return numeric_properties_values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
EventMessage::mutable_numeric_properties_values() {
  return &numeric_properties_values_;
}

// repeated string string_properties_keys = 3;
inline int EventMessage::string_properties_keys_size() const {
  return string_properties_keys_.size();
}
inline void EventMessage::clear_string_properties_keys() {
  string_properties_keys_.Clear();
}
inline const ::std::string& EventMessage::string_properties_keys(int index) const {
  return string_properties_keys_.Get(index);
}
inline ::std::string* EventMessage::mutable_string_properties_keys(int index) {
  return string_properties_keys_.Mutable(index);
}
inline void EventMessage::set_string_properties_keys(int index, const ::std::string& value) {
  string_properties_keys_.Mutable(index)->assign(value);
}
inline void EventMessage::set_string_properties_keys(int index, const char* value) {
  string_properties_keys_.Mutable(index)->assign(value);
}
inline void EventMessage::set_string_properties_keys(int index, const char* value, size_t size) {
  string_properties_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventMessage::add_string_properties_keys() {
  return string_properties_keys_.Add();
}
inline void EventMessage::add_string_properties_keys(const ::std::string& value) {
  string_properties_keys_.Add()->assign(value);
}
inline void EventMessage::add_string_properties_keys(const char* value) {
  string_properties_keys_.Add()->assign(value);
}
inline void EventMessage::add_string_properties_keys(const char* value, size_t size) {
  string_properties_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventMessage::string_properties_keys() const {
  return string_properties_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventMessage::mutable_string_properties_keys() {
  return &string_properties_keys_;
}

// repeated string string_properties_values = 4;
inline int EventMessage::string_properties_values_size() const {
  return string_properties_values_.size();
}
inline void EventMessage::clear_string_properties_values() {
  string_properties_values_.Clear();
}
inline const ::std::string& EventMessage::string_properties_values(int index) const {
  return string_properties_values_.Get(index);
}
inline ::std::string* EventMessage::mutable_string_properties_values(int index) {
  return string_properties_values_.Mutable(index);
}
inline void EventMessage::set_string_properties_values(int index, const ::std::string& value) {
  string_properties_values_.Mutable(index)->assign(value);
}
inline void EventMessage::set_string_properties_values(int index, const char* value) {
  string_properties_values_.Mutable(index)->assign(value);
}
inline void EventMessage::set_string_properties_values(int index, const char* value, size_t size) {
  string_properties_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventMessage::add_string_properties_values() {
  return string_properties_values_.Add();
}
inline void EventMessage::add_string_properties_values(const ::std::string& value) {
  string_properties_values_.Add()->assign(value);
}
inline void EventMessage::add_string_properties_values(const char* value) {
  string_properties_values_.Add()->assign(value);
}
inline void EventMessage::add_string_properties_values(const char* value, size_t size) {
  string_properties_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventMessage::string_properties_values() const {
  return string_properties_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventMessage::mutable_string_properties_values() {
  return &string_properties_values_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fuse_messages
}  // namespace protocol
}  // namespace veil

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fuse_5fmessages_2eproto__INCLUDED
