// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote_file_management.proto

#ifndef PROTOBUF_remote_5ffile_5fmanagement_2eproto__INCLUDED
#define PROTOBUF_remote_5ffile_5fmanagement_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace veil {
namespace protocol {
namespace remote_file_management {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

class RemoteFileMangement;
class GetAttr;
class StorageAttibutes;
class CreateFile;
class DeleteFileAtStorage;
class TruncateFile;
class ReadFile;
class FileData;
class WriteFile;
class WriteInfo;
class ChangePermsAtStorage;

// ===================================================================

class RemoteFileMangement : public ::google::protobuf::Message {
 public:
  RemoteFileMangement();
  virtual ~RemoteFileMangement();

  RemoteFileMangement(const RemoteFileMangement& from);

  inline RemoteFileMangement& operator=(const RemoteFileMangement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteFileMangement& default_instance();

  void Swap(RemoteFileMangement* other);

  // implements Message ----------------------------------------------

  RemoteFileMangement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteFileMangement& from);
  void MergeFrom(const RemoteFileMangement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline const ::std::string& message_type() const;
  inline void set_message_type(const ::std::string& value);
  inline void set_message_type(const char* value);
  inline void set_message_type(const char* value, size_t size);
  inline ::std::string* mutable_message_type();
  inline ::std::string* release_message_type();
  inline void set_allocated_message_type(::std::string* message_type);

  // required bytes input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::std::string& input() const;
  inline void set_input(const ::std::string& value);
  inline void set_input(const char* value);
  inline void set_input(const void* value, size_t size);
  inline ::std::string* mutable_input();
  inline ::std::string* release_input();
  inline void set_allocated_input(::std::string* input);

  // optional string space_id = 3 [default = ""];
  inline bool has_space_id() const;
  inline void clear_space_id();
  static const int kSpaceIdFieldNumber = 3;
  inline const ::std::string& space_id() const;
  inline void set_space_id(const ::std::string& value);
  inline void set_space_id(const char* value);
  inline void set_space_id(const char* value, size_t size);
  inline ::std::string* mutable_space_id();
  inline ::std::string* release_space_id();
  inline void set_allocated_space_id(::std::string* space_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.RemoteFileMangement)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_space_id();
  inline void clear_has_space_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_type_;
  ::std::string* input_;
  ::std::string* space_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static RemoteFileMangement* default_instance_;
};
// -------------------------------------------------------------------

class GetAttr : public ::google::protobuf::Message {
 public:
  GetAttr();
  virtual ~GetAttr();

  GetAttr(const GetAttr& from);

  inline GetAttr& operator=(const GetAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAttr& default_instance();

  void Swap(GetAttr* other);

  // implements Message ----------------------------------------------

  GetAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAttr& from);
  void MergeFrom(const GetAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.GetAttr)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static GetAttr* default_instance_;
};
// -------------------------------------------------------------------

class StorageAttibutes : public ::google::protobuf::Message {
 public:
  StorageAttibutes();
  virtual ~StorageAttibutes();

  StorageAttibutes(const StorageAttibutes& from);

  inline StorageAttibutes& operator=(const StorageAttibutes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageAttibutes& default_instance();

  void Swap(StorageAttibutes* other);

  // implements Message ----------------------------------------------

  StorageAttibutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageAttibutes& from);
  void MergeFrom(const StorageAttibutes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string answer = 1 [default = "ok"];
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline const ::std::string& answer() const;
  inline void set_answer(const ::std::string& value);
  inline void set_answer(const char* value);
  inline void set_answer(const char* value, size_t size);
  inline ::std::string* mutable_answer();
  inline ::std::string* release_answer();
  inline void set_allocated_answer(::std::string* answer);

  // optional int64 dev = 2 [default = 0];
  inline bool has_dev() const;
  inline void clear_dev();
  static const int kDevFieldNumber = 2;
  inline ::google::protobuf::int64 dev() const;
  inline void set_dev(::google::protobuf::int64 value);

  // optional int64 ino = 3 [default = 0];
  inline bool has_ino() const;
  inline void clear_ino();
  static const int kInoFieldNumber = 3;
  inline ::google::protobuf::int64 ino() const;
  inline void set_ino(::google::protobuf::int64 value);

  // optional int64 mode = 4 [default = 0];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::int64 mode() const;
  inline void set_mode(::google::protobuf::int64 value);

  // optional int64 nlink = 5 [default = 1];
  inline bool has_nlink() const;
  inline void clear_nlink();
  static const int kNlinkFieldNumber = 5;
  inline ::google::protobuf::int64 nlink() const;
  inline void set_nlink(::google::protobuf::int64 value);

  // optional int64 uid = 6 [default = 0];
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional int64 gid = 7 [default = 0];
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 7;
  inline ::google::protobuf::int64 gid() const;
  inline void set_gid(::google::protobuf::int64 value);

  // optional int64 rdev = 8 [default = 0];
  inline bool has_rdev() const;
  inline void clear_rdev();
  static const int kRdevFieldNumber = 8;
  inline ::google::protobuf::int64 rdev() const;
  inline void set_rdev(::google::protobuf::int64 value);

  // optional int64 size = 9 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // optional int64 blksize = 10 [default = 0];
  inline bool has_blksize() const;
  inline void clear_blksize();
  static const int kBlksizeFieldNumber = 10;
  inline ::google::protobuf::int64 blksize() const;
  inline void set_blksize(::google::protobuf::int64 value);

  // optional int64 blocks = 11 [default = 0];
  inline bool has_blocks() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 11;
  inline ::google::protobuf::int64 blocks() const;
  inline void set_blocks(::google::protobuf::int64 value);

  // optional int64 atime = 12 [default = 0];
  inline bool has_atime() const;
  inline void clear_atime();
  static const int kAtimeFieldNumber = 12;
  inline ::google::protobuf::int64 atime() const;
  inline void set_atime(::google::protobuf::int64 value);

  // optional int64 mtime = 13 [default = 0];
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 13;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);

  // optional int64 ctime = 14 [default = 0];
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 14;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.StorageAttibutes)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_dev();
  inline void clear_has_dev();
  inline void set_has_ino();
  inline void clear_has_ino();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_nlink();
  inline void clear_has_nlink();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_rdev();
  inline void clear_has_rdev();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_blksize();
  inline void clear_has_blksize();
  inline void set_has_blocks();
  inline void clear_has_blocks();
  inline void set_has_atime();
  inline void clear_has_atime();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_ctime();
  inline void clear_has_ctime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_;
  static ::std::string* _default_answer_;
  ::google::protobuf::int64 dev_;
  ::google::protobuf::int64 ino_;
  ::google::protobuf::int64 mode_;
  ::google::protobuf::int64 nlink_;
  ::google::protobuf::int64 uid_;
  ::google::protobuf::int64 gid_;
  ::google::protobuf::int64 rdev_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 blksize_;
  ::google::protobuf::int64 blocks_;
  ::google::protobuf::int64 atime_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int64 ctime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static StorageAttibutes* default_instance_;
};
// -------------------------------------------------------------------

class CreateFile : public ::google::protobuf::Message {
 public:
  CreateFile();
  virtual ~CreateFile();

  CreateFile(const CreateFile& from);

  inline CreateFile& operator=(const CreateFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateFile& default_instance();

  void Swap(CreateFile* other);

  // implements Message ----------------------------------------------

  CreateFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateFile& from);
  void MergeFrom(const CreateFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required uint32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.CreateFile)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::uint32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static CreateFile* default_instance_;
};
// -------------------------------------------------------------------

class DeleteFileAtStorage : public ::google::protobuf::Message {
 public:
  DeleteFileAtStorage();
  virtual ~DeleteFileAtStorage();

  DeleteFileAtStorage(const DeleteFileAtStorage& from);

  inline DeleteFileAtStorage& operator=(const DeleteFileAtStorage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteFileAtStorage& default_instance();

  void Swap(DeleteFileAtStorage* other);

  // implements Message ----------------------------------------------

  DeleteFileAtStorage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteFileAtStorage& from);
  void MergeFrom(const DeleteFileAtStorage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.DeleteFileAtStorage)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static DeleteFileAtStorage* default_instance_;
};
// -------------------------------------------------------------------

class TruncateFile : public ::google::protobuf::Message {
 public:
  TruncateFile();
  virtual ~TruncateFile();

  TruncateFile(const TruncateFile& from);

  inline TruncateFile& operator=(const TruncateFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateFile& default_instance();

  void Swap(TruncateFile* other);

  // implements Message ----------------------------------------------

  TruncateFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruncateFile& from);
  void MergeFrom(const TruncateFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int64 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int64 length() const;
  inline void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.TruncateFile)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::int64 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static TruncateFile* default_instance_;
};
// -------------------------------------------------------------------

class ReadFile : public ::google::protobuf::Message {
 public:
  ReadFile();
  virtual ~ReadFile();

  ReadFile(const ReadFile& from);

  inline ReadFile& operator=(const ReadFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadFile& default_instance();

  void Swap(ReadFile* other);

  // implements Message ----------------------------------------------

  ReadFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadFile& from);
  void MergeFrom(const ReadFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int64 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // optional int64 offset = 3 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.ReadFile)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static ReadFile* default_instance_;
};
// -------------------------------------------------------------------

class FileData : public ::google::protobuf::Message {
 public:
  FileData();
  virtual ~FileData();

  FileData(const FileData& from);

  inline FileData& operator=(const FileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileData& default_instance();

  void Swap(FileData* other);

  // implements Message ----------------------------------------------

  FileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileData& from);
  void MergeFrom(const FileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string answer_status = 1;
  inline bool has_answer_status() const;
  inline void clear_answer_status();
  static const int kAnswerStatusFieldNumber = 1;
  inline const ::std::string& answer_status() const;
  inline void set_answer_status(const ::std::string& value);
  inline void set_answer_status(const char* value);
  inline void set_answer_status(const char* value, size_t size);
  inline ::std::string* mutable_answer_status();
  inline ::std::string* release_answer_status();
  inline void set_allocated_answer_status(::std::string* answer_status);

  // optional string operation_guid = 2;
  inline bool has_operation_guid() const;
  inline void clear_operation_guid();
  static const int kOperationGuidFieldNumber = 2;
  inline const ::std::string& operation_guid() const;
  inline void set_operation_guid(const ::std::string& value);
  inline void set_operation_guid(const char* value);
  inline void set_operation_guid(const char* value, size_t size);
  inline ::std::string* mutable_operation_guid();
  inline ::std::string* release_operation_guid();
  inline void set_allocated_operation_guid(::std::string* operation_guid);

  // optional string new_data_source = 3;
  inline bool has_new_data_source() const;
  inline void clear_new_data_source();
  static const int kNewDataSourceFieldNumber = 3;
  inline const ::std::string& new_data_source() const;
  inline void set_new_data_source(const ::std::string& value);
  inline void set_new_data_source(const char* value);
  inline void set_new_data_source(const char* value, size_t size);
  inline ::std::string* mutable_new_data_source();
  inline ::std::string* release_new_data_source();
  inline void set_allocated_new_data_source(::std::string* new_data_source);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.FileData)
 private:
  inline void set_has_answer_status();
  inline void clear_has_answer_status();
  inline void set_has_operation_guid();
  inline void clear_has_operation_guid();
  inline void set_has_new_data_source();
  inline void clear_has_new_data_source();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_status_;
  ::std::string* operation_guid_;
  ::std::string* new_data_source_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static FileData* default_instance_;
};
// -------------------------------------------------------------------

class WriteFile : public ::google::protobuf::Message {
 public:
  WriteFile();
  virtual ~WriteFile();

  WriteFile(const WriteFile& from);

  inline WriteFile& operator=(const WriteFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteFile& default_instance();

  void Swap(WriteFile* other);

  // implements Message ----------------------------------------------

  WriteFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WriteFile& from);
  void MergeFrom(const WriteFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // optional int64 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int64 offset = 4 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.WriteFile)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::int64 size_;
  ::std::string* data_;
  ::google::protobuf::int64 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static WriteFile* default_instance_;
};
// -------------------------------------------------------------------

class WriteInfo : public ::google::protobuf::Message {
 public:
  WriteInfo();
  virtual ~WriteInfo();

  WriteInfo(const WriteInfo& from);

  inline WriteInfo& operator=(const WriteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteInfo& default_instance();

  void Swap(WriteInfo* other);

  // implements Message ----------------------------------------------

  WriteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WriteInfo& from);
  void MergeFrom(const WriteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string answer_status = 1;
  inline bool has_answer_status() const;
  inline void clear_answer_status();
  static const int kAnswerStatusFieldNumber = 1;
  inline const ::std::string& answer_status() const;
  inline void set_answer_status(const ::std::string& value);
  inline void set_answer_status(const char* value);
  inline void set_answer_status(const char* value, size_t size);
  inline ::std::string* mutable_answer_status();
  inline ::std::string* release_answer_status();
  inline void set_allocated_answer_status(::std::string* answer_status);

  // optional int64 bytes_written = 2 [default = 0];
  inline bool has_bytes_written() const;
  inline void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 2;
  inline ::google::protobuf::int64 bytes_written() const;
  inline void set_bytes_written(::google::protobuf::int64 value);

  // optional string operation_guid = 3;
  inline bool has_operation_guid() const;
  inline void clear_operation_guid();
  static const int kOperationGuidFieldNumber = 3;
  inline const ::std::string& operation_guid() const;
  inline void set_operation_guid(const ::std::string& value);
  inline void set_operation_guid(const char* value);
  inline void set_operation_guid(const char* value, size_t size);
  inline ::std::string* mutable_operation_guid();
  inline ::std::string* release_operation_guid();
  inline void set_allocated_operation_guid(::std::string* operation_guid);

  // optional string new_data_listener = 4;
  inline bool has_new_data_listener() const;
  inline void clear_new_data_listener();
  static const int kNewDataListenerFieldNumber = 4;
  inline const ::std::string& new_data_listener() const;
  inline void set_new_data_listener(const ::std::string& value);
  inline void set_new_data_listener(const char* value);
  inline void set_new_data_listener(const char* value, size_t size);
  inline ::std::string* mutable_new_data_listener();
  inline ::std::string* release_new_data_listener();
  inline void set_allocated_new_data_listener(::std::string* new_data_listener);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.WriteInfo)
 private:
  inline void set_has_answer_status();
  inline void clear_has_answer_status();
  inline void set_has_bytes_written();
  inline void clear_has_bytes_written();
  inline void set_has_operation_guid();
  inline void clear_has_operation_guid();
  inline void set_has_new_data_listener();
  inline void clear_has_new_data_listener();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* answer_status_;
  ::google::protobuf::int64 bytes_written_;
  ::std::string* operation_guid_;
  ::std::string* new_data_listener_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static WriteInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChangePermsAtStorage : public ::google::protobuf::Message {
 public:
  ChangePermsAtStorage();
  virtual ~ChangePermsAtStorage();

  ChangePermsAtStorage(const ChangePermsAtStorage& from);

  inline ChangePermsAtStorage& operator=(const ChangePermsAtStorage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePermsAtStorage& default_instance();

  void Swap(ChangePermsAtStorage* other);

  // implements Message ----------------------------------------------

  ChangePermsAtStorage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePermsAtStorage& from);
  void MergeFrom(const ChangePermsAtStorage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int32 perms = 2;
  inline bool has_perms() const;
  inline void clear_perms();
  static const int kPermsFieldNumber = 2;
  inline ::google::protobuf::int32 perms() const;
  inline void set_perms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:veil.protocol.remote_file_management.ChangePermsAtStorage)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_perms();
  inline void clear_has_perms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::int32 perms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_AssignDesc_remote_5ffile_5fmanagement_2eproto();
  friend void protobuf_ShutdownFile_remote_5ffile_5fmanagement_2eproto();

  void InitAsDefaultInstance();
  static ChangePermsAtStorage* default_instance_;
};
// ===================================================================


// ===================================================================

// RemoteFileMangement

// required string message_type = 1;
inline bool RemoteFileMangement::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteFileMangement::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteFileMangement::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteFileMangement::clear_message_type() {
  if (message_type_ != &::google::protobuf::internal::kEmptyString) {
    message_type_->clear();
  }
  clear_has_message_type();
}
inline const ::std::string& RemoteFileMangement::message_type() const {
  return *message_type_;
}
inline void RemoteFileMangement::set_message_type(const ::std::string& value) {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  message_type_->assign(value);
}
inline void RemoteFileMangement::set_message_type(const char* value) {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  message_type_->assign(value);
}
inline void RemoteFileMangement::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  message_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteFileMangement::mutable_message_type() {
  set_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    message_type_ = new ::std::string;
  }
  return message_type_;
}
inline ::std::string* RemoteFileMangement::release_message_type() {
  clear_has_message_type();
  if (message_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_type_;
    message_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteFileMangement::set_allocated_message_type(::std::string* message_type) {
  if (message_type_ != &::google::protobuf::internal::kEmptyString) {
    delete message_type_;
  }
  if (message_type) {
    set_has_message_type();
    message_type_ = message_type;
  } else {
    clear_has_message_type();
    message_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes input = 2;
inline bool RemoteFileMangement::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteFileMangement::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteFileMangement::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteFileMangement::clear_input() {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    input_->clear();
  }
  clear_has_input();
}
inline const ::std::string& RemoteFileMangement::input() const {
  return *input_;
}
inline void RemoteFileMangement::set_input(const ::std::string& value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void RemoteFileMangement::set_input(const char* value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void RemoteFileMangement::set_input(const void* value, size_t size) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteFileMangement::mutable_input() {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  return input_;
}
inline ::std::string* RemoteFileMangement::release_input() {
  clear_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_;
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteFileMangement::set_allocated_input(::std::string* input) {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    delete input_;
  }
  if (input) {
    set_has_input();
    input_ = input;
  } else {
    clear_has_input();
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string space_id = 3 [default = ""];
inline bool RemoteFileMangement::has_space_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteFileMangement::set_has_space_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteFileMangement::clear_has_space_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteFileMangement::clear_space_id() {
  if (space_id_ != &::google::protobuf::internal::kEmptyString) {
    space_id_->clear();
  }
  clear_has_space_id();
}
inline const ::std::string& RemoteFileMangement::space_id() const {
  return *space_id_;
}
inline void RemoteFileMangement::set_space_id(const ::std::string& value) {
  set_has_space_id();
  if (space_id_ == &::google::protobuf::internal::kEmptyString) {
    space_id_ = new ::std::string;
  }
  space_id_->assign(value);
}
inline void RemoteFileMangement::set_space_id(const char* value) {
  set_has_space_id();
  if (space_id_ == &::google::protobuf::internal::kEmptyString) {
    space_id_ = new ::std::string;
  }
  space_id_->assign(value);
}
inline void RemoteFileMangement::set_space_id(const char* value, size_t size) {
  set_has_space_id();
  if (space_id_ == &::google::protobuf::internal::kEmptyString) {
    space_id_ = new ::std::string;
  }
  space_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteFileMangement::mutable_space_id() {
  set_has_space_id();
  if (space_id_ == &::google::protobuf::internal::kEmptyString) {
    space_id_ = new ::std::string;
  }
  return space_id_;
}
inline ::std::string* RemoteFileMangement::release_space_id() {
  clear_has_space_id();
  if (space_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = space_id_;
    space_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteFileMangement::set_allocated_space_id(::std::string* space_id) {
  if (space_id_ != &::google::protobuf::internal::kEmptyString) {
    delete space_id_;
  }
  if (space_id) {
    set_has_space_id();
    space_id_ = space_id;
  } else {
    clear_has_space_id();
    space_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetAttr

// required string file_id = 1;
inline bool GetAttr::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAttr::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAttr::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAttr::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& GetAttr::file_id() const {
  return *file_id_;
}
inline void GetAttr::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void GetAttr::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void GetAttr::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAttr::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* GetAttr::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetAttr::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StorageAttibutes

// optional string answer = 1 [default = "ok"];
inline bool StorageAttibutes::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageAttibutes::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageAttibutes::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageAttibutes::clear_answer() {
  if (answer_ != _default_answer_) {
    answer_->assign(*_default_answer_);
  }
  clear_has_answer();
}
inline const ::std::string& StorageAttibutes::answer() const {
  return *answer_;
}
inline void StorageAttibutes::set_answer(const ::std::string& value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void StorageAttibutes::set_answer(const char* value) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(value);
}
inline void StorageAttibutes::set_answer(const char* value, size_t size) {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string;
  }
  answer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorageAttibutes::mutable_answer() {
  set_has_answer();
  if (answer_ == _default_answer_) {
    answer_ = new ::std::string(*_default_answer_);
  }
  return answer_;
}
inline ::std::string* StorageAttibutes::release_answer() {
  clear_has_answer();
  if (answer_ == _default_answer_) {
    return NULL;
  } else {
    ::std::string* temp = answer_;
    answer_ = const_cast< ::std::string*>(_default_answer_);
    return temp;
  }
}
inline void StorageAttibutes::set_allocated_answer(::std::string* answer) {
  if (answer_ != _default_answer_) {
    delete answer_;
  }
  if (answer) {
    set_has_answer();
    answer_ = answer;
  } else {
    clear_has_answer();
    answer_ = const_cast< ::std::string*>(_default_answer_);
  }
}

// optional int64 dev = 2 [default = 0];
inline bool StorageAttibutes::has_dev() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageAttibutes::set_has_dev() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageAttibutes::clear_has_dev() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageAttibutes::clear_dev() {
  dev_ = GOOGLE_LONGLONG(0);
  clear_has_dev();
}
inline ::google::protobuf::int64 StorageAttibutes::dev() const {
  return dev_;
}
inline void StorageAttibutes::set_dev(::google::protobuf::int64 value) {
  set_has_dev();
  dev_ = value;
}

// optional int64 ino = 3 [default = 0];
inline bool StorageAttibutes::has_ino() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageAttibutes::set_has_ino() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageAttibutes::clear_has_ino() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageAttibutes::clear_ino() {
  ino_ = GOOGLE_LONGLONG(0);
  clear_has_ino();
}
inline ::google::protobuf::int64 StorageAttibutes::ino() const {
  return ino_;
}
inline void StorageAttibutes::set_ino(::google::protobuf::int64 value) {
  set_has_ino();
  ino_ = value;
}

// optional int64 mode = 4 [default = 0];
inline bool StorageAttibutes::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StorageAttibutes::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StorageAttibutes::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StorageAttibutes::clear_mode() {
  mode_ = GOOGLE_LONGLONG(0);
  clear_has_mode();
}
inline ::google::protobuf::int64 StorageAttibutes::mode() const {
  return mode_;
}
inline void StorageAttibutes::set_mode(::google::protobuf::int64 value) {
  set_has_mode();
  mode_ = value;
}

// optional int64 nlink = 5 [default = 1];
inline bool StorageAttibutes::has_nlink() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StorageAttibutes::set_has_nlink() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StorageAttibutes::clear_has_nlink() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StorageAttibutes::clear_nlink() {
  nlink_ = GOOGLE_LONGLONG(1);
  clear_has_nlink();
}
inline ::google::protobuf::int64 StorageAttibutes::nlink() const {
  return nlink_;
}
inline void StorageAttibutes::set_nlink(::google::protobuf::int64 value) {
  set_has_nlink();
  nlink_ = value;
}

// optional int64 uid = 6 [default = 0];
inline bool StorageAttibutes::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StorageAttibutes::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StorageAttibutes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StorageAttibutes::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 StorageAttibutes::uid() const {
  return uid_;
}
inline void StorageAttibutes::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int64 gid = 7 [default = 0];
inline bool StorageAttibutes::has_gid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StorageAttibutes::set_has_gid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StorageAttibutes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StorageAttibutes::clear_gid() {
  gid_ = GOOGLE_LONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::int64 StorageAttibutes::gid() const {
  return gid_;
}
inline void StorageAttibutes::set_gid(::google::protobuf::int64 value) {
  set_has_gid();
  gid_ = value;
}

// optional int64 rdev = 8 [default = 0];
inline bool StorageAttibutes::has_rdev() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StorageAttibutes::set_has_rdev() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StorageAttibutes::clear_has_rdev() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StorageAttibutes::clear_rdev() {
  rdev_ = GOOGLE_LONGLONG(0);
  clear_has_rdev();
}
inline ::google::protobuf::int64 StorageAttibutes::rdev() const {
  return rdev_;
}
inline void StorageAttibutes::set_rdev(::google::protobuf::int64 value) {
  set_has_rdev();
  rdev_ = value;
}

// optional int64 size = 9 [default = 0];
inline bool StorageAttibutes::has_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StorageAttibutes::set_has_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StorageAttibutes::clear_has_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StorageAttibutes::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 StorageAttibutes::size() const {
  return size_;
}
inline void StorageAttibutes::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// optional int64 blksize = 10 [default = 0];
inline bool StorageAttibutes::has_blksize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StorageAttibutes::set_has_blksize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StorageAttibutes::clear_has_blksize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StorageAttibutes::clear_blksize() {
  blksize_ = GOOGLE_LONGLONG(0);
  clear_has_blksize();
}
inline ::google::protobuf::int64 StorageAttibutes::blksize() const {
  return blksize_;
}
inline void StorageAttibutes::set_blksize(::google::protobuf::int64 value) {
  set_has_blksize();
  blksize_ = value;
}

// optional int64 blocks = 11 [default = 0];
inline bool StorageAttibutes::has_blocks() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StorageAttibutes::set_has_blocks() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StorageAttibutes::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StorageAttibutes::clear_blocks() {
  blocks_ = GOOGLE_LONGLONG(0);
  clear_has_blocks();
}
inline ::google::protobuf::int64 StorageAttibutes::blocks() const {
  return blocks_;
}
inline void StorageAttibutes::set_blocks(::google::protobuf::int64 value) {
  set_has_blocks();
  blocks_ = value;
}

// optional int64 atime = 12 [default = 0];
inline bool StorageAttibutes::has_atime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StorageAttibutes::set_has_atime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StorageAttibutes::clear_has_atime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StorageAttibutes::clear_atime() {
  atime_ = GOOGLE_LONGLONG(0);
  clear_has_atime();
}
inline ::google::protobuf::int64 StorageAttibutes::atime() const {
  return atime_;
}
inline void StorageAttibutes::set_atime(::google::protobuf::int64 value) {
  set_has_atime();
  atime_ = value;
}

// optional int64 mtime = 13 [default = 0];
inline bool StorageAttibutes::has_mtime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StorageAttibutes::set_has_mtime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StorageAttibutes::clear_has_mtime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StorageAttibutes::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::int64 StorageAttibutes::mtime() const {
  return mtime_;
}
inline void StorageAttibutes::set_mtime(::google::protobuf::int64 value) {
  set_has_mtime();
  mtime_ = value;
}

// optional int64 ctime = 14 [default = 0];
inline bool StorageAttibutes::has_ctime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StorageAttibutes::set_has_ctime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StorageAttibutes::clear_has_ctime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StorageAttibutes::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::int64 StorageAttibutes::ctime() const {
  return ctime_;
}
inline void StorageAttibutes::set_ctime(::google::protobuf::int64 value) {
  set_has_ctime();
  ctime_ = value;
}

// -------------------------------------------------------------------

// CreateFile

// required string file_id = 1;
inline bool CreateFile::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateFile::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateFile::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateFile::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& CreateFile::file_id() const {
  return *file_id_;
}
inline void CreateFile::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void CreateFile::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void CreateFile::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateFile::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* CreateFile::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateFile::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 mode = 2;
inline bool CreateFile::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateFile::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateFile::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateFile::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 CreateFile::mode() const {
  return mode_;
}
inline void CreateFile::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// DeleteFileAtStorage

// required string file_id = 1;
inline bool DeleteFileAtStorage::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteFileAtStorage::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteFileAtStorage::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteFileAtStorage::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& DeleteFileAtStorage::file_id() const {
  return *file_id_;
}
inline void DeleteFileAtStorage::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void DeleteFileAtStorage::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void DeleteFileAtStorage::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteFileAtStorage::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* DeleteFileAtStorage::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeleteFileAtStorage::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TruncateFile

// required string file_id = 1;
inline bool TruncateFile::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TruncateFile::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TruncateFile::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TruncateFile::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& TruncateFile::file_id() const {
  return *file_id_;
}
inline void TruncateFile::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void TruncateFile::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void TruncateFile::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TruncateFile::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* TruncateFile::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TruncateFile::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 length = 2;
inline bool TruncateFile::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TruncateFile::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TruncateFile::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TruncateFile::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::int64 TruncateFile::length() const {
  return length_;
}
inline void TruncateFile::set_length(::google::protobuf::int64 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// ReadFile

// required string file_id = 1;
inline bool ReadFile::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadFile::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadFile::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadFile::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& ReadFile::file_id() const {
  return *file_id_;
}
inline void ReadFile::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void ReadFile::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void ReadFile::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReadFile::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* ReadFile::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReadFile::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 size = 2;
inline bool ReadFile::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadFile::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadFile::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadFile::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 ReadFile::size() const {
  return size_;
}
inline void ReadFile::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// optional int64 offset = 3 [default = 0];
inline bool ReadFile::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReadFile::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReadFile::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReadFile::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 ReadFile::offset() const {
  return offset_;
}
inline void ReadFile::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// FileData

// required string answer_status = 1;
inline bool FileData::has_answer_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileData::set_has_answer_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileData::clear_has_answer_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileData::clear_answer_status() {
  if (answer_status_ != &::google::protobuf::internal::kEmptyString) {
    answer_status_->clear();
  }
  clear_has_answer_status();
}
inline const ::std::string& FileData::answer_status() const {
  return *answer_status_;
}
inline void FileData::set_answer_status(const ::std::string& value) {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  answer_status_->assign(value);
}
inline void FileData::set_answer_status(const char* value) {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  answer_status_->assign(value);
}
inline void FileData::set_answer_status(const char* value, size_t size) {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  answer_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileData::mutable_answer_status() {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  return answer_status_;
}
inline ::std::string* FileData::release_answer_status() {
  clear_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = answer_status_;
    answer_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileData::set_allocated_answer_status(::std::string* answer_status) {
  if (answer_status_ != &::google::protobuf::internal::kEmptyString) {
    delete answer_status_;
  }
  if (answer_status) {
    set_has_answer_status();
    answer_status_ = answer_status;
  } else {
    clear_has_answer_status();
    answer_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operation_guid = 2;
inline bool FileData::has_operation_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileData::set_has_operation_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileData::clear_has_operation_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileData::clear_operation_guid() {
  if (operation_guid_ != &::google::protobuf::internal::kEmptyString) {
    operation_guid_->clear();
  }
  clear_has_operation_guid();
}
inline const ::std::string& FileData::operation_guid() const {
  return *operation_guid_;
}
inline void FileData::set_operation_guid(const ::std::string& value) {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  operation_guid_->assign(value);
}
inline void FileData::set_operation_guid(const char* value) {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  operation_guid_->assign(value);
}
inline void FileData::set_operation_guid(const char* value, size_t size) {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  operation_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileData::mutable_operation_guid() {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  return operation_guid_;
}
inline ::std::string* FileData::release_operation_guid() {
  clear_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operation_guid_;
    operation_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileData::set_allocated_operation_guid(::std::string* operation_guid) {
  if (operation_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete operation_guid_;
  }
  if (operation_guid) {
    set_has_operation_guid();
    operation_guid_ = operation_guid;
  } else {
    clear_has_operation_guid();
    operation_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string new_data_source = 3;
inline bool FileData::has_new_data_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileData::set_has_new_data_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileData::clear_has_new_data_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileData::clear_new_data_source() {
  if (new_data_source_ != &::google::protobuf::internal::kEmptyString) {
    new_data_source_->clear();
  }
  clear_has_new_data_source();
}
inline const ::std::string& FileData::new_data_source() const {
  return *new_data_source_;
}
inline void FileData::set_new_data_source(const ::std::string& value) {
  set_has_new_data_source();
  if (new_data_source_ == &::google::protobuf::internal::kEmptyString) {
    new_data_source_ = new ::std::string;
  }
  new_data_source_->assign(value);
}
inline void FileData::set_new_data_source(const char* value) {
  set_has_new_data_source();
  if (new_data_source_ == &::google::protobuf::internal::kEmptyString) {
    new_data_source_ = new ::std::string;
  }
  new_data_source_->assign(value);
}
inline void FileData::set_new_data_source(const char* value, size_t size) {
  set_has_new_data_source();
  if (new_data_source_ == &::google::protobuf::internal::kEmptyString) {
    new_data_source_ = new ::std::string;
  }
  new_data_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileData::mutable_new_data_source() {
  set_has_new_data_source();
  if (new_data_source_ == &::google::protobuf::internal::kEmptyString) {
    new_data_source_ = new ::std::string;
  }
  return new_data_source_;
}
inline ::std::string* FileData::release_new_data_source() {
  clear_has_new_data_source();
  if (new_data_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_data_source_;
    new_data_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileData::set_allocated_new_data_source(::std::string* new_data_source) {
  if (new_data_source_ != &::google::protobuf::internal::kEmptyString) {
    delete new_data_source_;
  }
  if (new_data_source) {
    set_has_new_data_source();
    new_data_source_ = new_data_source;
  } else {
    clear_has_new_data_source();
    new_data_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 4;
inline bool FileData::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileData::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileData::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& FileData::data() const {
  return *data_;
}
inline void FileData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FileData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FileData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* FileData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WriteFile

// required string file_id = 1;
inline bool WriteFile::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WriteFile::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WriteFile::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WriteFile::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& WriteFile::file_id() const {
  return *file_id_;
}
inline void WriteFile::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void WriteFile::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void WriteFile::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WriteFile::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* WriteFile::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WriteFile::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 size = 2;
inline bool WriteFile::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WriteFile::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WriteFile::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WriteFile::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 WriteFile::size() const {
  return size_;
}
inline void WriteFile::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// optional bytes data = 3;
inline bool WriteFile::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WriteFile::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WriteFile::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WriteFile::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& WriteFile::data() const {
  return *data_;
}
inline void WriteFile::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void WriteFile::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void WriteFile::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WriteFile::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* WriteFile::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WriteFile::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 offset = 4 [default = 0];
inline bool WriteFile::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WriteFile::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WriteFile::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WriteFile::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 WriteFile::offset() const {
  return offset_;
}
inline void WriteFile::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// WriteInfo

// required string answer_status = 1;
inline bool WriteInfo::has_answer_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WriteInfo::set_has_answer_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WriteInfo::clear_has_answer_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WriteInfo::clear_answer_status() {
  if (answer_status_ != &::google::protobuf::internal::kEmptyString) {
    answer_status_->clear();
  }
  clear_has_answer_status();
}
inline const ::std::string& WriteInfo::answer_status() const {
  return *answer_status_;
}
inline void WriteInfo::set_answer_status(const ::std::string& value) {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  answer_status_->assign(value);
}
inline void WriteInfo::set_answer_status(const char* value) {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  answer_status_->assign(value);
}
inline void WriteInfo::set_answer_status(const char* value, size_t size) {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  answer_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WriteInfo::mutable_answer_status() {
  set_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    answer_status_ = new ::std::string;
  }
  return answer_status_;
}
inline ::std::string* WriteInfo::release_answer_status() {
  clear_has_answer_status();
  if (answer_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = answer_status_;
    answer_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WriteInfo::set_allocated_answer_status(::std::string* answer_status) {
  if (answer_status_ != &::google::protobuf::internal::kEmptyString) {
    delete answer_status_;
  }
  if (answer_status) {
    set_has_answer_status();
    answer_status_ = answer_status;
  } else {
    clear_has_answer_status();
    answer_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 bytes_written = 2 [default = 0];
inline bool WriteInfo::has_bytes_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WriteInfo::set_has_bytes_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WriteInfo::clear_has_bytes_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WriteInfo::clear_bytes_written() {
  bytes_written_ = GOOGLE_LONGLONG(0);
  clear_has_bytes_written();
}
inline ::google::protobuf::int64 WriteInfo::bytes_written() const {
  return bytes_written_;
}
inline void WriteInfo::set_bytes_written(::google::protobuf::int64 value) {
  set_has_bytes_written();
  bytes_written_ = value;
}

// optional string operation_guid = 3;
inline bool WriteInfo::has_operation_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WriteInfo::set_has_operation_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WriteInfo::clear_has_operation_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WriteInfo::clear_operation_guid() {
  if (operation_guid_ != &::google::protobuf::internal::kEmptyString) {
    operation_guid_->clear();
  }
  clear_has_operation_guid();
}
inline const ::std::string& WriteInfo::operation_guid() const {
  return *operation_guid_;
}
inline void WriteInfo::set_operation_guid(const ::std::string& value) {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  operation_guid_->assign(value);
}
inline void WriteInfo::set_operation_guid(const char* value) {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  operation_guid_->assign(value);
}
inline void WriteInfo::set_operation_guid(const char* value, size_t size) {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  operation_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WriteInfo::mutable_operation_guid() {
  set_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    operation_guid_ = new ::std::string;
  }
  return operation_guid_;
}
inline ::std::string* WriteInfo::release_operation_guid() {
  clear_has_operation_guid();
  if (operation_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operation_guid_;
    operation_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WriteInfo::set_allocated_operation_guid(::std::string* operation_guid) {
  if (operation_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete operation_guid_;
  }
  if (operation_guid) {
    set_has_operation_guid();
    operation_guid_ = operation_guid;
  } else {
    clear_has_operation_guid();
    operation_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string new_data_listener = 4;
inline bool WriteInfo::has_new_data_listener() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WriteInfo::set_has_new_data_listener() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WriteInfo::clear_has_new_data_listener() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WriteInfo::clear_new_data_listener() {
  if (new_data_listener_ != &::google::protobuf::internal::kEmptyString) {
    new_data_listener_->clear();
  }
  clear_has_new_data_listener();
}
inline const ::std::string& WriteInfo::new_data_listener() const {
  return *new_data_listener_;
}
inline void WriteInfo::set_new_data_listener(const ::std::string& value) {
  set_has_new_data_listener();
  if (new_data_listener_ == &::google::protobuf::internal::kEmptyString) {
    new_data_listener_ = new ::std::string;
  }
  new_data_listener_->assign(value);
}
inline void WriteInfo::set_new_data_listener(const char* value) {
  set_has_new_data_listener();
  if (new_data_listener_ == &::google::protobuf::internal::kEmptyString) {
    new_data_listener_ = new ::std::string;
  }
  new_data_listener_->assign(value);
}
inline void WriteInfo::set_new_data_listener(const char* value, size_t size) {
  set_has_new_data_listener();
  if (new_data_listener_ == &::google::protobuf::internal::kEmptyString) {
    new_data_listener_ = new ::std::string;
  }
  new_data_listener_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WriteInfo::mutable_new_data_listener() {
  set_has_new_data_listener();
  if (new_data_listener_ == &::google::protobuf::internal::kEmptyString) {
    new_data_listener_ = new ::std::string;
  }
  return new_data_listener_;
}
inline ::std::string* WriteInfo::release_new_data_listener() {
  clear_has_new_data_listener();
  if (new_data_listener_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_data_listener_;
    new_data_listener_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WriteInfo::set_allocated_new_data_listener(::std::string* new_data_listener) {
  if (new_data_listener_ != &::google::protobuf::internal::kEmptyString) {
    delete new_data_listener_;
  }
  if (new_data_listener) {
    set_has_new_data_listener();
    new_data_listener_ = new_data_listener;
  } else {
    clear_has_new_data_listener();
    new_data_listener_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangePermsAtStorage

// required string file_id = 1;
inline bool ChangePermsAtStorage::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePermsAtStorage::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePermsAtStorage::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePermsAtStorage::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& ChangePermsAtStorage::file_id() const {
  return *file_id_;
}
inline void ChangePermsAtStorage::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void ChangePermsAtStorage::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void ChangePermsAtStorage::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePermsAtStorage::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* ChangePermsAtStorage::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangePermsAtStorage::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 perms = 2;
inline bool ChangePermsAtStorage::has_perms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePermsAtStorage::set_has_perms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePermsAtStorage::clear_has_perms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePermsAtStorage::clear_perms() {
  perms_ = 0;
  clear_has_perms();
}
inline ::google::protobuf::int32 ChangePermsAtStorage::perms() const {
  return perms_;
}
inline void ChangePermsAtStorage::set_perms(::google::protobuf::int32 value) {
  set_has_perms();
  perms_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote_file_management
}  // namespace protocol
}  // namespace veil

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_remote_5ffile_5fmanagement_2eproto__INCLUDED
